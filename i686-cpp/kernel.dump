
kernel.elf:     file format elf32-i386


Disassembly of section .text:

00101000 <start>:
  101000:	89 25 00 60 11 00    	mov    DWORD PTR ds:0x116000,esp
  101006:	50                   	push   eax
  101007:	53                   	push   ebx
  101008:	e8 a3 0b 00 00       	call   101bb0 <kernel_main>
  10100d:	f4                   	hlt    

0010100e <hang>:
  10100e:	eb fe                	jmp    10100e <hang>

00101010 <halt()>:
static_assert(string_to_int(test_string) == 987);
static_assert(int_to_string(15500) == "15500");
static_assert(int_to_string(string_to_int(test_string)) == "987");
} // namespace

[[noreturn]] void halt() {
  101010:	55                   	push   ebp
  101011:	89 e5                	mov    ebp,esp
    asm("hlt");
  101013:	f4                   	hlt    
  101014:	90                   	nop
  101015:	90                   	nop
  101016:	90                   	nop
  101017:	90                   	nop
  101018:	90                   	nop
  101019:	90                   	nop
  10101a:	90                   	nop
  10101b:	90                   	nop
  10101c:	90                   	nop
  10101d:	90                   	nop
  10101e:	90                   	nop
  10101f:	90                   	nop
    while (true)
  101020:	eb fe                	jmp    101020 <halt()+0x10>
  101022:	90                   	nop
  101023:	90                   	nop
  101024:	90                   	nop
  101025:	90                   	nop
  101026:	90                   	nop
  101027:	90                   	nop
  101028:	90                   	nop
  101029:	90                   	nop
  10102a:	90                   	nop
  10102b:	90                   	nop
  10102c:	90                   	nop
  10102d:	90                   	nop
  10102e:	90                   	nop
  10102f:	90                   	nop

00101030 <term::set(int, unsigned char, char)>:

constexpr auto index(int col = Term.col, int row = Term.row) {
    return (COLS * row) + col;
}

void set(int index, uint8 colour, char symbol) {
  101030:	55                   	push   ebp
  101031:	89 e5                	mov    ebp,esp
  101033:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  101036:	0f be 4d 10          	movsx  ecx,BYTE PTR [ebp+0x10]
    VGA_BUF[index] = static_cast<uint16>((colour << 8) | symbol);
  10103a:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  10103d:	c1 e2 08             	shl    edx,0x8
  101040:	09 ca                	or     edx,ecx
  101042:	8b 0d 00 50 10 00    	mov    ecx,DWORD PTR ds:0x105000
  101048:	66 89 14 41          	mov    WORD PTR [ecx+eax*2],dx
}
  10104c:	5d                   	pop    ebp
  10104d:	c3                   	ret    
  10104e:	90                   	nop
  10104f:	90                   	nop

00101050 <term::clear()>:

void clear() {
  101050:	55                   	push   ebp
  101051:	89 e5                	mov    ebp,esp
  101053:	a1 0c 50 10 00       	mov    eax,ds:0x10500c
  101058:	c1 e0 08             	shl    eax,0x8
  10105b:	83 c8 20             	or     eax,0x20
  10105e:	b9 00 0f 00 00       	mov    ecx,0xf00
    for (int a = 0; a < COLS; a++) {
  101063:	03 0d 00 50 10 00    	add    ecx,DWORD PTR ds:0x105000
  101069:	ba b0 ff ff ff       	mov    edx,0xffffffb0
  10106e:	90                   	nop
  10106f:	90                   	nop
    VGA_BUF[index] = static_cast<uint16>((colour << 8) | symbol);
  101070:	66 89 84 51 a0 f1 ff 	mov    WORD PTR [ecx+edx*2-0xe60],ax
  101077:	ff 
  101078:	66 89 84 51 40 f2 ff 	mov    WORD PTR [ecx+edx*2-0xdc0],ax
  10107f:	ff 
  101080:	66 89 84 51 e0 f2 ff 	mov    WORD PTR [ecx+edx*2-0xd20],ax
  101087:	ff 
  101088:	66 89 84 51 80 f3 ff 	mov    WORD PTR [ecx+edx*2-0xc80],ax
  10108f:	ff 
  101090:	66 89 84 51 20 f4 ff 	mov    WORD PTR [ecx+edx*2-0xbe0],ax
  101097:	ff 
  101098:	66 89 84 51 c0 f4 ff 	mov    WORD PTR [ecx+edx*2-0xb40],ax
  10109f:	ff 
  1010a0:	66 89 84 51 60 f5 ff 	mov    WORD PTR [ecx+edx*2-0xaa0],ax
  1010a7:	ff 
  1010a8:	66 89 84 51 00 f6 ff 	mov    WORD PTR [ecx+edx*2-0xa00],ax
  1010af:	ff 
  1010b0:	66 89 84 51 a0 f6 ff 	mov    WORD PTR [ecx+edx*2-0x960],ax
  1010b7:	ff 
  1010b8:	66 89 84 51 40 f7 ff 	mov    WORD PTR [ecx+edx*2-0x8c0],ax
  1010bf:	ff 
  1010c0:	66 89 84 51 e0 f7 ff 	mov    WORD PTR [ecx+edx*2-0x820],ax
  1010c7:	ff 
  1010c8:	66 89 84 51 80 f8 ff 	mov    WORD PTR [ecx+edx*2-0x780],ax
  1010cf:	ff 
  1010d0:	66 89 84 51 20 f9 ff 	mov    WORD PTR [ecx+edx*2-0x6e0],ax
  1010d7:	ff 
  1010d8:	66 89 84 51 c0 f9 ff 	mov    WORD PTR [ecx+edx*2-0x640],ax
  1010df:	ff 
  1010e0:	66 89 84 51 60 fa ff 	mov    WORD PTR [ecx+edx*2-0x5a0],ax
  1010e7:	ff 
  1010e8:	66 89 84 51 00 fb ff 	mov    WORD PTR [ecx+edx*2-0x500],ax
  1010ef:	ff 
  1010f0:	66 89 84 51 a0 fb ff 	mov    WORD PTR [ecx+edx*2-0x460],ax
  1010f7:	ff 
  1010f8:	66 89 84 51 40 fc ff 	mov    WORD PTR [ecx+edx*2-0x3c0],ax
  1010ff:	ff 
  101100:	66 89 84 51 e0 fc ff 	mov    WORD PTR [ecx+edx*2-0x320],ax
  101107:	ff 
  101108:	66 89 84 51 80 fd ff 	mov    WORD PTR [ecx+edx*2-0x280],ax
  10110f:	ff 
  101110:	66 89 84 51 20 fe ff 	mov    WORD PTR [ecx+edx*2-0x1e0],ax
  101117:	ff 
  101118:	66 89 84 51 c0 fe ff 	mov    WORD PTR [ecx+edx*2-0x140],ax
  10111f:	ff 
  101120:	66 89 84 51 60 ff ff 	mov    WORD PTR [ecx+edx*2-0xa0],ax
  101127:	ff 
  101128:	66 89 04 51          	mov    WORD PTR [ecx+edx*2],ax
  10112c:	66 89 84 51 a0 00 00 	mov    WORD PTR [ecx+edx*2+0xa0],ax
  101133:	00 
    for (int a = 0; a < COLS; a++) {
  101134:	42                   	inc    edx
  101135:	0f 85 35 ff ff ff    	jne    101070 <term::clear()+0x20>
        for (int b = 0; b < ROWS; b++) {
            set(index(a, b), Term.colour, ' ');
        }
    }
}
  10113b:	5d                   	pop    ebp
  10113c:	c3                   	ret    
  10113d:	90                   	nop
  10113e:	90                   	nop
  10113f:	90                   	nop

00101140 <term::write(char)>:

void write(char c) {
  101140:	55                   	push   ebp
  101141:	89 e5                	mov    ebp,esp
    switch (c) {
  101143:	0f be 45 08          	movsx  eax,BYTE PTR [ebp+0x8]
  101147:	83 f8 09             	cmp    eax,0x9
  10114a:	74 43                	je     10118f <term::write(char)+0x4f>
  10114c:	83 f8 0a             	cmp    eax,0xa
  10114f:	75 59                	jne    1011aa <term::write(char)+0x6a>
        if (!flipped) {
  101151:	80 3d 0d 50 10 00 00 	cmp    BYTE PTR ds:0x10500d,0x0
  101158:	0f 84 95 00 00 00    	je     1011f3 <term::write(char)+0xb3>
            increment_cursor(row, col, ROWS, COLS, ROWS - (row % ROWS));
  10115e:	8b 0d 08 50 10 00    	mov    ecx,DWORD PTR ds:0x105008
  101164:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  101169:	89 c8                	mov    eax,ecx
  10116b:	f7 ea                	imul   edx
  10116d:	89 d0                	mov    eax,edx
  10116f:	c1 e8 1f             	shr    eax,0x1f
  101172:	c1 fa 03             	sar    edx,0x3
  101175:	01 c2                	add    edx,eax
  101177:	8d 04 92             	lea    eax,[edx+edx*4]
  10117a:	8d 04 80             	lea    eax,[eax+eax*4]
  10117d:	29 c8                	sub    eax,ecx
  10117f:	83 c0 19             	add    eax,0x19
  101182:	b9 08 50 10 00       	mov    ecx,0x105008
  101187:	ba 04 50 10 00       	mov    edx,0x105004
  10118c:	50                   	push   eax
  10118d:	eb 56                	jmp    1011e5 <term::write(char)+0xa5>
        if (!flipped) {
  10118f:	80 3d 0d 50 10 00 00 	cmp    BYTE PTR ds:0x10500d,0x0
  101196:	0f 84 88 00 00 00    	je     101224 <term::write(char)+0xe4>
            increment_cursor(row, col, ROWS, COLS, n);
  10119c:	b9 08 50 10 00       	mov    ecx,0x105008
  1011a1:	ba 04 50 10 00       	mov    edx,0x105004
  1011a6:	6a 04                	push   0x4
  1011a8:	eb 3b                	jmp    1011e5 <term::write(char)+0xa5>
        break;
    case '\t':
        Term.advance(4);
        break;
    default:
        set(index(), Term.colour, c);
  1011aa:	8b 0d 08 50 10 00    	mov    ecx,DWORD PTR ds:0x105008
    return (COLS * row) + col;
  1011b0:	8d 0c 89             	lea    ecx,[ecx+ecx*4]
  1011b3:	c1 e1 04             	shl    ecx,0x4
  1011b6:	03 0d 04 50 10 00    	add    ecx,DWORD PTR ds:0x105004
    VGA_BUF[index] = static_cast<uint16>((colour << 8) | symbol);
  1011bc:	8b 15 0c 50 10 00    	mov    edx,DWORD PTR ds:0x10500c
  1011c2:	c1 e2 08             	shl    edx,0x8
  1011c5:	09 c2                	or     edx,eax
  1011c7:	a1 00 50 10 00       	mov    eax,ds:0x105000
  1011cc:	66 89 14 48          	mov    WORD PTR [eax+ecx*2],dx
        if (!flipped) {
  1011d0:	80 3d 0d 50 10 00 00 	cmp    BYTE PTR ds:0x10500d,0x0
  1011d7:	74 59                	je     101232 <term::write(char)+0xf2>
            increment_cursor(row, col, ROWS, COLS, n);
  1011d9:	b9 08 50 10 00       	mov    ecx,0x105008
  1011de:	ba 04 50 10 00       	mov    edx,0x105004
  1011e3:	6a 01                	push   0x1
  1011e5:	6a 50                	push   0x50
  1011e7:	6a 19                	push   0x19
  1011e9:	e8 02 21 00 00       	call   1032f0 <term::$_0::increment_cursor(int&, int&, int, int, int)>
  1011ee:	83 c4 0c             	add    esp,0xc
        Term.advance();
        break;
    }
}
  1011f1:	5d                   	pop    ebp
  1011f2:	c3                   	ret    
            increment_cursor(col, row, COLS, ROWS, COLS - (col % COLS));
  1011f3:	8b 0d 04 50 10 00    	mov    ecx,DWORD PTR ds:0x105004
  1011f9:	ba 67 66 66 66       	mov    edx,0x66666667
  1011fe:	89 c8                	mov    eax,ecx
  101200:	f7 ea                	imul   edx
  101202:	89 d0                	mov    eax,edx
  101204:	c1 e8 1f             	shr    eax,0x1f
  101207:	c1 fa 05             	sar    edx,0x5
  10120a:	01 c2                	add    edx,eax
  10120c:	c1 e2 04             	shl    edx,0x4
  10120f:	8d 04 92             	lea    eax,[edx+edx*4]
  101212:	29 c8                	sub    eax,ecx
  101214:	83 c0 50             	add    eax,0x50
  101217:	b9 04 50 10 00       	mov    ecx,0x105004
  10121c:	ba 08 50 10 00       	mov    edx,0x105008
  101221:	50                   	push   eax
  101222:	eb 1a                	jmp    10123e <term::write(char)+0xfe>
            increment_cursor(col, row, COLS, ROWS, n);
  101224:	b9 04 50 10 00       	mov    ecx,0x105004
  101229:	ba 08 50 10 00       	mov    edx,0x105008
  10122e:	6a 04                	push   0x4
  101230:	eb 0c                	jmp    10123e <term::write(char)+0xfe>
  101232:	b9 04 50 10 00       	mov    ecx,0x105004
  101237:	ba 08 50 10 00       	mov    edx,0x105008
  10123c:	6a 01                	push   0x1
  10123e:	6a 19                	push   0x19
  101240:	6a 50                	push   0x50
  101242:	e8 a9 20 00 00       	call   1032f0 <term::$_0::increment_cursor(int&, int&, int, int, int)>
  101247:	83 c4 0c             	add    esp,0xc
}
  10124a:	5d                   	pop    ebp
  10124b:	c3                   	ret    
  10124c:	90                   	nop
  10124d:	90                   	nop
  10124e:	90                   	nop
  10124f:	90                   	nop

00101250 <term::write(char const*)>:

void write(const char *s) {
  101250:	55                   	push   ebp
  101251:	89 e5                	mov    ebp,esp
  101253:	56                   	push   esi
  101254:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
    for (int a = 0; s[a] != 0; a++) {
  101257:	8a 06                	mov    al,BYTE PTR [esi]
  101259:	84 c0                	test   al,al
  10125b:	74 17                	je     101274 <term::write(char const*)+0x24>
  10125d:	46                   	inc    esi
  10125e:	90                   	nop
  10125f:	90                   	nop
        write(s[a]);
  101260:	0f be c0             	movsx  eax,al
  101263:	50                   	push   eax
  101264:	e8 d7 fe ff ff       	call   101140 <term::write(char)>
  101269:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10126c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10126f:	46                   	inc    esi
  101270:	84 c0                	test   al,al
  101272:	75 ec                	jne    101260 <term::write(char const*)+0x10>
    }
}
  101274:	5e                   	pop    esi
  101275:	5d                   	pop    ebp
  101276:	c3                   	ret    
  101277:	90                   	nop
  101278:	90                   	nop
  101279:	90                   	nop
  10127a:	90                   	nop
  10127b:	90                   	nop
  10127c:	90                   	nop
  10127d:	90                   	nop
  10127e:	90                   	nop
  10127f:	90                   	nop

00101280 <memset>:
#include "initializer_list.hpp"

/**
 * Auto-referenced by clang for some big initializations.
 */
extern "C" void *memset(void *dest, int ch, uint32 count) {
  101280:	55                   	push   ebp
  101281:	89 e5                	mov    ebp,esp
  101283:	56                   	push   esi
  101284:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
  101287:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
    for (uint32 a = 0; a < count; a++)
  10128a:	85 c9                	test   ecx,ecx
  10128c:	74 18                	je     1012a6 <memset+0x26>
  10128e:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  101291:	89 c6                	mov    esi,eax
  101293:	90                   	nop
  101294:	90                   	nop
  101295:	90                   	nop
  101296:	90                   	nop
  101297:	90                   	nop
  101298:	90                   	nop
  101299:	90                   	nop
  10129a:	90                   	nop
  10129b:	90                   	nop
  10129c:	90                   	nop
  10129d:	90                   	nop
  10129e:	90                   	nop
  10129f:	90                   	nop
        reinterpret_cast<uint8 *>(dest)[a] = static_cast<uint8>(ch);
  1012a0:	88 16                	mov    BYTE PTR [esi],dl
    for (uint32 a = 0; a < count; a++)
  1012a2:	46                   	inc    esi
  1012a3:	49                   	dec    ecx
  1012a4:	75 fa                	jne    1012a0 <memset+0x20>
    return dest;
  1012a6:	5e                   	pop    esi
  1012a7:	5d                   	pop    ebp
  1012a8:	c3                   	ret    
  1012a9:	90                   	nop
  1012aa:	90                   	nop
  1012ab:	90                   	nop
  1012ac:	90                   	nop
  1012ad:	90                   	nop
  1012ae:	90                   	nop
  1012af:	90                   	nop

001012b0 <operator new(unsigned int)>:

allocator<4 * sizeof(uint32), 1000> fast_allocator;

} // namespace

void *operator new(uint32 count) {
  1012b0:	55                   	push   ebp
  1012b1:	89 e5                	mov    ebp,esp
  1012b3:	53                   	push   ebx
  1012b4:	56                   	push   esi
  1012b5:	83 e4 f8             	and    esp,0xfffffff8
  1012b8:	83 ec 28             	sub    esp,0x28
    if (count >= 4 * sizeof(uint32)) {
  1012bb:	83 7d 08 10          	cmp    DWORD PTR [ebp+0x8],0x10
  1012bf:	0f 83 8c 00 00 00    	jae    101351 <operator new(unsigned int)+0xa1>
        if (blocks >= BN - next_free || !find_next_free())
  1012c5:	a1 00 60 11 00       	mov    eax,ds:0x116000
  1012ca:	b9 e8 03 00 00       	mov    ecx,0x3e8
  1012cf:	29 c1                	sub    ecx,eax
  1012d1:	83 f9 02             	cmp    ecx,0x2
  1012d4:	72 2c                	jb     101302 <operator new(unsigned int)+0x52>
  1012d6:	31 c9                	xor    ecx,ecx
  1012d8:	90                   	nop
  1012d9:	90                   	nop
  1012da:	90                   	nop
  1012db:	90                   	nop
  1012dc:	90                   	nop
  1012dd:	90                   	nop
  1012de:	90                   	nop
  1012df:	90                   	nop
        auto b = bytes_[i / 8];
  1012e0:	89 ca                	mov    edx,ecx
  1012e2:	c1 ea 03             	shr    edx,0x3
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  1012e5:	0f b6 92 04 60 11 00 	movzx  edx,BYTE PTR [edx+0x116004]
        return (b & (1 << (i % 8))) != 0;
  1012ec:	89 cb                	mov    ebx,ecx
  1012ee:	80 e3 07             	and    bl,0x7
  1012f1:	0f b6 f3             	movzx  esi,bl
  1012f4:	0f a3 f2             	bt     edx,esi
            if (!block_list[a])
  1012f7:	73 1d                	jae    101316 <operator new(unsigned int)+0x66>
        for (uint32 a=0; a<BN; a++) {
  1012f9:	41                   	inc    ecx
  1012fa:	81 f9 e8 03 00 00    	cmp    ecx,0x3e8
  101300:	75 de                	jne    1012e0 <operator new(unsigned int)+0x30>
                          int_to_string(4 * sizeof(uint32)).str(),
                          " bytes at once\n");
    }
    auto r = fast_allocator.allocate(1);
    if (!r) {
        term::fatal_error("Allocation failed: ", r.err, "\n");
  101302:	68 9f 00 10 00       	push   0x10009f
  101307:	68 6f 00 10 00       	push   0x10006f
  10130c:	68 b8 00 10 00       	push   0x1000b8
  101311:	e8 1a 23 00 00       	call   103630 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)>
        auto r = reinterpret_cast<uint32 *>(mem::HEAP_START + BS * next_free);
  101316:	c1 e0 04             	shl    eax,0x4
  101319:	05 00 00 20 00       	add    eax,0x200000
  10131e:	31 c9                	xor    ecx,ecx
        auto b = bytes_[i / 8];
  101320:	89 ca                	mov    edx,ecx
  101322:	c1 ea 03             	shr    edx,0x3
  101325:	0f b6 92 04 60 11 00 	movzx  edx,BYTE PTR [edx+0x116004]
        return (b & (1 << (i % 8))) != 0;
  10132c:	89 cb                	mov    ebx,ecx
  10132e:	80 e3 07             	and    bl,0x7
  101331:	0f b6 f3             	movzx  esi,bl
  101334:	0f a3 f2             	bt     edx,esi
            if (!block_list[a])
  101337:	73 0b                	jae    101344 <operator new(unsigned int)+0x94>
        for (uint32 a=0; a<BN; a++) {
  101339:	41                   	inc    ecx
  10133a:	81 f9 e8 03 00 00    	cmp    ecx,0x3e8
  101340:	75 de                	jne    101320 <operator new(unsigned int)+0x70>
  101342:	31 c9                	xor    ecx,ecx
        next_free = find_next_free().value;
  101344:	89 0d 00 60 11 00    	mov    DWORD PTR ds:0x116000,ecx
    }
    return r.value;
  10134a:	8d 65 f8             	lea    esp,[ebp-0x8]
  10134d:	5e                   	pop    esi
  10134e:	5b                   	pop    ebx
  10134f:	5d                   	pop    ebp
  101350:	c3                   	ret    
  101351:	89 e6                	mov    esi,esp
                          int_to_string(4 * sizeof(uint32)).str(),
  101353:	6a 10                	push   0x10
  101355:	56                   	push   esi
  101356:	e8 65 23 00 00       	call   1036c0 <auto int_to_string<10, unsigned int>(unsigned int)>
  10135b:	83 c4 04             	add    esp,0x4
        term::fatal_error("Cannot allocate more than ",
  10135e:	68 cc 00 10 00       	push   0x1000cc
  101363:	56                   	push   esi
  101364:	68 11 00 10 00       	push   0x100011
  101369:	e8 c2 22 00 00       	call   103630 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)>
  10136e:	90                   	nop
  10136f:	90                   	nop

00101370 <operator delete(void*)>:
}

void operator delete(void *p) noexcept { fast_allocator.deallocate(p); }
  101370:	55                   	push   ebp
  101371:	89 e5                	mov    ebp,esp
  101373:	53                   	push   ebx
  101374:	83 e4 f8             	and    esp,0xfffffff8
  101377:	83 ec 10             	sub    esp,0x10
  10137a:	bb 00 00 e0 ff       	mov    ebx,0xffe00000
        auto target = reinterpret_cast<uint32>(p) - mem::HEAP_START;
  10137f:	03 5d 08             	add    ebx,DWORD PTR [ebp+0x8]
  101382:	89 e0                	mov    eax,esp
        return bit_member(*this, static_cast<int>(i));
  101384:	53                   	push   ebx
  101385:	68 04 60 11 00       	push   0x116004
  10138a:	50                   	push   eax
  10138b:	e8 d0 28 00 00       	call   103c60 <mem::bit_sequence<1000u>::bit_member::bit_member(mem::bit_sequence<1000u>&, int)>
  101390:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  101393:	80 7c 24 08 00       	cmp    BYTE PTR [esp+0x8],0x0
        if (!block_list[target]) {
  101398:	74 4e                	je     1013e8 <operator delete(void*)+0x78>
        auto &b = bytes_[i / 8];
  10139a:	89 d8                	mov    eax,ebx
  10139c:	c1 e8 03             	shr    eax,0x3
  10139f:	80 e3 07             	and    bl,0x7
  1013a2:	ba 01 00 00 00       	mov    edx,0x1
  1013a7:	89 d9                	mov    ecx,ebx
  1013a9:	d3 e2                	shl    edx,cl
        if (x)
  1013ab:	f6 d2                	not    dl
  1013ad:	20 90 04 60 11 00    	and    BYTE PTR [eax+0x116004],dl
  1013b3:	31 c0                	xor    eax,eax
  1013b5:	90                   	nop
  1013b6:	90                   	nop
  1013b7:	90                   	nop
  1013b8:	90                   	nop
  1013b9:	90                   	nop
  1013ba:	90                   	nop
  1013bb:	90                   	nop
  1013bc:	90                   	nop
  1013bd:	90                   	nop
  1013be:	90                   	nop
  1013bf:	90                   	nop
        auto b = bytes_[i / 8];
  1013c0:	89 c1                	mov    ecx,eax
  1013c2:	c1 e9 03             	shr    ecx,0x3
  1013c5:	0f b6 89 04 60 11 00 	movzx  ecx,BYTE PTR [ecx+0x116004]
        return (b & (1 << (i % 8))) != 0;
  1013cc:	89 c2                	mov    edx,eax
  1013ce:	80 e2 07             	and    dl,0x7
  1013d1:	0f b6 d2             	movzx  edx,dl
  1013d4:	0f a3 d1             	bt     ecx,edx
            if (!block_list[a])
  1013d7:	73 0a                	jae    1013e3 <operator delete(void*)+0x73>
        for (uint32 a=0; a<BN; a++) {
  1013d9:	40                   	inc    eax
  1013da:	3d e8 03 00 00       	cmp    eax,0x3e8
  1013df:	75 df                	jne    1013c0 <operator delete(void*)+0x50>
  1013e1:	31 c0                	xor    eax,eax
        next_free = find_next_free().value;
  1013e3:	a3 00 60 11 00       	mov    ds:0x116000,eax
void operator delete(void *p) noexcept { fast_allocator.deallocate(p); }
  1013e8:	8d 65 fc             	lea    esp,[ebp-0x4]
  1013eb:	5b                   	pop    ebx
  1013ec:	5d                   	pop    ebp
  1013ed:	c3                   	ret    
  1013ee:	90                   	nop
  1013ef:	90                   	nop

001013f0 <io::send(unsigned short, unsigned char)>:
#pragma once
#include "core.hpp"

namespace io {
void send(uint16 port, uint8 byte) {
  1013f0:	55                   	push   ebp
  1013f1:	89 e5                	mov    ebp,esp
  1013f3:	0f b7 55 08          	movzx  edx,WORD PTR [ebp+0x8]
  1013f7:	8a 45 0c             	mov    al,BYTE PTR [ebp+0xc]
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1013fa:	ee                   	out    dx,al
}
  1013fb:	5d                   	pop    ebp
  1013fc:	c3                   	ret    
  1013fd:	90                   	nop
  1013fe:	90                   	nop
  1013ff:	90                   	nop

00101400 <io::receive(unsigned short)>:

uint8 receive(uint16 port) {
  101400:	55                   	push   ebp
  101401:	89 e5                	mov    ebp,esp
  101403:	0f b7 55 08          	movzx  edx,WORD PTR [ebp+0x8]
    uint8 r;
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101407:	ec                   	in     al,dx
    return r;
  101408:	5d                   	pop    ebp
  101409:	c3                   	ret    
  10140a:	90                   	nop
  10140b:	90                   	nop
  10140c:	90                   	nop
  10140d:	90                   	nop
  10140e:	90                   	nop
  10140f:	90                   	nop

00101410 <ps2::read_config()>:
 * Specialized send/receive functions with timeout
 */
// void send(uint16 port, uint8 byte);
// uint8 receive(uint16 port);

uint8 read_config() {
  101410:	55                   	push   ebp
  101411:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101413:	66 ba 64 00          	mov    dx,0x64
  101417:	b0 20                	mov    al,0x20
  101419:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10141a:	66 ba 60 00          	mov    dx,0x60
  10141e:	ec                   	in     al,dx
    /*5 	    Second PS/2 port clock (1 = disabled, 0 = enabled, only if 2
     * PS/2 ports supported)*/
    /*6 	    First PS/2 port translation (1 = enabled, 0 = disabled)*/
    /*7       Must be zero*/
    send(COMMAND, 0x20);
    return receive(DATA);
  10141f:	5d                   	pop    ebp
  101420:	c3                   	ret    
  101421:	90                   	nop
  101422:	90                   	nop
  101423:	90                   	nop
  101424:	90                   	nop
  101425:	90                   	nop
  101426:	90                   	nop
  101427:	90                   	nop
  101428:	90                   	nop
  101429:	90                   	nop
  10142a:	90                   	nop
  10142b:	90                   	nop
  10142c:	90                   	nop
  10142d:	90                   	nop
  10142e:	90                   	nop
  10142f:	90                   	nop

00101430 <ps2::write_config(unsigned char)>:
}
void write_config(uint8 byte) {
  101430:	55                   	push   ebp
  101431:	89 e5                	mov    ebp,esp
  101433:	8a 4d 08             	mov    cl,BYTE PTR [ebp+0x8]
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101436:	66 ba 64 00          	mov    dx,0x64
  10143a:	b0 60                	mov    al,0x60
  10143c:	ee                   	out    dx,al
  10143d:	66 ba 60 00          	mov    dx,0x60
  101441:	89 c8                	mov    eax,ecx
  101443:	ee                   	out    dx,al
    send(COMMAND, 0x60);
    send(DATA, byte);
}
  101444:	5d                   	pop    ebp
  101445:	c3                   	ret    
  101446:	90                   	nop
  101447:	90                   	nop
  101448:	90                   	nop
  101449:	90                   	nop
  10144a:	90                   	nop
  10144b:	90                   	nop
  10144c:	90                   	nop
  10144d:	90                   	nop
  10144e:	90                   	nop
  10144f:	90                   	nop

00101450 <ps2::status()>:

uint8 status() { return receive(COMMAND); }
  101450:	55                   	push   ebp
  101451:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101453:	66 ba 64 00          	mov    dx,0x64
  101457:	ec                   	in     al,dx
uint8 status() { return receive(COMMAND); }
  101458:	5d                   	pop    ebp
  101459:	c3                   	ret    
  10145a:	90                   	nop
  10145b:	90                   	nop
  10145c:	90                   	nop
  10145d:	90                   	nop
  10145e:	90                   	nop
  10145f:	90                   	nop

00101460 <ps2::has_output_data()>:
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101460:	55                   	push   ebp
  101461:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101463:	66 ba 64 00          	mov    dx,0x64
  101467:	ec                   	in     al,dx
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101468:	24 01                	and    al,0x1
  10146a:	5d                   	pop    ebp
  10146b:	c3                   	ret    
  10146c:	90                   	nop
  10146d:	90                   	nop
  10146e:	90                   	nop
  10146f:	90                   	nop

00101470 <ps2::has_input_data()>:
bool has_input_data() { return (status() & 0b00000010) != 0; }
  101470:	55                   	push   ebp
  101471:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101473:	66 ba 64 00          	mov    dx,0x64
  101477:	ec                   	in     al,dx
bool has_input_data() { return (status() & 0b00000010) != 0; }
  101478:	24 02                	and    al,0x2
  10147a:	d0 e8                	shr    al,1
  10147c:	5d                   	pop    ebp
  10147d:	c3                   	ret    
  10147e:	90                   	nop
  10147f:	90                   	nop

00101480 <ps2::writing_to_controller()>:
bool writing_to_controller() { return (status() & 0b00001000) != 0; }
  101480:	55                   	push   ebp
  101481:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101483:	66 ba 64 00          	mov    dx,0x64
  101487:	ec                   	in     al,dx
bool writing_to_controller() { return (status() & 0b00001000) != 0; }
  101488:	24 08                	and    al,0x8
  10148a:	c0 e8 03             	shr    al,0x3
  10148d:	5d                   	pop    ebp
  10148e:	c3                   	ret    
  10148f:	90                   	nop

00101490 <ps2::got_timeout_error()>:
bool got_timeout_error() { return (status() & 0b010000000) != 0; }
  101490:	55                   	push   ebp
  101491:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101493:	66 ba 64 00          	mov    dx,0x64
  101497:	ec                   	in     al,dx
bool got_timeout_error() { return (status() & 0b010000000) != 0; }
  101498:	c0 e8 07             	shr    al,0x7
  10149b:	5d                   	pop    ebp
  10149c:	c3                   	ret    
  10149d:	90                   	nop
  10149e:	90                   	nop
  10149f:	90                   	nop

001014a0 <ps2::got_parity_error()>:
bool got_parity_error() { return (status() & 0b10000000) != 0; }
  1014a0:	55                   	push   ebp
  1014a1:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014a3:	66 ba 64 00          	mov    dx,0x64
  1014a7:	ec                   	in     al,dx
bool got_parity_error() { return (status() & 0b10000000) != 0; }
  1014a8:	c0 e8 07             	shr    al,0x7
  1014ab:	5d                   	pop    ebp
  1014ac:	c3                   	ret    
  1014ad:	90                   	nop
  1014ae:	90                   	nop
  1014af:	90                   	nop

001014b0 <ps2::read_output_port()>:

uint8 read_output_port() {
  1014b0:	55                   	push   ebp
  1014b1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1014b3:	66 ba 64 00          	mov    dx,0x64
  1014b7:	b0 d0                	mov    al,0xd0
  1014b9:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014ba:	66 ba 60 00          	mov    dx,0x60
  1014be:	ec                   	in     al,dx
    send(COMMAND, 0xD0);
    return receive(DATA);
  1014bf:	5d                   	pop    ebp
  1014c0:	c3                   	ret    
  1014c1:	90                   	nop
  1014c2:	90                   	nop
  1014c3:	90                   	nop
  1014c4:	90                   	nop
  1014c5:	90                   	nop
  1014c6:	90                   	nop
  1014c7:	90                   	nop
  1014c8:	90                   	nop
  1014c9:	90                   	nop
  1014ca:	90                   	nop
  1014cb:	90                   	nop
  1014cc:	90                   	nop
  1014cd:	90                   	nop
  1014ce:	90                   	nop
  1014cf:	90                   	nop

001014d0 <ps2::test_controller()>:
}

bool test_controller() {
  1014d0:	55                   	push   ebp
  1014d1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1014d3:	66 ba 64 00          	mov    dx,0x64
  1014d7:	b0 aa                	mov    al,0xaa
  1014d9:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014da:	66 ba 60 00          	mov    dx,0x60
  1014de:	ec                   	in     al,dx
    send(COMMAND, 0xAA);
    return receive(DATA) == 0x55;
  1014df:	3c 55                	cmp    al,0x55
  1014e1:	0f 94 c0             	sete   al
  1014e4:	5d                   	pop    ebp
  1014e5:	c3                   	ret    
  1014e6:	90                   	nop
  1014e7:	90                   	nop
  1014e8:	90                   	nop
  1014e9:	90                   	nop
  1014ea:	90                   	nop
  1014eb:	90                   	nop
  1014ec:	90                   	nop
  1014ed:	90                   	nop
  1014ee:	90                   	nop
  1014ef:	90                   	nop

001014f0 <ps2::test_port_1()>:
}
bool test_port_1() {
  1014f0:	55                   	push   ebp
  1014f1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1014f3:	66 ba 64 00          	mov    dx,0x64
  1014f7:	b0 ab                	mov    al,0xab
  1014f9:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014fa:	66 ba 60 00          	mov    dx,0x60
  1014fe:	ec                   	in     al,dx
    send(COMMAND, 0xAB);
    return receive(DATA) == 0x00;
  1014ff:	84 c0                	test   al,al
  101501:	0f 94 c0             	sete   al
  101504:	5d                   	pop    ebp
  101505:	c3                   	ret    
  101506:	90                   	nop
  101507:	90                   	nop
  101508:	90                   	nop
  101509:	90                   	nop
  10150a:	90                   	nop
  10150b:	90                   	nop
  10150c:	90                   	nop
  10150d:	90                   	nop
  10150e:	90                   	nop
  10150f:	90                   	nop

00101510 <ps2::disable_1()>:
}

void disable_1() { send(COMMAND, 0xAD); }
  101510:	55                   	push   ebp
  101511:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101513:	66 ba 64 00          	mov    dx,0x64
  101517:	b0 ad                	mov    al,0xad
  101519:	ee                   	out    dx,al
void disable_1() { send(COMMAND, 0xAD); }
  10151a:	5d                   	pop    ebp
  10151b:	c3                   	ret    
  10151c:	90                   	nop
  10151d:	90                   	nop
  10151e:	90                   	nop
  10151f:	90                   	nop

00101520 <ps2::enable_1()>:
void enable_1() { send(COMMAND, 0xAE); }
  101520:	55                   	push   ebp
  101521:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101523:	66 ba 64 00          	mov    dx,0x64
  101527:	b0 ae                	mov    al,0xae
  101529:	ee                   	out    dx,al
void enable_1() { send(COMMAND, 0xAE); }
  10152a:	5d                   	pop    ebp
  10152b:	c3                   	ret    
  10152c:	90                   	nop
  10152d:	90                   	nop
  10152e:	90                   	nop
  10152f:	90                   	nop

00101530 <ps2::disable_2()>:
void disable_2() { send(COMMAND, 0xA7); }
  101530:	55                   	push   ebp
  101531:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101533:	66 ba 64 00          	mov    dx,0x64
  101537:	b0 a7                	mov    al,0xa7
  101539:	ee                   	out    dx,al
void disable_2() { send(COMMAND, 0xA7); }
  10153a:	5d                   	pop    ebp
  10153b:	c3                   	ret    
  10153c:	90                   	nop
  10153d:	90                   	nop
  10153e:	90                   	nop
  10153f:	90                   	nop

00101540 <ps2::enable_2()>:
void enable_2() { send(COMMAND, 0xA8); }
  101540:	55                   	push   ebp
  101541:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101543:	66 ba 64 00          	mov    dx,0x64
  101547:	b0 a8                	mov    al,0xa8
  101549:	ee                   	out    dx,al
void enable_2() { send(COMMAND, 0xA8); }
  10154a:	5d                   	pop    ebp
  10154b:	c3                   	ret    
  10154c:	90                   	nop
  10154d:	90                   	nop
  10154e:	90                   	nop
  10154f:	90                   	nop

00101550 <ps2::reset_1()>:
bool reset_1() {
  101550:	55                   	push   ebp
  101551:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101553:	66 ba 60 00          	mov    dx,0x60
  101557:	b0 ff                	mov    al,0xff
  101559:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10155a:	66 ba 60 00          	mov    dx,0x60
  10155e:	ec                   	in     al,dx
  10155f:	66 ba 60 00          	mov    dx,0x60
  101563:	ec                   	in     al,dx
    send(DATA, 0xFF);
    receive(DATA); // this receive() should not be necessary...
    return receive(DATA) == 0xAA;
  101564:	3c aa                	cmp    al,0xaa
  101566:	0f 94 c0             	sete   al
  101569:	5d                   	pop    ebp
  10156a:	c3                   	ret    
  10156b:	90                   	nop
  10156c:	90                   	nop
  10156d:	90                   	nop
  10156e:	90                   	nop
  10156f:	90                   	nop

00101570 <ps2::reset_2()>:
}
bool reset_2() {
  101570:	55                   	push   ebp
  101571:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101573:	66 ba 64 00          	mov    dx,0x64
  101577:	b0 d4                	mov    al,0xd4
  101579:	ee                   	out    dx,al
  10157a:	66 ba 60 00          	mov    dx,0x60
  10157e:	b0 ff                	mov    al,0xff
  101580:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101581:	66 ba 60 00          	mov    dx,0x60
  101585:	ec                   	in     al,dx
  101586:	66 ba 60 00          	mov    dx,0x60
  10158a:	ec                   	in     al,dx
    send(COMMAND, 0xD4);
    send(DATA, 0xFF);
    receive(DATA); // this receive() should not be necessary...
    return receive(DATA) == 0xAA;
  10158b:	3c aa                	cmp    al,0xaa
  10158d:	0f 94 c0             	sete   al
  101590:	5d                   	pop    ebp
  101591:	c3                   	ret    
  101592:	90                   	nop
  101593:	90                   	nop
  101594:	90                   	nop
  101595:	90                   	nop
  101596:	90                   	nop
  101597:	90                   	nop
  101598:	90                   	nop
  101599:	90                   	nop
  10159a:	90                   	nop
  10159b:	90                   	nop
  10159c:	90                   	nop
  10159d:	90                   	nop
  10159e:	90                   	nop
  10159f:	90                   	nop

001015a0 <ps2::hard_reset()>:
}

void hard_reset() { send(COMMAND, 0xFE); }
  1015a0:	55                   	push   ebp
  1015a1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1015a3:	66 ba 64 00          	mov    dx,0x64
  1015a7:	b0 fe                	mov    al,0xfe
  1015a9:	ee                   	out    dx,al
void hard_reset() { send(COMMAND, 0xFE); }
  1015aa:	5d                   	pop    ebp
  1015ab:	c3                   	ret    
  1015ac:	90                   	nop
  1015ad:	90                   	nop
  1015ae:	90                   	nop
  1015af:	90                   	nop

001015b0 <ps2::get_output()>:

uint8 get_output() { return receive(DATA); }
  1015b0:	55                   	push   ebp
  1015b1:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1015b3:	66 ba 60 00          	mov    dx,0x60
  1015b7:	ec                   	in     al,dx
uint8 get_output() { return receive(DATA); }
  1015b8:	5d                   	pop    ebp
  1015b9:	c3                   	ret    
  1015ba:	90                   	nop
  1015bb:	90                   	nop
  1015bc:	90                   	nop
  1015bd:	90                   	nop
  1015be:	90                   	nop
  1015bf:	90                   	nop

001015c0 <ps2::flush_output()>:

void flush_output() {
  1015c0:	55                   	push   ebp
  1015c1:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1015c3:	66 ba 64 00          	mov    dx,0x64
  1015c7:	ec                   	in     al,dx
  1015c8:	a8 01                	test   al,0x1
    while (has_output_data())
  1015ca:	74 12                	je     1015de <ps2::flush_output()+0x1e>
  1015cc:	90                   	nop
  1015cd:	90                   	nop
  1015ce:	90                   	nop
  1015cf:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1015d0:	66 ba 60 00          	mov    dx,0x60
  1015d4:	ec                   	in     al,dx
  1015d5:	66 ba 64 00          	mov    dx,0x64
  1015d9:	ec                   	in     al,dx
  1015da:	a8 01                	test   al,0x1
    while (has_output_data())
  1015dc:	75 f2                	jne    1015d0 <ps2::flush_output()+0x10>
        receive(DATA);
}
  1015de:	5d                   	pop    ebp
  1015df:	c3                   	ret    

001015e0 <ps2::startup(int)>:
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1015e0:	66 ba 64 00          	mov    dx,0x64
  1015e4:	b0 ad                	mov    al,0xad
  1015e6:	ee                   	out    dx,al
  1015e7:	66 ba 64 00          	mov    dx,0x64
  1015eb:	b0 a7                	mov    al,0xa7
  1015ed:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1015ee:	66 ba 64 00          	mov    dx,0x64
  1015f2:	ec                   	in     al,dx
  1015f3:	a8 01                	test   al,0x1
    while (has_output_data())
  1015f5:	74 17                	je     10160e <ps2::startup(int)+0x2e>
  1015f7:	90                   	nop
  1015f8:	90                   	nop
  1015f9:	90                   	nop
  1015fa:	90                   	nop
  1015fb:	90                   	nop
  1015fc:	90                   	nop
  1015fd:	90                   	nop
  1015fe:	90                   	nop
  1015ff:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101600:	66 ba 60 00          	mov    dx,0x60
  101604:	ec                   	in     al,dx
  101605:	66 ba 64 00          	mov    dx,0x64
  101609:	ec                   	in     al,dx
  10160a:	a8 01                	test   al,0x1
    while (has_output_data())
  10160c:	75 f2                	jne    101600 <ps2::startup(int)+0x20>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10160e:	66 ba 64 00          	mov    dx,0x64
  101612:	b0 20                	mov    al,0x20
  101614:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101615:	66 ba 60 00          	mov    dx,0x60
  101619:	ec                   	in     al,dx
  10161a:	89 c1                	mov    ecx,eax
bool startup(int device = 1) {
    ps2::disable_1();
    ps2::disable_2();
    ps2::flush_output();
    uint8 cb = ps2::read_config();
    cb &= 0b10111100; // disable interrupts and translation
  10161c:	80 e1 bc             	and    cl,0xbc
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10161f:	66 ba 64 00          	mov    dx,0x64
  101623:	b0 60                	mov    al,0x60
  101625:	ee                   	out    dx,al
  101626:	66 ba 60 00          	mov    dx,0x60
  10162a:	89 c8                	mov    eax,ecx
  10162c:	ee                   	out    dx,al
  10162d:	66 ba 64 00          	mov    dx,0x64
  101631:	b0 aa                	mov    al,0xaa
  101633:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101634:	66 ba 60 00          	mov    dx,0x60
  101638:	ec                   	in     al,dx
    return receive(DATA) == 0x55;
  101639:	3c 55                	cmp    al,0x55
    ps2::write_config(cb);
    if (!(ps2::test_controller() && ps2::test_port_1()))
  10163b:	75 5c                	jne    101699 <ps2::startup(int)+0xb9>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10163d:	66 ba 64 00          	mov    dx,0x64
  101641:	b0 ab                	mov    al,0xab
  101643:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101644:	66 ba 60 00          	mov    dx,0x60
  101648:	ec                   	in     al,dx
    return receive(DATA) == 0x00;
  101649:	84 c0                	test   al,al
    if (!(ps2::test_controller() && ps2::test_port_1()))
  10164b:	75 4c                	jne    101699 <ps2::startup(int)+0xb9>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10164d:	66 ba 64 00          	mov    dx,0x64
  101651:	b0 ae                	mov    al,0xae
  101653:	ee                   	out    dx,al
  101654:	66 ba 60 00          	mov    dx,0x60
  101658:	b0 ff                	mov    al,0xff
  10165a:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10165b:	66 ba 60 00          	mov    dx,0x60
  10165f:	ec                   	in     al,dx
  101660:	66 ba 60 00          	mov    dx,0x60
  101664:	ec                   	in     al,dx
    return receive(DATA) == 0xAA;
  101665:	3c aa                	cmp    al,0xaa
        return false;
    ps2::enable_1();
    if (!ps2::reset_1())
  101667:	75 30                	jne    101699 <ps2::startup(int)+0xb9>
  101669:	55                   	push   ebp
  10166a:	89 e5                	mov    ebp,esp
        return false;
    if (device == 2) {
  10166c:	83 7d 08 02          	cmp    DWORD PTR [ebp+0x8],0x2
  101670:	5d                   	pop    ebp
  101671:	75 23                	jne    101696 <ps2::startup(int)+0xb6>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101673:	66 ba 64 00          	mov    dx,0x64
  101677:	b0 a8                	mov    al,0xa8
  101679:	ee                   	out    dx,al
  10167a:	66 ba 64 00          	mov    dx,0x64
  10167e:	b0 d4                	mov    al,0xd4
  101680:	ee                   	out    dx,al
  101681:	66 ba 60 00          	mov    dx,0x60
  101685:	b0 ff                	mov    al,0xff
  101687:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101688:	66 ba 60 00          	mov    dx,0x60
  10168c:	ec                   	in     al,dx
  10168d:	66 ba 60 00          	mov    dx,0x60
  101691:	ec                   	in     al,dx
    return receive(DATA) == 0xAA;
  101692:	3c aa                	cmp    al,0xaa
        ps2::enable_2();
        if (!ps2::reset_2())
  101694:	75 03                	jne    101699 <ps2::startup(int)+0xb9>
  101696:	b0 01                	mov    al,0x1
            return false;
    }
    return true;
}
  101698:	c3                   	ret    
  101699:	31 c0                	xor    eax,eax
  10169b:	c3                   	ret    
  10169c:	90                   	nop
  10169d:	90                   	nop
  10169e:	90                   	nop
  10169f:	90                   	nop

001016a0 <kbd::get_ascii()>:

string<80> LINE_BUFFER;

enum special_ascii : char { ASCII_END_OF_TEXT = 0x3, ASCII_BACKSPACE=0x8 };

optional<char> get_ascii() {
  1016a0:	55                   	push   ebp
  1016a1:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1016a3:	66 ba 60 00          	mov    dx,0x60
  1016a7:	ec                   	in     al,dx
  1016a8:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
    static bool ctrl_pressed = false;
    auto a = ps2::get_output();
    // scan codes (set 2)
    // http://www.techtoys.com.hk/Downloads/Download/Microchip/PS2_driver/ScanCode.pdf
    switch (a) {
  1016ab:	04 10                	add    al,0x10
  1016ad:	3c 76                	cmp    al,0x76
  1016af:	77 23                	ja     1016d4 <kbd::get_ascii()+0x34>
  1016b1:	0f b6 c0             	movzx  eax,al
  1016b4:	ff 24 85 00 40 10 00 	jmp    DWORD PTR [eax*4+0x104000]
  1016bb:	66 ba 60 00          	mov    dx,0x60
  1016bf:	ec                   	in     al,dx
    case 0xF0: {
        // break codes
        auto b = ps2::get_output();
        switch (b) {
  1016c0:	3c 14                	cmp    al,0x14
  1016c2:	75 10                	jne    1016d4 <kbd::get_ascii()+0x34>
        case 0x14:
            ctrl_pressed = false;
  1016c4:	c6 05 dc 60 11 00 00 	mov    BYTE PTR ds:0x1160dc,0x0
  1016cb:	eb 07                	jmp    1016d4 <kbd::get_ascii()+0x34>
            break;
        }
        break;
    }
    case 0x14:
        ctrl_pressed = true;
  1016cd:	c6 05 dc 60 11 00 01 	mov    BYTE PTR ds:0x1160dc,0x1
    bool loaded_ = false;
  1016d4:	66 c7 01 00 00       	mov    WORD PTR [ecx],0x0
  1016d9:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
    //  }
    default:
        break; // unhandled make/break code
    }
    return {};
}
  1016e0:	89 c8                	mov    eax,ecx
  1016e2:	5d                   	pop    ebp
  1016e3:	c2 04 00             	ret    0x4
    constexpr optional(T p) : loaded_(true), value(move(p)) {}
  1016e6:	66 c7 01 01 7a       	mov    WORD PTR [ecx],0x7a01
  1016eb:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1016f2:	89 c8                	mov    eax,ecx
  1016f4:	5d                   	pop    ebp
  1016f5:	c2 04 00             	ret    0x4
        if (ctrl_pressed)
  1016f8:	a0 dc 60 11 00       	mov    al,ds:0x1160dc
  1016fd:	c6 01 01             	mov    BYTE PTR [ecx],0x1
  101700:	3c 01                	cmp    al,0x1
  101702:	0f 85 05 03 00 00    	jne    101a0d <kbd::get_ascii()+0x36d>
  101708:	c6 41 01 03          	mov    BYTE PTR [ecx+0x1],0x3
  10170c:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
}
  101713:	89 c8                	mov    eax,ecx
  101715:	5d                   	pop    ebp
  101716:	c2 04 00             	ret    0x4
  101719:	66 c7 01 01 78       	mov    WORD PTR [ecx],0x7801
  10171e:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101725:	89 c8                	mov    eax,ecx
  101727:	5d                   	pop    ebp
  101728:	c2 04 00             	ret    0x4
  10172b:	66 c7 01 01 64       	mov    WORD PTR [ecx],0x6401
  101730:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101737:	89 c8                	mov    eax,ecx
  101739:	5d                   	pop    ebp
  10173a:	c2 04 00             	ret    0x4
  10173d:	66 c7 01 01 65       	mov    WORD PTR [ecx],0x6501
  101742:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101749:	89 c8                	mov    eax,ecx
  10174b:	5d                   	pop    ebp
  10174c:	c2 04 00             	ret    0x4
  10174f:	66 c7 01 01 66       	mov    WORD PTR [ecx],0x6601
  101754:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10175b:	89 c8                	mov    eax,ecx
  10175d:	5d                   	pop    ebp
  10175e:	c2 04 00             	ret    0x4
  101761:	66 c7 01 01 74       	mov    WORD PTR [ecx],0x7401
  101766:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10176d:	89 c8                	mov    eax,ecx
  10176f:	5d                   	pop    ebp
  101770:	c2 04 00             	ret    0x4
  101773:	66 c7 01 01 35       	mov    WORD PTR [ecx],0x3501
  101778:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10177f:	89 c8                	mov    eax,ecx
  101781:	5d                   	pop    ebp
  101782:	c2 04 00             	ret    0x4
  101785:	66 c7 01 01 6e       	mov    WORD PTR [ecx],0x6e01
  10178a:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101791:	89 c8                	mov    eax,ecx
  101793:	5d                   	pop    ebp
  101794:	c2 04 00             	ret    0x4
  101797:	66 c7 01 01 62       	mov    WORD PTR [ecx],0x6201
  10179c:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1017a3:	89 c8                	mov    eax,ecx
  1017a5:	5d                   	pop    ebp
  1017a6:	c2 04 00             	ret    0x4
  1017a9:	66 c7 01 01 68       	mov    WORD PTR [ecx],0x6801
  1017ae:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1017b5:	89 c8                	mov    eax,ecx
  1017b7:	5d                   	pop    ebp
  1017b8:	c2 04 00             	ret    0x4
  1017bb:	66 c7 01 01 67       	mov    WORD PTR [ecx],0x6701
  1017c0:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1017c7:	89 c8                	mov    eax,ecx
  1017c9:	5d                   	pop    ebp
  1017ca:	c2 04 00             	ret    0x4
  1017cd:	66 c7 01 01 6d       	mov    WORD PTR [ecx],0x6d01
  1017d2:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1017d9:	89 c8                	mov    eax,ecx
  1017db:	5d                   	pop    ebp
  1017dc:	c2 04 00             	ret    0x4
  1017df:	66 c7 01 01 6a       	mov    WORD PTR [ecx],0x6a01
  1017e4:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1017eb:	89 c8                	mov    eax,ecx
  1017ed:	5d                   	pop    ebp
  1017ee:	c2 04 00             	ret    0x4
  1017f1:	66 c7 01 01 37       	mov    WORD PTR [ecx],0x3701
  1017f6:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1017fd:	89 c8                	mov    eax,ecx
  1017ff:	5d                   	pop    ebp
  101800:	c2 04 00             	ret    0x4
  101803:	66 c7 01 01 6b       	mov    WORD PTR [ecx],0x6b01
  101808:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10180f:	89 c8                	mov    eax,ecx
  101811:	5d                   	pop    ebp
  101812:	c2 04 00             	ret    0x4
  101815:	66 c7 01 01 30       	mov    WORD PTR [ecx],0x3001
  10181a:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101821:	89 c8                	mov    eax,ecx
  101823:	5d                   	pop    ebp
  101824:	c2 04 00             	ret    0x4
  101827:	66 c7 01 01 2e       	mov    WORD PTR [ecx],0x2e01
  10182c:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101833:	89 c8                	mov    eax,ecx
  101835:	5d                   	pop    ebp
  101836:	c2 04 00             	ret    0x4
  101839:	66 c7 01 01 2f       	mov    WORD PTR [ecx],0x2f01
  10183e:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101845:	89 c8                	mov    eax,ecx
  101847:	5d                   	pop    ebp
  101848:	c2 04 00             	ret    0x4
  10184b:	66 c7 01 01 6c       	mov    WORD PTR [ecx],0x6c01
  101850:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101857:	89 c8                	mov    eax,ecx
  101859:	5d                   	pop    ebp
  10185a:	c2 04 00             	ret    0x4
  10185d:	66 c7 01 01 70       	mov    WORD PTR [ecx],0x7001
  101862:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101869:	89 c8                	mov    eax,ecx
  10186b:	5d                   	pop    ebp
  10186c:	c2 04 00             	ret    0x4
  10186f:	66 c7 01 01 3d       	mov    WORD PTR [ecx],0x3d01
  101874:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10187b:	89 c8                	mov    eax,ecx
  10187d:	5d                   	pop    ebp
  10187e:	c2 04 00             	ret    0x4
  101881:	66 c7 01 01 0a       	mov    WORD PTR [ecx],0xa01
  101886:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10188d:	89 c8                	mov    eax,ecx
  10188f:	5d                   	pop    ebp
  101890:	c2 04 00             	ret    0x4
  101893:	66 c7 01 01 09       	mov    WORD PTR [ecx],0x901
  101898:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10189f:	89 c8                	mov    eax,ecx
  1018a1:	5d                   	pop    ebp
  1018a2:	c2 04 00             	ret    0x4
  1018a5:	66 c7 01 01 71       	mov    WORD PTR [ecx],0x7101
  1018aa:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1018b1:	89 c8                	mov    eax,ecx
  1018b3:	5d                   	pop    ebp
  1018b4:	c2 04 00             	ret    0x4
  1018b7:	66 c7 01 01 31       	mov    WORD PTR [ecx],0x3101
  1018bc:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1018c3:	89 c8                	mov    eax,ecx
  1018c5:	5d                   	pop    ebp
  1018c6:	c2 04 00             	ret    0x4
  1018c9:	66 c7 01 01 73       	mov    WORD PTR [ecx],0x7301
  1018ce:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1018d5:	89 c8                	mov    eax,ecx
  1018d7:	5d                   	pop    ebp
  1018d8:	c2 04 00             	ret    0x4
  1018db:	66 c7 01 01 61       	mov    WORD PTR [ecx],0x6101
  1018e0:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1018e7:	89 c8                	mov    eax,ecx
  1018e9:	5d                   	pop    ebp
  1018ea:	c2 04 00             	ret    0x4
  1018ed:	66 c7 01 01 77       	mov    WORD PTR [ecx],0x7701
  1018f2:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1018f9:	89 c8                	mov    eax,ecx
  1018fb:	5d                   	pop    ebp
  1018fc:	c2 04 00             	ret    0x4
  1018ff:	66 c7 01 01 32       	mov    WORD PTR [ecx],0x3201
  101904:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10190b:	89 c8                	mov    eax,ecx
  10190d:	5d                   	pop    ebp
  10190e:	c2 04 00             	ret    0x4
  101911:	66 c7 01 01 34       	mov    WORD PTR [ecx],0x3401
  101916:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10191d:	89 c8                	mov    eax,ecx
  10191f:	5d                   	pop    ebp
  101920:	c2 04 00             	ret    0x4
  101923:	66 c7 01 01 33       	mov    WORD PTR [ecx],0x3301
  101928:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10192f:	89 c8                	mov    eax,ecx
  101931:	5d                   	pop    ebp
  101932:	c2 04 00             	ret    0x4
  101935:	66 c7 01 01 20       	mov    WORD PTR [ecx],0x2001
  10193a:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101941:	89 c8                	mov    eax,ecx
  101943:	5d                   	pop    ebp
  101944:	c2 04 00             	ret    0x4
  101947:	66 c7 01 01 76       	mov    WORD PTR [ecx],0x7601
  10194c:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101953:	89 c8                	mov    eax,ecx
  101955:	5d                   	pop    ebp
  101956:	c2 04 00             	ret    0x4
  101959:	66 c7 01 01 72       	mov    WORD PTR [ecx],0x7201
  10195e:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101965:	89 c8                	mov    eax,ecx
  101967:	5d                   	pop    ebp
  101968:	c2 04 00             	ret    0x4
  10196b:	66 c7 01 01 79       	mov    WORD PTR [ecx],0x7901
  101970:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101977:	89 c8                	mov    eax,ecx
  101979:	5d                   	pop    ebp
  10197a:	c2 04 00             	ret    0x4
  10197d:	66 c7 01 01 36       	mov    WORD PTR [ecx],0x3601
  101982:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101989:	89 c8                	mov    eax,ecx
  10198b:	5d                   	pop    ebp
  10198c:	c2 04 00             	ret    0x4
  10198f:	66 c7 01 01 75       	mov    WORD PTR [ecx],0x7501
  101994:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10199b:	89 c8                	mov    eax,ecx
  10199d:	5d                   	pop    ebp
  10199e:	c2 04 00             	ret    0x4
  1019a1:	66 c7 01 01 38       	mov    WORD PTR [ecx],0x3801
  1019a6:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1019ad:	89 c8                	mov    eax,ecx
  1019af:	5d                   	pop    ebp
  1019b0:	c2 04 00             	ret    0x4
  1019b3:	66 c7 01 01 69       	mov    WORD PTR [ecx],0x6901
  1019b8:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1019bf:	89 c8                	mov    eax,ecx
  1019c1:	5d                   	pop    ebp
  1019c2:	c2 04 00             	ret    0x4
  1019c5:	66 c7 01 01 6f       	mov    WORD PTR [ecx],0x6f01
  1019ca:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1019d1:	89 c8                	mov    eax,ecx
  1019d3:	5d                   	pop    ebp
  1019d4:	c2 04 00             	ret    0x4
  1019d7:	66 c7 01 01 39       	mov    WORD PTR [ecx],0x3901
  1019dc:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1019e3:	89 c8                	mov    eax,ecx
  1019e5:	5d                   	pop    ebp
  1019e6:	c2 04 00             	ret    0x4
  1019e9:	66 c7 01 01 2d       	mov    WORD PTR [ecx],0x2d01
  1019ee:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1019f5:	89 c8                	mov    eax,ecx
  1019f7:	5d                   	pop    ebp
  1019f8:	c2 04 00             	ret    0x4
  1019fb:	66 c7 01 01 08       	mov    WORD PTR [ecx],0x801
  101a00:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101a07:	89 c8                	mov    eax,ecx
  101a09:	5d                   	pop    ebp
  101a0a:	c2 04 00             	ret    0x4
  101a0d:	c6 41 01 63          	mov    BYTE PTR [ecx+0x1],0x63
  101a11:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101a18:	89 c8                	mov    eax,ecx
  101a1a:	5d                   	pop    ebp
  101a1b:	c2 04 00             	ret    0x4
  101a1e:	90                   	nop
  101a1f:	90                   	nop

00101a20 <kbd::get_line(bool)>:

auto &get_line(bool echo = true) {
  101a20:	55                   	push   ebp
  101a21:	89 e5                	mov    ebp,esp
  101a23:	53                   	push   ebx
  101a24:	57                   	push   edi
  101a25:	56                   	push   esi
  101a26:	83 e4 f8             	and    esp,0xfffffff8
  101a29:	83 ec 10             	sub    esp,0x10
  101a2c:	31 f6                	xor    esi,esi
  101a2e:	89 e7                	mov    edi,esp
    int b = 0;
    while (b < LINE_BUFFER.size() - 1) {
  101a30:	80 7d 08 00          	cmp    BYTE PTR [ebp+0x8],0x0
  101a34:	75 2a                	jne    101a60 <kbd::get_line(bool)+0x40>
  101a36:	e9 85 00 00 00       	jmp    101ac0 <kbd::get_line(bool)+0xa0>
            continue;
        char a = _a.value;

        if(a==ASCII_BACKSPACE) {
            b--;
            term::Term.col-=1;
  101a3b:	ff 0d 04 50 10 00    	dec    DWORD PTR ds:0x105004
        write(s[a]);
  101a41:	6a 20                	push   0x20
  101a43:	e8 f8 f6 ff ff       	call   101140 <term::write(char)>
  101a48:	83 c4 04             	add    esp,0x4
            b--;
  101a4b:	4e                   	dec    esi
            term::write(" ");
            term::Term.col-=1;
  101a4c:	ff 0d 04 50 10 00    	dec    DWORD PTR ds:0x105004
    while (b < LINE_BUFFER.size() - 1) {
  101a52:	83 fe 4f             	cmp    esi,0x4f
  101a55:	0f 8d 97 00 00 00    	jge    101af2 <kbd::get_line(bool)+0xd2>
  101a5b:	90                   	nop
  101a5c:	90                   	nop
  101a5d:	90                   	nop
  101a5e:	90                   	nop
  101a5f:	90                   	nop
  101a60:	66 ba 64 00          	mov    dx,0x64
  101a64:	ec                   	in     al,dx
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101a65:	a8 01                	test   al,0x1
        while (!ps2::has_output_data())
  101a67:	74 f7                	je     101a60 <kbd::get_line(bool)+0x40>
        auto _a = get_ascii();
  101a69:	57                   	push   edi
  101a6a:	e8 31 fc ff ff       	call   1016a0 <kbd::get_ascii()>
    constexpr operator bool() const { return loaded_; }
  101a6f:	80 3c 24 00          	cmp    BYTE PTR [esp],0x0
        if (!_a)
  101a73:	74 dd                	je     101a52 <kbd::get_line(bool)+0x32>
        char a = _a.value;
  101a75:	0f b6 5c 24 01       	movzx  ebx,BYTE PTR [esp+0x1]
        if(a==ASCII_BACKSPACE) {
  101a7a:	80 fb 08             	cmp    bl,0x8
  101a7d:	74 bc                	je     101a3b <kbd::get_line(bool)+0x1b>
            continue;
        }
        if (echo) {
            term::write(a);
  101a7f:	0f be c3             	movsx  eax,bl
  101a82:	50                   	push   eax
  101a83:	e8 b8 f6 ff ff       	call   101140 <term::write(char)>
  101a88:	83 c4 04             	add    esp,0x4
        }
        if (a == '\n')
  101a8b:	80 fb 03             	cmp    bl,0x3
  101a8e:	74 76                	je     101b06 <kbd::get_line(bool)+0xe6>
  101a90:	80 fb 0a             	cmp    bl,0xa
  101a93:	74 5d                	je     101af2 <kbd::get_line(bool)+0xd2>
            term::write('\n');
            LINE_BUFFER[0] = 0;
            return LINE_BUFFER;
        }
        
        LINE_BUFFER[b++] = a;
  101a95:	88 9e 88 60 11 00    	mov    BYTE PTR [esi+0x116088],bl
  101a9b:	46                   	inc    esi
    while (b < LINE_BUFFER.size() - 1) {
  101a9c:	83 fe 4f             	cmp    esi,0x4f
  101a9f:	7c bf                	jl     101a60 <kbd::get_line(bool)+0x40>
  101aa1:	eb 4f                	jmp    101af2 <kbd::get_line(bool)+0xd2>
            term::Term.col-=1;
  101aa3:	ff 0d 04 50 10 00    	dec    DWORD PTR ds:0x105004
  101aa9:	6a 20                	push   0x20
  101aab:	e8 90 f6 ff ff       	call   101140 <term::write(char)>
  101ab0:	83 c4 04             	add    esp,0x4
            b--;
  101ab3:	4e                   	dec    esi
            term::Term.col-=1;
  101ab4:	ff 0d 04 50 10 00    	dec    DWORD PTR ds:0x105004
    while (b < LINE_BUFFER.size() - 1) {
  101aba:	83 fe 4f             	cmp    esi,0x4f
  101abd:	7d 33                	jge    101af2 <kbd::get_line(bool)+0xd2>
  101abf:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101ac0:	66 ba 64 00          	mov    dx,0x64
  101ac4:	ec                   	in     al,dx
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101ac5:	a8 01                	test   al,0x1
        while (!ps2::has_output_data())
  101ac7:	74 f7                	je     101ac0 <kbd::get_line(bool)+0xa0>
        auto _a = get_ascii();
  101ac9:	57                   	push   edi
  101aca:	e8 d1 fb ff ff       	call   1016a0 <kbd::get_ascii()>
  101acf:	80 3c 24 00          	cmp    BYTE PTR [esp],0x0
        if (!_a)
  101ad3:	74 e5                	je     101aba <kbd::get_line(bool)+0x9a>
        char a = _a.value;
  101ad5:	0f b6 44 24 01       	movzx  eax,BYTE PTR [esp+0x1]
        if(a==ASCII_BACKSPACE) {
  101ada:	3c 08                	cmp    al,0x8
  101adc:	74 c5                	je     101aa3 <kbd::get_line(bool)+0x83>
  101ade:	3c 03                	cmp    al,0x3
  101ae0:	74 24                	je     101b06 <kbd::get_line(bool)+0xe6>
  101ae2:	3c 0a                	cmp    al,0xa
  101ae4:	74 0c                	je     101af2 <kbd::get_line(bool)+0xd2>
        LINE_BUFFER[b++] = a;
  101ae6:	88 86 88 60 11 00    	mov    BYTE PTR [esi+0x116088],al
  101aec:	46                   	inc    esi
    while (b < LINE_BUFFER.size() - 1) {
  101aed:	83 fe 4f             	cmp    esi,0x4f
  101af0:	7c ce                	jl     101ac0 <kbd::get_line(bool)+0xa0>
    }
    LINE_BUFFER[b] = 0;
  101af2:	c6 86 88 60 11 00 00 	mov    BYTE PTR [esi+0x116088],0x0
    return LINE_BUFFER;
}
  101af9:	b8 88 60 11 00       	mov    eax,0x116088
  101afe:	8d 65 f4             	lea    esp,[ebp-0xc]
  101b01:	5e                   	pop    esi
  101b02:	5f                   	pop    edi
  101b03:	5b                   	pop    ebx
  101b04:	5d                   	pop    ebp
  101b05:	c3                   	ret    
        if (!flipped) {
  101b06:	80 3d 0d 50 10 00 00 	cmp    BYTE PTR ds:0x10500d,0x0
  101b0d:	74 35                	je     101b44 <kbd::get_line(bool)+0x124>
            increment_cursor(row, col, ROWS, COLS, ROWS - (row % ROWS));
  101b0f:	8b 0d 08 50 10 00    	mov    ecx,DWORD PTR ds:0x105008
  101b15:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  101b1a:	89 c8                	mov    eax,ecx
  101b1c:	f7 ea                	imul   edx
  101b1e:	89 d0                	mov    eax,edx
  101b20:	c1 e8 1f             	shr    eax,0x1f
  101b23:	c1 fa 03             	sar    edx,0x3
  101b26:	01 c2                	add    edx,eax
  101b28:	8d 04 92             	lea    eax,[edx+edx*4]
  101b2b:	8d 04 80             	lea    eax,[eax+eax*4]
  101b2e:	29 c8                	sub    eax,ecx
  101b30:	83 c0 19             	add    eax,0x19
  101b33:	b9 08 50 10 00       	mov    ecx,0x105008
  101b38:	ba 04 50 10 00       	mov    edx,0x105004
  101b3d:	50                   	push   eax
  101b3e:	6a 50                	push   0x50
  101b40:	6a 19                	push   0x19
  101b42:	eb 33                	jmp    101b77 <kbd::get_line(bool)+0x157>
            increment_cursor(col, row, COLS, ROWS, COLS - (col % COLS));
  101b44:	8b 0d 04 50 10 00    	mov    ecx,DWORD PTR ds:0x105004
  101b4a:	ba 67 66 66 66       	mov    edx,0x66666667
  101b4f:	89 c8                	mov    eax,ecx
  101b51:	f7 ea                	imul   edx
  101b53:	89 d0                	mov    eax,edx
  101b55:	c1 e8 1f             	shr    eax,0x1f
  101b58:	c1 fa 05             	sar    edx,0x5
  101b5b:	01 c2                	add    edx,eax
  101b5d:	c1 e2 04             	shl    edx,0x4
  101b60:	8d 04 92             	lea    eax,[edx+edx*4]
  101b63:	29 c8                	sub    eax,ecx
  101b65:	83 c0 50             	add    eax,0x50
  101b68:	b9 04 50 10 00       	mov    ecx,0x105004
  101b6d:	ba 08 50 10 00       	mov    edx,0x105008
  101b72:	50                   	push   eax
  101b73:	6a 19                	push   0x19
  101b75:	6a 50                	push   0x50
  101b77:	e8 74 17 00 00       	call   1032f0 <term::$_0::increment_cursor(int&, int&, int, int, int)>
  101b7c:	83 c4 0c             	add    esp,0xc
            LINE_BUFFER[0] = 0;
  101b7f:	c6 05 88 60 11 00 00 	mov    BYTE PTR ds:0x116088,0x0
  101b86:	e9 6e ff ff ff       	jmp    101af9 <kbd::get_line(bool)+0xd9>
  101b8b:	90                   	nop
  101b8c:	90                   	nop
  101b8d:	90                   	nop
  101b8e:	90                   	nop
  101b8f:	90                   	nop

00101b90 <time::delay(int)>:

/**
 * Spin the CPU for a given number of "moments".
 * (One "moment" is 2^16 AND operations.)
 */
void delay(int amount = 1) {
  101b90:	55                   	push   ebp
  101b91:	89 e5                	mov    ebp,esp
  101b93:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
    for (int a = 0; a < (1 << 16) * amount; a++) {
  101b96:	85 c0                	test   eax,eax
  101b98:	7e 0d                	jle    101ba7 <time::delay(int)+0x17>
  101b9a:	c1 e0 10             	shl    eax,0x10
  101b9d:	31 c9                	xor    ecx,ecx
  101b9f:	90                   	nop
        asm volatile ("and %eax,%eax");
  101ba0:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  101ba2:	41                   	inc    ecx
  101ba3:	39 c1                	cmp    ecx,eax
  101ba5:	7c f9                	jl     101ba0 <time::delay(int)+0x10>
    }
}
  101ba7:	5d                   	pop    ebp
  101ba8:	c3                   	ret    
  101ba9:	90                   	nop
  101baa:	90                   	nop
  101bab:	90                   	nop
  101bac:	90                   	nop
  101bad:	90                   	nop
  101bae:	90                   	nop
  101baf:	90                   	nop

00101bb0 <kernel_main>:
        f_();
        term::write("Runner ended\n");
    }
};

extern "C" void kernel_main(multiboot_info_t *mb, uint32 magic) {
  101bb0:	55                   	push   ebp
  101bb1:	89 e5                	mov    ebp,esp
  101bb3:	53                   	push   ebx
  101bb4:	57                   	push   edi
  101bb5:	56                   	push   esi
  101bb6:	83 e4 f8             	and    esp,0xfffffff8
  101bb9:	81 ec c8 0c 00 00    	sub    esp,0xcc8
  101bbf:	8b 5d 0c             	mov    ebx,DWORD PTR [ebp+0xc]
    term::clear();
  101bc2:	e8 89 f4 ff ff       	call   101050 <term::clear()>
    constexpr array() : data_{T()} {}
  101bc7:	66 c7 84 24 14 03 00 	mov    WORD PTR [esp+0x314],0x0
  101bce:	00 00 00 
  101bd1:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  101bd8:	00 00 00 00 
  101bdc:	c7 84 24 0c 03 00 00 	mov    DWORD PTR [esp+0x30c],0x0
  101be3:	00 00 00 00 
  101be7:	c7 84 24 08 03 00 00 	mov    DWORD PTR [esp+0x308],0x0
  101bee:	00 00 00 00 
  101bf2:	c7 84 24 04 03 00 00 	mov    DWORD PTR [esp+0x304],0x0
  101bf9:	00 00 00 00 
  101bfd:	c7 84 24 00 03 00 00 	mov    DWORD PTR [esp+0x300],0x0
  101c04:	00 00 00 00 
  101c08:	c7 84 24 fc 02 00 00 	mov    DWORD PTR [esp+0x2fc],0x0
  101c0f:	00 00 00 00 
  101c13:	c7 84 24 f8 02 00 00 	mov    DWORD PTR [esp+0x2f8],0x0
  101c1a:	00 00 00 00 
    int index_ = 0;
  101c1e:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  101c25:	00 00 00 00 
    if (x == 0)
  101c29:	85 db                	test   ebx,ebx
  101c2b:	74 77                	je     101ca4 <kernel_main+0xf4>
    for (; x > 0; a++) {
  101c2d:	8d 84 24 f7 02 00 00 	lea    eax,[esp+0x2f7]
  101c34:	31 f6                	xor    esi,esi
  101c36:	90                   	nop
  101c37:	90                   	nop
  101c38:	90                   	nop
  101c39:	90                   	nop
  101c3a:	90                   	nop
  101c3b:	90                   	nop
  101c3c:	90                   	nop
  101c3d:	90                   	nop
  101c3e:	90                   	nop
  101c3f:	90                   	nop
        if ((x % B) < 10)
  101c40:	89 da                	mov    edx,ebx
  101c42:	83 e2 0f             	and    edx,0xf
  101c45:	89 d1                	mov    ecx,edx
  101c47:	80 c9 30             	or     cl,0x30
  101c4a:	88 dd                	mov    ch,bl
  101c4c:	80 c5 06             	add    ch,0x6
  101c4f:	80 e5 0f             	and    ch,0xf
  101c52:	80 c5 41             	add    ch,0x41
  101c55:	83 fa 0a             	cmp    edx,0xa
  101c58:	0f b6 d1             	movzx  edx,cl
  101c5b:	0f b6 cd             	movzx  ecx,ch
  101c5e:	0f 42 ca             	cmovb  ecx,edx
        r[a] = i2c(x);
  101c61:	88 48 01             	mov    BYTE PTR [eax+0x1],cl
  101c64:	40                   	inc    eax
        x /= B;
  101c65:	c1 eb 04             	shr    ebx,0x4
    for (; x > 0; a++) {
  101c68:	46                   	inc    esi
  101c69:	85 db                	test   ebx,ebx
  101c6b:	75 d3                	jne    101c40 <kernel_main+0x90>
    r[a] = 0;
  101c6d:	c6 40 01 00          	mov    BYTE PTR [eax+0x1],0x0
    for (auto b = 0; b < a / 2; b++) {
  101c71:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  101c77:	74 35                	je     101cae <kernel_main+0xfe>
  101c79:	d1 ee                	shr    esi,1
  101c7b:	8d 94 24 f8 02 00 00 	lea    edx,[esp+0x2f8]
  101c82:	90                   	nop
  101c83:	90                   	nop
  101c84:	90                   	nop
  101c85:	90                   	nop
  101c86:	90                   	nop
  101c87:	90                   	nop
  101c88:	90                   	nop
  101c89:	90                   	nop
  101c8a:	90                   	nop
  101c8b:	90                   	nop
  101c8c:	90                   	nop
  101c8d:	90                   	nop
  101c8e:	90                   	nop
  101c8f:	90                   	nop
        r[b] ^= r[a - b - 1];
  101c90:	0f b6 0a             	movzx  ecx,BYTE PTR [edx]
  101c93:	32 08                	xor    cl,BYTE PTR [eax]
  101c95:	88 0a                	mov    BYTE PTR [edx],cl
        r[a - b - 1] ^= r[b];
  101c97:	32 08                	xor    cl,BYTE PTR [eax]
  101c99:	88 08                	mov    BYTE PTR [eax],cl
        r[b] ^= r[a - b - 1];
  101c9b:	30 0a                	xor    BYTE PTR [edx],cl
    for (auto b = 0; b < a / 2; b++) {
  101c9d:	42                   	inc    edx
  101c9e:	48                   	dec    eax
  101c9f:	4e                   	dec    esi
  101ca0:	75 ee                	jne    101c90 <kernel_main+0xe0>
  101ca2:	eb 0a                	jmp    101cae <kernel_main+0xfe>
        r[a++] = '0';
  101ca4:	66 c7 84 24 f8 02 00 	mov    WORD PTR [esp+0x2f8],0x30
  101cab:	00 30 00 
  101cae:	8d bc 24 f8 00 00 00 	lea    edi,[esp+0xf8]
  101cb5:	8d b4 24 f8 02 00 00 	lea    esi,[esp+0x2f8]
    return r;
  101cbc:	b9 09 00 00 00       	mov    ecx,0x9
  101cc1:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
        write(s[a]);
  101cc3:	6a 4c                	push   0x4c
  101cc5:	e8 76 f4 ff ff       	call   101140 <term::write(char)>
  101cca:	83 c4 04             	add    esp,0x4
  101ccd:	6a 6f                	push   0x6f
  101ccf:	e8 6c f4 ff ff       	call   101140 <term::write(char)>
  101cd4:	83 c4 04             	add    esp,0x4
  101cd7:	6a 61                	push   0x61
  101cd9:	e8 62 f4 ff ff       	call   101140 <term::write(char)>
  101cde:	83 c4 04             	add    esp,0x4
  101ce1:	6a 64                	push   0x64
  101ce3:	e8 58 f4 ff ff       	call   101140 <term::write(char)>
  101ce8:	83 c4 04             	add    esp,0x4
  101ceb:	6a 65                	push   0x65
  101ced:	e8 4e f4 ff ff       	call   101140 <term::write(char)>
  101cf2:	83 c4 04             	add    esp,0x4
  101cf5:	6a 64                	push   0x64
  101cf7:	e8 44 f4 ff ff       	call   101140 <term::write(char)>
  101cfc:	83 c4 04             	add    esp,0x4
  101cff:	6a 20                	push   0x20
  101d01:	e8 3a f4 ff ff       	call   101140 <term::write(char)>
  101d06:	83 c4 04             	add    esp,0x4
  101d09:	6a 47                	push   0x47
  101d0b:	e8 30 f4 ff ff       	call   101140 <term::write(char)>
  101d10:	83 c4 04             	add    esp,0x4
  101d13:	6a 52                	push   0x52
  101d15:	e8 26 f4 ff ff       	call   101140 <term::write(char)>
  101d1a:	83 c4 04             	add    esp,0x4
  101d1d:	6a 55                	push   0x55
  101d1f:	e8 1c f4 ff ff       	call   101140 <term::write(char)>
  101d24:	83 c4 04             	add    esp,0x4
  101d27:	6a 42                	push   0x42
  101d29:	e8 12 f4 ff ff       	call   101140 <term::write(char)>
  101d2e:	83 c4 04             	add    esp,0x4
  101d31:	6a 20                	push   0x20
  101d33:	e8 08 f4 ff ff       	call   101140 <term::write(char)>
  101d38:	83 c4 04             	add    esp,0x4
  101d3b:	6a 69                	push   0x69
  101d3d:	e8 fe f3 ff ff       	call   101140 <term::write(char)>
  101d42:	83 c4 04             	add    esp,0x4
  101d45:	6a 6e                	push   0x6e
  101d47:	e8 f4 f3 ff ff       	call   101140 <term::write(char)>
  101d4c:	83 c4 04             	add    esp,0x4
  101d4f:	6a 66                	push   0x66
  101d51:	e8 ea f3 ff ff       	call   101140 <term::write(char)>
  101d56:	83 c4 04             	add    esp,0x4
  101d59:	6a 6f                	push   0x6f
  101d5b:	e8 e0 f3 ff ff       	call   101140 <term::write(char)>
  101d60:	83 c4 04             	add    esp,0x4
  101d63:	6a 3a                	push   0x3a
  101d65:	e8 d6 f3 ff ff       	call   101140 <term::write(char)>
  101d6a:	83 c4 04             	add    esp,0x4
  101d6d:	6a 20                	push   0x20
  101d6f:	e8 cc f3 ff ff       	call   101140 <term::write(char)>
  101d74:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  101d77:	8a 84 24 f8 00 00 00 	mov    al,BYTE PTR [esp+0xf8]
  101d7e:	84 c0                	test   al,al
  101d80:	74 22                	je     101da4 <kernel_main+0x1f4>
  101d82:	8d b4 24 f9 00 00 00 	lea    esi,[esp+0xf9]
  101d89:	90                   	nop
  101d8a:	90                   	nop
  101d8b:	90                   	nop
  101d8c:	90                   	nop
  101d8d:	90                   	nop
  101d8e:	90                   	nop
  101d8f:	90                   	nop
        write(s[a]);
  101d90:	0f be c0             	movsx  eax,al
  101d93:	50                   	push   eax
  101d94:	e8 a7 f3 ff ff       	call   101140 <term::write(char)>
  101d99:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  101d9c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  101d9f:	46                   	inc    esi
  101da0:	84 c0                	test   al,al
  101da2:	75 ec                	jne    101d90 <kernel_main+0x1e0>
        write(s[a]);
  101da4:	6a 0a                	push   0xa
  101da6:	e8 95 f3 ff ff       	call   101140 <term::write(char)>
  101dab:	83 c4 04             	add    esp,0x4
  101dae:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
    term::write("Loaded GRUB info: ", int_to_string<16>(magic).str(), "\n");

    auto mods = reinterpret_cast<multiboot_module_t *>(mb->mods_addr);
    if (mb->mods_count > 0) {
  101db1:	8b 59 14             	mov    ebx,DWORD PTR [ecx+0x14]
    auto mods = reinterpret_cast<multiboot_module_t *>(mb->mods_addr);
  101db4:	8b 41 18             	mov    eax,DWORD PTR [ecx+0x18]
  101db7:	89 44 24 04          	mov    DWORD PTR [esp+0x4],eax
    if (mb->mods_count > 0) {
  101dbb:	85 db                	test   ebx,ebx
  101dbd:	0f 84 f6 05 00 00    	je     1023b9 <kernel_main+0x809>
    constexpr array() : data_{T()} {}
  101dc3:	66 c7 84 24 14 03 00 	mov    WORD PTR [esp+0x314],0x0
  101dca:	00 00 00 
  101dcd:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  101dd4:	00 00 00 00 
  101dd8:	c7 84 24 0c 03 00 00 	mov    DWORD PTR [esp+0x30c],0x0
  101ddf:	00 00 00 00 
  101de3:	c7 84 24 08 03 00 00 	mov    DWORD PTR [esp+0x308],0x0
  101dea:	00 00 00 00 
  101dee:	c7 84 24 04 03 00 00 	mov    DWORD PTR [esp+0x304],0x0
  101df5:	00 00 00 00 
  101df9:	c7 84 24 00 03 00 00 	mov    DWORD PTR [esp+0x300],0x0
  101e00:	00 00 00 00 
  101e04:	c7 84 24 fc 02 00 00 	mov    DWORD PTR [esp+0x2fc],0x0
  101e0b:	00 00 00 00 
  101e0f:	c7 84 24 f8 02 00 00 	mov    DWORD PTR [esp+0x2f8],0x0
  101e16:	00 00 00 00 
    int index_ = 0;
  101e1a:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  101e21:	00 00 00 00 
    if (x == 0)
  101e25:	8d b4 24 f7 02 00 00 	lea    esi,[esp+0x2f7]
  101e2c:	31 ff                	xor    edi,edi
  101e2e:	90                   	nop
  101e2f:	90                   	nop
        x /= B;
  101e30:	89 d8                	mov    eax,ebx
  101e32:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  101e37:	f7 e1                	mul    ecx
  101e39:	c1 ea 03             	shr    edx,0x3
  101e3c:	8d 04 12             	lea    eax,[edx+edx*1]
  101e3f:	8d 04 80             	lea    eax,[eax+eax*4]
  101e42:	89 d9                	mov    ecx,ebx
  101e44:	29 c1                	sub    ecx,eax
            return '0' + (x % B);
  101e46:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  101e49:	88 4e 01             	mov    BYTE PTR [esi+0x1],cl
  101e4c:	46                   	inc    esi
    for (; x > 0; a++) {
  101e4d:	47                   	inc    edi
  101e4e:	83 fb 09             	cmp    ebx,0x9
  101e51:	89 d3                	mov    ebx,edx
  101e53:	77 db                	ja     101e30 <kernel_main+0x280>
    r[a] = 0;
  101e55:	c6 46 01 00          	mov    BYTE PTR [esi+0x1],0x0
    for (auto b = 0; b < a / 2; b++) {
  101e59:	f7 c7 fe ff ff ff    	test   edi,0xfffffffe
  101e5f:	8d 8c 24 f8 02 00 00 	lea    ecx,[esp+0x2f8]
  101e66:	74 1a                	je     101e82 <kernel_main+0x2d2>
  101e68:	d1 ef                	shr    edi,1
  101e6a:	90                   	nop
  101e6b:	90                   	nop
  101e6c:	90                   	nop
  101e6d:	90                   	nop
  101e6e:	90                   	nop
  101e6f:	90                   	nop
        r[b] ^= r[a - b - 1];
  101e70:	0f b6 01             	movzx  eax,BYTE PTR [ecx]
  101e73:	32 06                	xor    al,BYTE PTR [esi]
  101e75:	88 01                	mov    BYTE PTR [ecx],al
        r[a - b - 1] ^= r[b];
  101e77:	32 06                	xor    al,BYTE PTR [esi]
  101e79:	88 06                	mov    BYTE PTR [esi],al
        r[b] ^= r[a - b - 1];
  101e7b:	30 01                	xor    BYTE PTR [ecx],al
    for (auto b = 0; b < a / 2; b++) {
  101e7d:	41                   	inc    ecx
  101e7e:	4e                   	dec    esi
  101e7f:	4f                   	dec    edi
  101e80:	75 ee                	jne    101e70 <kernel_main+0x2c0>
  101e82:	8d bc 24 f8 00 00 00 	lea    edi,[esp+0xf8]
  101e89:	8d 84 24 f8 02 00 00 	lea    eax,[esp+0x2f8]
    return r;
  101e90:	b9 09 00 00 00       	mov    ecx,0x9
  101e95:	89 c6                	mov    esi,eax
  101e97:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
    constexpr array() : data_{T()} {}
  101e99:	66 c7 84 24 14 03 00 	mov    WORD PTR [esp+0x314],0x0
  101ea0:	00 00 00 
  101ea3:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  101eaa:	00 00 00 00 
  101eae:	c7 84 24 0c 03 00 00 	mov    DWORD PTR [esp+0x30c],0x0
  101eb5:	00 00 00 00 
  101eb9:	c7 84 24 08 03 00 00 	mov    DWORD PTR [esp+0x308],0x0
  101ec0:	00 00 00 00 
  101ec4:	c7 84 24 04 03 00 00 	mov    DWORD PTR [esp+0x304],0x0
  101ecb:	00 00 00 00 
  101ecf:	c7 84 24 00 03 00 00 	mov    DWORD PTR [esp+0x300],0x0
  101ed6:	00 00 00 00 
  101eda:	c7 84 24 fc 02 00 00 	mov    DWORD PTR [esp+0x2fc],0x0
  101ee1:	00 00 00 00 
  101ee5:	c7 84 24 f8 02 00 00 	mov    DWORD PTR [esp+0x2f8],0x0
  101eec:	00 00 00 00 
    int index_ = 0;
  101ef0:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  101ef7:	00 00 00 00 
  101efb:	8b 5c 24 04          	mov    ebx,DWORD PTR [esp+0x4]
    if (x == 0)
  101eff:	85 db                	test   ebx,ebx
  101f01:	74 61                	je     101f64 <kernel_main+0x3b4>
  101f03:	89 c7                	mov    edi,eax
    for (; x > 0; a++) {
  101f05:	8d 8c 24 f7 02 00 00 	lea    ecx,[esp+0x2f7]
  101f0c:	31 f6                	xor    esi,esi
  101f0e:	90                   	nop
  101f0f:	90                   	nop
        if ((x % B) < 10)
  101f10:	89 d8                	mov    eax,ebx
  101f12:	83 e0 0f             	and    eax,0xf
  101f15:	89 c2                	mov    edx,eax
  101f17:	80 ca 30             	or     dl,0x30
  101f1a:	88 de                	mov    dh,bl
  101f1c:	80 c6 06             	add    dh,0x6
  101f1f:	80 e6 0f             	and    dh,0xf
  101f22:	80 c6 41             	add    dh,0x41
  101f25:	83 f8 0a             	cmp    eax,0xa
  101f28:	0f b6 c2             	movzx  eax,dl
  101f2b:	0f b6 d6             	movzx  edx,dh
  101f2e:	0f 42 d0             	cmovb  edx,eax
        r[a] = i2c(x);
  101f31:	88 51 01             	mov    BYTE PTR [ecx+0x1],dl
  101f34:	41                   	inc    ecx
        x /= B;
  101f35:	c1 eb 04             	shr    ebx,0x4
    for (; x > 0; a++) {
  101f38:	46                   	inc    esi
  101f39:	85 db                	test   ebx,ebx
  101f3b:	75 d3                	jne    101f10 <kernel_main+0x360>
    r[a] = 0;
  101f3d:	c6 41 01 00          	mov    BYTE PTR [ecx+0x1],0x0
    for (auto b = 0; b < a / 2; b++) {
  101f41:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  101f47:	74 25                	je     101f6e <kernel_main+0x3be>
  101f49:	d1 ee                	shr    esi,1
  101f4b:	90                   	nop
  101f4c:	90                   	nop
  101f4d:	90                   	nop
  101f4e:	90                   	nop
  101f4f:	90                   	nop
        r[b] ^= r[a - b - 1];
  101f50:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  101f53:	32 01                	xor    al,BYTE PTR [ecx]
  101f55:	88 07                	mov    BYTE PTR [edi],al
        r[a - b - 1] ^= r[b];
  101f57:	32 01                	xor    al,BYTE PTR [ecx]
  101f59:	88 01                	mov    BYTE PTR [ecx],al
        r[b] ^= r[a - b - 1];
  101f5b:	30 07                	xor    BYTE PTR [edi],al
    for (auto b = 0; b < a / 2; b++) {
  101f5d:	47                   	inc    edi
  101f5e:	49                   	dec    ecx
  101f5f:	4e                   	dec    esi
  101f60:	75 ee                	jne    101f50 <kernel_main+0x3a0>
  101f62:	eb 0a                	jmp    101f6e <kernel_main+0x3be>
        r[a++] = '0';
  101f64:	66 c7 84 24 f8 02 00 	mov    WORD PTR [esp+0x2f8],0x30
  101f6b:	00 30 00 
  101f6e:	8d 44 24 10          	lea    eax,[esp+0x10]
  101f72:	8d b4 24 f8 02 00 00 	lea    esi,[esp+0x2f8]
    return r;
  101f79:	b9 09 00 00 00       	mov    ecx,0x9
  101f7e:	89 c7                	mov    edi,eax
  101f80:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
        term::write("Loaded ", int_to_string(mb->mods_count).str(),
  101f82:	68 9f 00 10 00       	push   0x10009f
  101f87:	50                   	push   eax
  101f88:	68 a1 00 10 00       	push   0x1000a1
  101f8d:	8d 84 24 04 01 00 00 	lea    eax,[esp+0x104]
  101f94:	50                   	push   eax
  101f95:	68 dc 00 10 00       	push   0x1000dc
  101f9a:	e8 01 18 00 00       	call   1037a0 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)>
  101f9f:	83 c4 14             	add    esp,0x14
  101fa2:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
                    " modules at 0x", int_to_string<16>(mb->mods_addr).str(),
                    "\n");
        for (uint32 a = 0; a < mb->mods_count; a++) {
  101fa5:	83 79 14 00          	cmp    DWORD PTR [ecx+0x14],0x0
  101fa9:	0f 84 0a 04 00 00    	je     1023b9 <kernel_main+0x809>
  101faf:	31 db                	xor    ebx,ebx
  101fb1:	eb 28                	jmp    101fdb <kernel_main+0x42b>
  101fb3:	90                   	nop
  101fb4:	90                   	nop
  101fb5:	90                   	nop
  101fb6:	90                   	nop
  101fb7:	90                   	nop
  101fb8:	90                   	nop
  101fb9:	90                   	nop
  101fba:	90                   	nop
  101fbb:	90                   	nop
  101fbc:	90                   	nop
  101fbd:	90                   	nop
  101fbe:	90                   	nop
  101fbf:	90                   	nop
  101fc0:	6a 0a                	push   0xa
  101fc2:	e8 79 f1 ff ff       	call   101140 <term::write(char)>
  101fc7:	83 c4 04             	add    esp,0x4
  101fca:	8b 5c 24 0c          	mov    ebx,DWORD PTR [esp+0xc]
  101fce:	43                   	inc    ebx
  101fcf:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
  101fd2:	3b 59 14             	cmp    ebx,DWORD PTR [ecx+0x14]
  101fd5:	0f 83 de 03 00 00    	jae    1023b9 <kernel_main+0x809>
    constexpr array() : data_{T()} {}
  101fdb:	66 c7 84 24 14 03 00 	mov    WORD PTR [esp+0x314],0x0
  101fe2:	00 00 00 
  101fe5:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  101fec:	00 00 00 00 
  101ff0:	c7 84 24 0c 03 00 00 	mov    DWORD PTR [esp+0x30c],0x0
  101ff7:	00 00 00 00 
  101ffb:	c7 84 24 08 03 00 00 	mov    DWORD PTR [esp+0x308],0x0
  102002:	00 00 00 00 
  102006:	c7 84 24 04 03 00 00 	mov    DWORD PTR [esp+0x304],0x0
  10200d:	00 00 00 00 
  102011:	c7 84 24 00 03 00 00 	mov    DWORD PTR [esp+0x300],0x0
  102018:	00 00 00 00 
  10201c:	c7 84 24 fc 02 00 00 	mov    DWORD PTR [esp+0x2fc],0x0
  102023:	00 00 00 00 
  102027:	c7 84 24 f8 02 00 00 	mov    DWORD PTR [esp+0x2f8],0x0
  10202e:	00 00 00 00 
    int index_ = 0;
  102032:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  102039:	00 00 00 00 
    if (x == 0)
  10203d:	85 db                	test   ebx,ebx
  10203f:	89 5c 24 0c          	mov    DWORD PTR [esp+0xc],ebx
  102043:	0f 84 97 00 00 00    	je     1020e0 <kernel_main+0x530>
  102049:	31 ff                	xor    edi,edi
  10204b:	b9 01 00 00 00       	mov    ecx,0x1
  102050:	8d 84 24 f8 02 00 00 	lea    eax,[esp+0x2f8]
  102057:	89 04 24             	mov    DWORD PTR [esp],eax
  10205a:	90                   	nop
  10205b:	90                   	nop
  10205c:	90                   	nop
  10205d:	90                   	nop
  10205e:	90                   	nop
  10205f:	90                   	nop
        x /= B;
  102060:	89 d8                	mov    eax,ebx
  102062:	89 ce                	mov    esi,ecx
  102064:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  102069:	f7 e1                	mul    ecx
  10206b:	c1 ea 03             	shr    edx,0x3
  10206e:	8d 04 12             	lea    eax,[edx+edx*1]
  102071:	8d 04 80             	lea    eax,[eax+eax*4]
  102074:	89 d9                	mov    ecx,ebx
  102076:	29 c1                	sub    ecx,eax
  102078:	89 f0                	mov    eax,esi
  10207a:	8b 34 24             	mov    esi,DWORD PTR [esp]
            return '0' + (x % B);
  10207d:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  102080:	88 8c 3c f8 02 00 00 	mov    BYTE PTR [esp+edi*1+0x2f8],cl
    for (; x > 0; a++) {
  102087:	47                   	inc    edi
  102088:	8d 48 01             	lea    ecx,[eax+0x1]
  10208b:	83 fb 09             	cmp    ebx,0x9
  10208e:	8d 5e 01             	lea    ebx,[esi+0x1]
  102091:	89 1c 24             	mov    DWORD PTR [esp],ebx
  102094:	89 d3                	mov    ebx,edx
  102096:	77 c8                	ja     102060 <kernel_main+0x4b0>
    r[a] = 0;
  102098:	c6 84 3c f8 02 00 00 	mov    BYTE PTR [esp+edi*1+0x2f8],0x0
  10209f:	00 
    for (auto b = 0; b < a / 2; b++) {
  1020a0:	f7 c7 fe ff ff ff    	test   edi,0xfffffffe
  1020a6:	8b 5c 24 0c          	mov    ebx,DWORD PTR [esp+0xc]
  1020aa:	74 3e                	je     1020ea <kernel_main+0x53a>
  1020ac:	d1 e8                	shr    eax,1
  1020ae:	8d 8c 24 f8 02 00 00 	lea    ecx,[esp+0x2f8]
  1020b5:	90                   	nop
  1020b6:	90                   	nop
  1020b7:	90                   	nop
  1020b8:	90                   	nop
  1020b9:	90                   	nop
  1020ba:	90                   	nop
  1020bb:	90                   	nop
  1020bc:	90                   	nop
  1020bd:	90                   	nop
  1020be:	90                   	nop
  1020bf:	90                   	nop
        r[b] ^= r[a - b - 1];
  1020c0:	0f b6 11             	movzx  edx,BYTE PTR [ecx]
  1020c3:	32 16                	xor    dl,BYTE PTR [esi]
  1020c5:	88 11                	mov    BYTE PTR [ecx],dl
        r[a - b - 1] ^= r[b];
  1020c7:	32 16                	xor    dl,BYTE PTR [esi]
  1020c9:	88 16                	mov    BYTE PTR [esi],dl
        r[b] ^= r[a - b - 1];
  1020cb:	30 11                	xor    BYTE PTR [ecx],dl
    for (auto b = 0; b < a / 2; b++) {
  1020cd:	41                   	inc    ecx
  1020ce:	4e                   	dec    esi
  1020cf:	48                   	dec    eax
  1020d0:	75 ee                	jne    1020c0 <kernel_main+0x510>
  1020d2:	eb 16                	jmp    1020ea <kernel_main+0x53a>
  1020d4:	90                   	nop
  1020d5:	90                   	nop
  1020d6:	90                   	nop
  1020d7:	90                   	nop
  1020d8:	90                   	nop
  1020d9:	90                   	nop
  1020da:	90                   	nop
  1020db:	90                   	nop
  1020dc:	90                   	nop
  1020dd:	90                   	nop
  1020de:	90                   	nop
  1020df:	90                   	nop
        r[a++] = '0';
  1020e0:	66 c7 84 24 f8 02 00 	mov    WORD PTR [esp+0x2f8],0x30
  1020e7:	00 30 00 
    return r;
  1020ea:	b9 09 00 00 00       	mov    ecx,0x9
  1020ef:	8d bc 24 f8 00 00 00 	lea    edi,[esp+0xf8]
  1020f6:	8d 84 24 f8 02 00 00 	lea    eax,[esp+0x2f8]
  1020fd:	89 c6                	mov    esi,eax
  1020ff:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
            term::write("Module ", int_to_string(a).str(), ": from ",
                        int_to_string<16>(mods[a].mod_start).str(), " to ",
  102101:	89 d9                	mov    ecx,ebx
  102103:	c1 e1 04             	shl    ecx,0x4
  102106:	8b 5c 24 04          	mov    ebx,DWORD PTR [esp+0x4]
  10210a:	89 4c 24 08          	mov    DWORD PTR [esp+0x8],ecx
  10210e:	8b 14 0b             	mov    edx,DWORD PTR [ebx+ecx*1]
    constexpr array() : data_{T()} {}
  102111:	66 c7 84 24 14 03 00 	mov    WORD PTR [esp+0x314],0x0
  102118:	00 00 00 
  10211b:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  102122:	00 00 00 00 
  102126:	c7 84 24 0c 03 00 00 	mov    DWORD PTR [esp+0x30c],0x0
  10212d:	00 00 00 00 
  102131:	c7 84 24 08 03 00 00 	mov    DWORD PTR [esp+0x308],0x0
  102138:	00 00 00 00 
  10213c:	c7 84 24 04 03 00 00 	mov    DWORD PTR [esp+0x304],0x0
  102143:	00 00 00 00 
  102147:	c7 84 24 00 03 00 00 	mov    DWORD PTR [esp+0x300],0x0
  10214e:	00 00 00 00 
  102152:	c7 84 24 fc 02 00 00 	mov    DWORD PTR [esp+0x2fc],0x0
  102159:	00 00 00 00 
  10215d:	c7 84 24 f8 02 00 00 	mov    DWORD PTR [esp+0x2f8],0x0
  102164:	00 00 00 00 
    int index_ = 0;
  102168:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  10216f:	00 00 00 00 
    if (x == 0)
  102173:	85 d2                	test   edx,edx
  102175:	0f 84 95 00 00 00    	je     102210 <kernel_main+0x660>
  10217b:	31 f6                	xor    esi,esi
  10217d:	bf 01 00 00 00       	mov    edi,0x1
  102182:	89 c3                	mov    ebx,eax
  102184:	90                   	nop
  102185:	90                   	nop
  102186:	90                   	nop
  102187:	90                   	nop
  102188:	90                   	nop
  102189:	90                   	nop
  10218a:	90                   	nop
  10218b:	90                   	nop
  10218c:	90                   	nop
  10218d:	90                   	nop
  10218e:	90                   	nop
  10218f:	90                   	nop
  102190:	89 3c 24             	mov    DWORD PTR [esp],edi
  102193:	89 d9                	mov    ecx,ebx
        if ((x % B) < 10)
  102195:	89 d3                	mov    ebx,edx
  102197:	83 e3 0f             	and    ebx,0xf
  10219a:	89 d8                	mov    eax,ebx
  10219c:	0c 30                	or     al,0x30
  10219e:	88 d4                	mov    ah,dl
  1021a0:	80 c4 06             	add    ah,0x6
  1021a3:	80 e4 0f             	and    ah,0xf
  1021a6:	80 c4 41             	add    ah,0x41
  1021a9:	83 fb 0a             	cmp    ebx,0xa
  1021ac:	0f b6 f8             	movzx  edi,al
  1021af:	0f b6 c4             	movzx  eax,ah
  1021b2:	0f 42 c7             	cmovb  eax,edi
        r[a] = i2c(x);
  1021b5:	88 84 34 f8 02 00 00 	mov    BYTE PTR [esp+esi*1+0x2f8],al
  1021bc:	8b 04 24             	mov    eax,DWORD PTR [esp]
        x /= B;
  1021bf:	c1 ea 04             	shr    edx,0x4
    for (; x > 0; a++) {
  1021c2:	46                   	inc    esi
  1021c3:	8d 78 01             	lea    edi,[eax+0x1]
  1021c6:	8d 59 01             	lea    ebx,[ecx+0x1]
  1021c9:	85 d2                	test   edx,edx
  1021cb:	75 c3                	jne    102190 <kernel_main+0x5e0>
    r[a] = 0;
  1021cd:	c6 84 34 f8 02 00 00 	mov    BYTE PTR [esp+esi*1+0x2f8],0x0
  1021d4:	00 
    for (auto b = 0; b < a / 2; b++) {
  1021d5:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  1021db:	8b 5c 24 04          	mov    ebx,DWORD PTR [esp+0x4]
  1021df:	74 39                	je     10221a <kernel_main+0x66a>
  1021e1:	89 c6                	mov    esi,eax
  1021e3:	d1 ee                	shr    esi,1
  1021e5:	8d 94 24 f8 02 00 00 	lea    edx,[esp+0x2f8]
  1021ec:	90                   	nop
  1021ed:	90                   	nop
  1021ee:	90                   	nop
  1021ef:	90                   	nop
        r[b] ^= r[a - b - 1];
  1021f0:	0f b6 02             	movzx  eax,BYTE PTR [edx]
  1021f3:	32 01                	xor    al,BYTE PTR [ecx]
  1021f5:	88 02                	mov    BYTE PTR [edx],al
        r[a - b - 1] ^= r[b];
  1021f7:	32 01                	xor    al,BYTE PTR [ecx]
  1021f9:	88 01                	mov    BYTE PTR [ecx],al
        r[b] ^= r[a - b - 1];
  1021fb:	30 02                	xor    BYTE PTR [edx],al
    for (auto b = 0; b < a / 2; b++) {
  1021fd:	42                   	inc    edx
  1021fe:	49                   	dec    ecx
  1021ff:	4e                   	dec    esi
  102200:	75 ee                	jne    1021f0 <kernel_main+0x640>
  102202:	eb 16                	jmp    10221a <kernel_main+0x66a>
  102204:	90                   	nop
  102205:	90                   	nop
  102206:	90                   	nop
  102207:	90                   	nop
  102208:	90                   	nop
  102209:	90                   	nop
  10220a:	90                   	nop
  10220b:	90                   	nop
  10220c:	90                   	nop
  10220d:	90                   	nop
  10220e:	90                   	nop
  10220f:	90                   	nop
        r[a++] = '0';
  102210:	66 c7 84 24 f8 02 00 	mov    WORD PTR [esp+0x2f8],0x30
  102217:	00 30 00 
    return r;
  10221a:	b9 09 00 00 00       	mov    ecx,0x9
  10221f:	8d 7c 24 10          	lea    edi,[esp+0x10]
  102223:	8d 84 24 f8 02 00 00 	lea    eax,[esp+0x2f8]
  10222a:	89 c6                	mov    esi,eax
  10222c:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  10222e:	8b 4c 24 08          	mov    ecx,DWORD PTR [esp+0x8]
                        int_to_string<16>(mods[a].mod_end).str(), "\n");
  102232:	8b 54 0b 04          	mov    edx,DWORD PTR [ebx+ecx*1+0x4]
    constexpr array() : data_{T()} {}
  102236:	66 c7 84 24 14 03 00 	mov    WORD PTR [esp+0x314],0x0
  10223d:	00 00 00 
  102240:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  102247:	00 00 00 00 
  10224b:	c7 84 24 0c 03 00 00 	mov    DWORD PTR [esp+0x30c],0x0
  102252:	00 00 00 00 
  102256:	c7 84 24 08 03 00 00 	mov    DWORD PTR [esp+0x308],0x0
  10225d:	00 00 00 00 
  102261:	c7 84 24 04 03 00 00 	mov    DWORD PTR [esp+0x304],0x0
  102268:	00 00 00 00 
  10226c:	c7 84 24 00 03 00 00 	mov    DWORD PTR [esp+0x300],0x0
  102273:	00 00 00 00 
  102277:	c7 84 24 fc 02 00 00 	mov    DWORD PTR [esp+0x2fc],0x0
  10227e:	00 00 00 00 
  102282:	c7 84 24 f8 02 00 00 	mov    DWORD PTR [esp+0x2f8],0x0
  102289:	00 00 00 00 
    int index_ = 0;
  10228d:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  102294:	00 00 00 00 
    if (x == 0)
  102298:	85 d2                	test   edx,edx
  10229a:	0f 84 90 00 00 00    	je     102330 <kernel_main+0x780>
  1022a0:	31 f6                	xor    esi,esi
  1022a2:	bf 01 00 00 00       	mov    edi,0x1
  1022a7:	89 c3                	mov    ebx,eax
  1022a9:	90                   	nop
  1022aa:	90                   	nop
  1022ab:	90                   	nop
  1022ac:	90                   	nop
  1022ad:	90                   	nop
  1022ae:	90                   	nop
  1022af:	90                   	nop
  1022b0:	89 3c 24             	mov    DWORD PTR [esp],edi
  1022b3:	89 d9                	mov    ecx,ebx
        if ((x % B) < 10)
  1022b5:	89 d3                	mov    ebx,edx
  1022b7:	83 e3 0f             	and    ebx,0xf
  1022ba:	89 d8                	mov    eax,ebx
  1022bc:	0c 30                	or     al,0x30
  1022be:	88 d4                	mov    ah,dl
  1022c0:	80 c4 06             	add    ah,0x6
  1022c3:	80 e4 0f             	and    ah,0xf
  1022c6:	80 c4 41             	add    ah,0x41
  1022c9:	83 fb 0a             	cmp    ebx,0xa
  1022cc:	0f b6 f8             	movzx  edi,al
  1022cf:	0f b6 c4             	movzx  eax,ah
  1022d2:	0f 42 c7             	cmovb  eax,edi
        r[a] = i2c(x);
  1022d5:	88 84 34 f8 02 00 00 	mov    BYTE PTR [esp+esi*1+0x2f8],al
  1022dc:	8b 04 24             	mov    eax,DWORD PTR [esp]
        x /= B;
  1022df:	c1 ea 04             	shr    edx,0x4
    for (; x > 0; a++) {
  1022e2:	46                   	inc    esi
  1022e3:	8d 78 01             	lea    edi,[eax+0x1]
  1022e6:	8d 59 01             	lea    ebx,[ecx+0x1]
  1022e9:	85 d2                	test   edx,edx
  1022eb:	75 c3                	jne    1022b0 <kernel_main+0x700>
    r[a] = 0;
  1022ed:	c6 84 34 f8 02 00 00 	mov    BYTE PTR [esp+esi*1+0x2f8],0x0
  1022f4:	00 
    for (auto b = 0; b < a / 2; b++) {
  1022f5:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  1022fb:	8b 5c 24 04          	mov    ebx,DWORD PTR [esp+0x4]
  1022ff:	74 39                	je     10233a <kernel_main+0x78a>
  102301:	89 c6                	mov    esi,eax
  102303:	d1 ee                	shr    esi,1
  102305:	8d 94 24 f8 02 00 00 	lea    edx,[esp+0x2f8]
  10230c:	90                   	nop
  10230d:	90                   	nop
  10230e:	90                   	nop
  10230f:	90                   	nop
        r[b] ^= r[a - b - 1];
  102310:	0f b6 02             	movzx  eax,BYTE PTR [edx]
  102313:	32 01                	xor    al,BYTE PTR [ecx]
  102315:	88 02                	mov    BYTE PTR [edx],al
        r[a - b - 1] ^= r[b];
  102317:	32 01                	xor    al,BYTE PTR [ecx]
  102319:	88 01                	mov    BYTE PTR [ecx],al
        r[b] ^= r[a - b - 1];
  10231b:	30 02                	xor    BYTE PTR [edx],al
    for (auto b = 0; b < a / 2; b++) {
  10231d:	42                   	inc    edx
  10231e:	49                   	dec    ecx
  10231f:	4e                   	dec    esi
  102320:	75 ee                	jne    102310 <kernel_main+0x760>
  102322:	eb 16                	jmp    10233a <kernel_main+0x78a>
  102324:	90                   	nop
  102325:	90                   	nop
  102326:	90                   	nop
  102327:	90                   	nop
  102328:	90                   	nop
  102329:	90                   	nop
  10232a:	90                   	nop
  10232b:	90                   	nop
  10232c:	90                   	nop
  10232d:	90                   	nop
  10232e:	90                   	nop
  10232f:	90                   	nop
        r[a++] = '0';
  102330:	66 c7 84 24 f8 02 00 	mov    WORD PTR [esp+0x2f8],0x30
  102337:	00 30 00 
    return r;
  10233a:	b9 09 00 00 00       	mov    ecx,0x9
  10233f:	8d 44 24 70          	lea    eax,[esp+0x70]
  102343:	89 c7                	mov    edi,eax
  102345:	8d b4 24 f8 02 00 00 	lea    esi,[esp+0x2f8]
  10234c:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
            term::write("Module ", int_to_string(a).str(), ": from ",
  10234e:	68 9f 00 10 00       	push   0x10009f
  102353:	50                   	push   eax
  102354:	68 9a 00 10 00       	push   0x10009a
  102359:	8d 44 24 1c          	lea    eax,[esp+0x1c]
  10235d:	50                   	push   eax
  10235e:	68 b0 00 10 00       	push   0x1000b0
  102363:	8d 84 24 0c 01 00 00 	lea    eax,[esp+0x10c]
  10236a:	50                   	push   eax
  10236b:	68 49 00 10 00       	push   0x100049
  102370:	e8 eb 14 00 00       	call   103860 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)>
  102375:	83 c4 1c             	add    esp,0x1c
  102378:	8b 44 24 08          	mov    eax,DWORD PTR [esp+0x8]
                term::write(" ", reinterpret_cast<const char*>(mods[a].cmdline),"\n");
  10237c:	8b 74 03 08          	mov    esi,DWORD PTR [ebx+eax*1+0x8]
  102380:	6a 20                	push   0x20
  102382:	e8 b9 ed ff ff       	call   101140 <term::write(char)>
  102387:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10238a:	8a 06                	mov    al,BYTE PTR [esi]
  10238c:	84 c0                	test   al,al
  10238e:	0f 84 2c fc ff ff    	je     101fc0 <kernel_main+0x410>
  102394:	46                   	inc    esi
  102395:	90                   	nop
  102396:	90                   	nop
  102397:	90                   	nop
  102398:	90                   	nop
  102399:	90                   	nop
  10239a:	90                   	nop
  10239b:	90                   	nop
  10239c:	90                   	nop
  10239d:	90                   	nop
  10239e:	90                   	nop
  10239f:	90                   	nop
        write(s[a]);
  1023a0:	0f be c0             	movsx  eax,al
  1023a3:	50                   	push   eax
  1023a4:	e8 97 ed ff ff       	call   101140 <term::write(char)>
  1023a9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  1023ac:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  1023af:	46                   	inc    esi
  1023b0:	84 c0                	test   al,al
  1023b2:	75 ec                	jne    1023a0 <kernel_main+0x7f0>
  1023b4:	e9 07 fc ff ff       	jmp    101fc0 <kernel_main+0x410>
        }
    }

    if ((mb->flags & 1) == 1) {
  1023b9:	f6 01 01             	test   BYTE PTR [ecx],0x1
  1023bc:	0f 84 aa 01 00 00    	je     10256c <kernel_main+0x9bc>
        term::write("Mem size: ",
                    int_to_string(mb->mem_upper * mem::KB / mem::MB).str(),
  1023c2:	8b 59 08             	mov    ebx,DWORD PTR [ecx+0x8]
  1023c5:	c1 eb 0a             	shr    ebx,0xa
    if (x == 0)
  1023c8:	81 e3 ff 0f 00 00    	and    ebx,0xfff
    constexpr array() : data_{T()} {}
  1023ce:	66 c7 84 24 14 03 00 	mov    WORD PTR [esp+0x314],0x0
  1023d5:	00 00 00 
  1023d8:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  1023df:	00 00 00 00 
  1023e3:	c7 84 24 0c 03 00 00 	mov    DWORD PTR [esp+0x30c],0x0
  1023ea:	00 00 00 00 
  1023ee:	c7 84 24 08 03 00 00 	mov    DWORD PTR [esp+0x308],0x0
  1023f5:	00 00 00 00 
  1023f9:	c7 84 24 04 03 00 00 	mov    DWORD PTR [esp+0x304],0x0
  102400:	00 00 00 00 
  102404:	c7 84 24 00 03 00 00 	mov    DWORD PTR [esp+0x300],0x0
  10240b:	00 00 00 00 
  10240f:	c7 84 24 fc 02 00 00 	mov    DWORD PTR [esp+0x2fc],0x0
  102416:	00 00 00 00 
  10241a:	c7 84 24 f8 02 00 00 	mov    DWORD PTR [esp+0x2f8],0x0
  102421:	00 00 00 00 
    int index_ = 0;
  102425:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  10242c:	00 00 00 00 
    if (x == 0)
  102430:	74 62                	je     102494 <kernel_main+0x8e4>
    for (; x > 0; a++) {
  102432:	8d b4 24 f7 02 00 00 	lea    esi,[esp+0x2f7]
  102439:	31 ff                	xor    edi,edi
  10243b:	90                   	nop
  10243c:	90                   	nop
  10243d:	90                   	nop
  10243e:	90                   	nop
  10243f:	90                   	nop
        x /= B;
  102440:	89 d8                	mov    eax,ebx
  102442:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  102447:	f7 e1                	mul    ecx
  102449:	c1 ea 03             	shr    edx,0x3
  10244c:	8d 04 12             	lea    eax,[edx+edx*1]
  10244f:	8d 04 80             	lea    eax,[eax+eax*4]
  102452:	89 d9                	mov    ecx,ebx
  102454:	29 c1                	sub    ecx,eax
            return '0' + (x % B);
  102456:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  102459:	88 4e 01             	mov    BYTE PTR [esi+0x1],cl
  10245c:	46                   	inc    esi
    for (; x > 0; a++) {
  10245d:	47                   	inc    edi
  10245e:	83 fb 09             	cmp    ebx,0x9
  102461:	89 d3                	mov    ebx,edx
  102463:	77 db                	ja     102440 <kernel_main+0x890>
    r[a] = 0;
  102465:	c6 46 01 00          	mov    BYTE PTR [esi+0x1],0x0
    for (auto b = 0; b < a / 2; b++) {
  102469:	f7 c7 fe ff ff ff    	test   edi,0xfffffffe
  10246f:	74 2d                	je     10249e <kernel_main+0x8ee>
  102471:	d1 ef                	shr    edi,1
  102473:	8d 84 24 f8 02 00 00 	lea    eax,[esp+0x2f8]
  10247a:	90                   	nop
  10247b:	90                   	nop
  10247c:	90                   	nop
  10247d:	90                   	nop
  10247e:	90                   	nop
  10247f:	90                   	nop
        r[b] ^= r[a - b - 1];
  102480:	0f b6 08             	movzx  ecx,BYTE PTR [eax]
  102483:	32 0e                	xor    cl,BYTE PTR [esi]
  102485:	88 08                	mov    BYTE PTR [eax],cl
        r[a - b - 1] ^= r[b];
  102487:	32 0e                	xor    cl,BYTE PTR [esi]
  102489:	88 0e                	mov    BYTE PTR [esi],cl
        r[b] ^= r[a - b - 1];
  10248b:	30 08                	xor    BYTE PTR [eax],cl
    for (auto b = 0; b < a / 2; b++) {
  10248d:	40                   	inc    eax
  10248e:	4e                   	dec    esi
  10248f:	4f                   	dec    edi
  102490:	75 ee                	jne    102480 <kernel_main+0x8d0>
  102492:	eb 0a                	jmp    10249e <kernel_main+0x8ee>
        r[a++] = '0';
  102494:	66 c7 84 24 f8 02 00 	mov    WORD PTR [esp+0x2f8],0x30
  10249b:	00 30 00 
  10249e:	8d bc 24 f8 00 00 00 	lea    edi,[esp+0xf8]
  1024a5:	8d b4 24 f8 02 00 00 	lea    esi,[esp+0x2f8]
    return r;
  1024ac:	b9 09 00 00 00       	mov    ecx,0x9
  1024b1:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
        write(s[a]);
  1024b3:	6a 4d                	push   0x4d
  1024b5:	e8 86 ec ff ff       	call   101140 <term::write(char)>
  1024ba:	83 c4 04             	add    esp,0x4
  1024bd:	6a 65                	push   0x65
  1024bf:	e8 7c ec ff ff       	call   101140 <term::write(char)>
  1024c4:	83 c4 04             	add    esp,0x4
  1024c7:	6a 6d                	push   0x6d
  1024c9:	e8 72 ec ff ff       	call   101140 <term::write(char)>
  1024ce:	83 c4 04             	add    esp,0x4
  1024d1:	6a 20                	push   0x20
  1024d3:	e8 68 ec ff ff       	call   101140 <term::write(char)>
  1024d8:	83 c4 04             	add    esp,0x4
  1024db:	6a 73                	push   0x73
  1024dd:	e8 5e ec ff ff       	call   101140 <term::write(char)>
  1024e2:	83 c4 04             	add    esp,0x4
  1024e5:	6a 69                	push   0x69
  1024e7:	e8 54 ec ff ff       	call   101140 <term::write(char)>
  1024ec:	83 c4 04             	add    esp,0x4
  1024ef:	6a 7a                	push   0x7a
  1024f1:	e8 4a ec ff ff       	call   101140 <term::write(char)>
  1024f6:	83 c4 04             	add    esp,0x4
  1024f9:	6a 65                	push   0x65
  1024fb:	e8 40 ec ff ff       	call   101140 <term::write(char)>
  102500:	83 c4 04             	add    esp,0x4
  102503:	6a 3a                	push   0x3a
  102505:	e8 36 ec ff ff       	call   101140 <term::write(char)>
  10250a:	83 c4 04             	add    esp,0x4
  10250d:	6a 20                	push   0x20
  10250f:	e8 2c ec ff ff       	call   101140 <term::write(char)>
  102514:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102517:	8a 84 24 f8 00 00 00 	mov    al,BYTE PTR [esp+0xf8]
  10251e:	84 c0                	test   al,al
  102520:	74 22                	je     102544 <kernel_main+0x994>
  102522:	8d b4 24 f9 00 00 00 	lea    esi,[esp+0xf9]
  102529:	90                   	nop
  10252a:	90                   	nop
  10252b:	90                   	nop
  10252c:	90                   	nop
  10252d:	90                   	nop
  10252e:	90                   	nop
  10252f:	90                   	nop
        write(s[a]);
  102530:	0f be c0             	movsx  eax,al
  102533:	50                   	push   eax
  102534:	e8 07 ec ff ff       	call   101140 <term::write(char)>
  102539:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10253c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10253f:	46                   	inc    esi
  102540:	84 c0                	test   al,al
  102542:	75 ec                	jne    102530 <kernel_main+0x980>
        write(s[a]);
  102544:	6a 20                	push   0x20
  102546:	e8 f5 eb ff ff       	call   101140 <term::write(char)>
  10254b:	83 c4 04             	add    esp,0x4
  10254e:	6a 4d                	push   0x4d
  102550:	e8 eb eb ff ff       	call   101140 <term::write(char)>
  102555:	83 c4 04             	add    esp,0x4
  102558:	6a 42                	push   0x42
  10255a:	e8 e1 eb ff ff       	call   101140 <term::write(char)>
  10255f:	83 c4 04             	add    esp,0x4
  102562:	6a 0a                	push   0xa
  102564:	e8 d7 eb ff ff       	call   101140 <term::write(char)>
  102569:	83 c4 04             	add    esp,0x4
  10256c:	6a 50                	push   0x50
  10256e:	e8 cd eb ff ff       	call   101140 <term::write(char)>
  102573:	83 c4 04             	add    esp,0x4
  102576:	6a 53                	push   0x53
  102578:	e8 c3 eb ff ff       	call   101140 <term::write(char)>
  10257d:	83 c4 04             	add    esp,0x4
  102580:	6a 2f                	push   0x2f
  102582:	e8 b9 eb ff ff       	call   101140 <term::write(char)>
  102587:	83 c4 04             	add    esp,0x4
  10258a:	6a 32                	push   0x32
  10258c:	e8 af eb ff ff       	call   101140 <term::write(char)>
  102591:	83 c4 04             	add    esp,0x4
  102594:	6a 3a                	push   0x3a
  102596:	e8 a5 eb ff ff       	call   101140 <term::write(char)>
  10259b:	83 c4 04             	add    esp,0x4
  10259e:	6a 20                	push   0x20
  1025a0:	e8 9b eb ff ff       	call   101140 <term::write(char)>
  1025a5:	83 c4 04             	add    esp,0x4
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1025a8:	66 ba 64 00          	mov    dx,0x64
  1025ac:	b0 ad                	mov    al,0xad
  1025ae:	ee                   	out    dx,al
  1025af:	66 ba 64 00          	mov    dx,0x64
  1025b3:	b0 a7                	mov    al,0xa7
  1025b5:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1025b6:	66 ba 64 00          	mov    dx,0x64
  1025ba:	ec                   	in     al,dx
bool has_output_data() { return (status() & 0b00000001) != 0; }
  1025bb:	a8 01                	test   al,0x1
  1025bd:	8d 9c 24 f8 00 00 00 	lea    ebx,[esp+0xf8]
    while (has_output_data())
  1025c4:	74 18                	je     1025de <kernel_main+0xa2e>
  1025c6:	90                   	nop
  1025c7:	90                   	nop
  1025c8:	90                   	nop
  1025c9:	90                   	nop
  1025ca:	90                   	nop
  1025cb:	90                   	nop
  1025cc:	90                   	nop
  1025cd:	90                   	nop
  1025ce:	90                   	nop
  1025cf:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1025d0:	66 ba 60 00          	mov    dx,0x60
  1025d4:	ec                   	in     al,dx
  1025d5:	66 ba 64 00          	mov    dx,0x64
  1025d9:	ec                   	in     al,dx
    while (has_output_data())
  1025da:	a8 01                	test   al,0x1
  1025dc:	75 f2                	jne    1025d0 <kernel_main+0xa20>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1025de:	66 ba 64 00          	mov    dx,0x64
  1025e2:	b0 20                	mov    al,0x20
  1025e4:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1025e5:	66 ba 60 00          	mov    dx,0x60
  1025e9:	ec                   	in     al,dx
  1025ea:	89 c1                	mov    ecx,eax
    cb &= 0b10111100; // disable interrupts and translation
  1025ec:	80 e1 bc             	and    cl,0xbc
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1025ef:	66 ba 64 00          	mov    dx,0x64
  1025f3:	b0 60                	mov    al,0x60
  1025f5:	ee                   	out    dx,al
  1025f6:	66 ba 60 00          	mov    dx,0x60
  1025fa:	89 c8                	mov    eax,ecx
  1025fc:	ee                   	out    dx,al
  1025fd:	66 ba 64 00          	mov    dx,0x64
  102601:	b0 aa                	mov    al,0xaa
  102603:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  102604:	66 ba 60 00          	mov    dx,0x60
  102608:	ec                   	in     al,dx
    return receive(DATA) == 0x55;
  102609:	3c 55                	cmp    al,0x55
    if (!(ps2::test_controller() && ps2::test_port_1()))
  10260b:	0f 85 d1 0c 00 00    	jne    1032e2 <kernel_main+0x1732>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  102611:	66 ba 64 00          	mov    dx,0x64
  102615:	b0 ab                	mov    al,0xab
  102617:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  102618:	66 ba 60 00          	mov    dx,0x60
  10261c:	ec                   	in     al,dx
    return receive(DATA) == 0x00;
  10261d:	84 c0                	test   al,al
    if (!(ps2::test_controller() && ps2::test_port_1()))
  10261f:	0f 85 bd 0c 00 00    	jne    1032e2 <kernel_main+0x1732>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  102625:	66 ba 64 00          	mov    dx,0x64
  102629:	b0 ae                	mov    al,0xae
  10262b:	ee                   	out    dx,al
  10262c:	66 ba 60 00          	mov    dx,0x60
  102630:	b0 ff                	mov    al,0xff
  102632:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  102633:	66 ba 60 00          	mov    dx,0x60
  102637:	ec                   	in     al,dx
  102638:	66 ba 60 00          	mov    dx,0x60
  10263c:	ec                   	in     al,dx
    return receive(DATA) == 0xAA;
  10263d:	3c aa                	cmp    al,0xaa
    if (!ps2::reset_1())
  10263f:	0f 85 9d 0c 00 00    	jne    1032e2 <kernel_main+0x1732>
  102645:	6a 4f                	push   0x4f
  102647:	e8 f4 ea ff ff       	call   101140 <term::write(char)>
  10264c:	83 c4 04             	add    esp,0x4
  10264f:	6a 4b                	push   0x4b
  102651:	e8 ea ea ff ff       	call   101140 <term::write(char)>
  102656:	83 c4 04             	add    esp,0x4
  102659:	6a 0a                	push   0xa
  10265b:	e8 e0 ea ff ff       	call   101140 <term::write(char)>
  102660:	83 c4 04             	add    esp,0x4
  102663:	eb 0b                	jmp    102670 <kernel_main+0xac0>
        return p[length()] == 0;
  102665:	85 c0                	test   eax,eax
            }
            term::Term.flipped = false;
            term::Term.wrap = false;
            term::Term.set_colour(term::WHITE);
        }
        if (command == "coredump") {
  102667:	0f 84 23 04 00 00    	je     102a90 <kernel_main+0xee0>
  10266d:	90                   	nop
  10266e:	90                   	nop
  10266f:	90                   	nop
  102670:	6a 3e                	push   0x3e
  102672:	e8 c9 ea ff ff       	call   101140 <term::write(char)>
  102677:	83 c4 04             	add    esp,0x4
  10267a:	6a 20                	push   0x20
  10267c:	e8 bf ea ff ff       	call   101140 <term::write(char)>
  102681:	83 c4 04             	add    esp,0x4
  102684:	6a 20                	push   0x20
  102686:	e8 b5 ea ff ff       	call   101140 <term::write(char)>
  10268b:	83 c4 04             	add    esp,0x4
    int index_ = 0;
  10268e:	68 bc 09 00 00       	push   0x9bc
  102693:	6a 00                	push   0x0
  102695:	8d 84 24 08 03 00 00 	lea    eax,[esp+0x308]
  10269c:	50                   	push   eax
  10269d:	e8 de eb ff ff       	call   101280 <memset>
  1026a2:	83 c4 0c             	add    esp,0xc
    array<uint32, N> mt; /* the array for the state vector  */
    uint32 mti = N + 1;  /* mti==N+1 means mt[N] is not initialized */

  public:
    random_gen(uint32 seed = 5489) {
        mt[0] = seed & static_cast<uint32>(~0);
  1026a5:	c7 84 24 f8 02 00 00 	mov    DWORD PTR [esp+0x2f8],0x1571
  1026ac:	71 15 00 00 
        for (mti = 1; mti < N; mti++) {
            mt[mti] =
  1026b0:	c7 84 24 fc 02 00 00 	mov    DWORD PTR [esp+0x2fc],0x4d98ee96
  1026b7:	96 ee 98 4d 
  1026bb:	c7 84 24 00 03 00 00 	mov    DWORD PTR [esp+0x300],0xaf25f095
  1026c2:	95 f0 25 af 
  1026c6:	c7 84 24 bc 0c 00 00 	mov    DWORD PTR [esp+0xcbc],0x3
  1026cd:	03 00 00 00 
  1026d1:	b9 02 00 00 00       	mov    ecx,0x2
  1026d6:	b8 03 00 00 00       	mov    eax,0x3
  1026db:	90                   	nop
  1026dc:	90                   	nop
  1026dd:	90                   	nop
  1026de:	90                   	nop
  1026df:	90                   	nop
                (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
  1026e0:	8b 8c 8c f8 02 00 00 	mov    ecx,DWORD PTR [esp+ecx*4+0x2f8]
  1026e7:	89 ca                	mov    edx,ecx
  1026e9:	c1 ea 1e             	shr    edx,0x1e
  1026ec:	31 ca                	xor    edx,ecx
  1026ee:	69 ca 65 89 07 6c    	imul   ecx,edx,0x6c078965
  1026f4:	01 c1                	add    ecx,eax
            mt[mti] =
  1026f6:	89 8c 84 f8 02 00 00 	mov    DWORD PTR [esp+eax*4+0x2f8],ecx
            mt[mti] &= static_cast<uint32>(~0);
  1026fd:	8b 8c 24 bc 0c 00 00 	mov    ecx,DWORD PTR [esp+0xcbc]
        for (mti = 1; mti < N; mti++) {
  102704:	8d 41 01             	lea    eax,[ecx+0x1]
  102707:	89 84 24 bc 0c 00 00 	mov    DWORD PTR [esp+0xcbc],eax
  10270e:	3d 70 02 00 00       	cmp    eax,0x270
  102713:	72 cb                	jb     1026e0 <kernel_main+0xb30>
        auto&& line = kbd::get_line();
  102715:	6a 01                	push   0x1
  102717:	e8 04 f3 ff ff       	call   101a20 <kbd::get_line(bool)>
  10271c:	83 c4 04             	add    esp,0x4
  10271f:	31 f6                	xor    esi,esi
  102721:	31 c0                	xor    eax,eax
  102723:	b9 15 00 00 00       	mov    ecx,0x15
  102728:	89 df                	mov    edi,ebx
  10272a:	f3 ab                	rep stos DWORD PTR es:[edi],eax
  10272c:	b8 b0 ff ff ff       	mov    eax,0xffffffb0
  102731:	31 c9                	xor    ecx,ecx
            if (a == separator) {
  102733:	8a 90 d8 60 11 00    	mov    dl,BYTE PTR [eax+0x1160d8]
  102739:	80 fa 20             	cmp    dl,0x20
  10273c:	75 11                	jne    10274f <kernel_main+0xb9f>
  10273e:	90                   	nop
  10273f:	90                   	nop
                seps++;
  102740:	41                   	inc    ecx
        for (auto &a : this->data_) {
  102741:	40                   	inc    eax
  102742:	74 2c                	je     102770 <kernel_main+0xbc0>
            if (a == separator) {
  102744:	8a 90 d8 60 11 00    	mov    dl,BYTE PTR [eax+0x1160d8]
  10274a:	80 fa 20             	cmp    dl,0x20
  10274d:	74 f1                	je     102740 <kernel_main+0xb90>
            } else if (seps == num) {
  10274f:	85 c9                	test   ecx,ecx
  102751:	75 ee                	jne    102741 <kernel_main+0xb91>
                *r = a;
  102753:	88 94 34 f8 00 00 00 	mov    BYTE PTR [esp+esi*1+0xf8],dl
    constexpr auto operator++() { index_++; }
  10275a:	8b b4 24 48 01 00 00 	mov    esi,DWORD PTR [esp+0x148]
  102761:	46                   	inc    esi
  102762:	89 b4 24 48 01 00 00 	mov    DWORD PTR [esp+0x148],esi
  102769:	31 c9                	xor    ecx,ecx
        for (auto &a : this->data_) {
  10276b:	40                   	inc    eax
  10276c:	75 d6                	jne    102744 <kernel_main+0xb94>
  10276e:	90                   	nop
  10276f:	90                   	nop
        if (seps < num)
  102770:	85 c9                	test   ecx,ecx
  102772:	78 1c                	js     102790 <kernel_main+0xbe0>
        *r = 0;
  102774:	c6 84 34 f8 00 00 00 	mov    BYTE PTR [esp+esi*1+0xf8],0x0
  10277b:	00 
    return static_cast<remove_ref<T> &&>(t);
  10277c:	b9 15 00 00 00       	mov    ecx,0x15
  102781:	8d 7c 24 14          	lea    edi,[esp+0x14]
  102785:	89 de                	mov    esi,ebx
  102787:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  102789:	b2 01                	mov    dl,0x1
  10278b:	eb 12                	jmp    10279f <kernel_main+0xbef>
  10278d:	90                   	nop
  10278e:	90                   	nop
  10278f:	90                   	nop
  102790:	31 d2                	xor    edx,edx
    constexpr optional() : value() {}
  102792:	31 c0                	xor    eax,eax
  102794:	b9 15 00 00 00       	mov    ecx,0x15
  102799:	8d 7c 24 14          	lea    edi,[esp+0x14]
  10279d:	f3 ab                	rep stos DWORD PTR es:[edi],eax
    bool loaded_ = false;
  10279f:	88 54 24 10          	mov    BYTE PTR [esp+0x10],dl
    const char *err = "(Unknown error)";
  1027a3:	c7 44 24 68 5f 00 10 	mov    DWORD PTR [esp+0x68],0x10005f
  1027aa:	00 
  1027ab:	31 d2                	xor    edx,edx
    int index_ = 0;
  1027ad:	31 c0                	xor    eax,eax
  1027af:	b9 15 00 00 00       	mov    ecx,0x15
  1027b4:	89 df                	mov    edi,ebx
  1027b6:	f3 ab                	rep stos DWORD PTR es:[edi],eax
  1027b8:	b8 b0 ff ff ff       	mov    eax,0xffffffb0
  1027bd:	31 c9                	xor    ecx,ecx
            if (a == separator) {
  1027bf:	8a 98 d8 60 11 00    	mov    bl,BYTE PTR [eax+0x1160d8]
  1027c5:	80 fb 20             	cmp    bl,0x20
  1027c8:	75 15                	jne    1027df <kernel_main+0xc2f>
  1027ca:	90                   	nop
  1027cb:	90                   	nop
  1027cc:	90                   	nop
  1027cd:	90                   	nop
  1027ce:	90                   	nop
  1027cf:	90                   	nop
                seps++;
  1027d0:	41                   	inc    ecx
        for (auto &a : this->data_) {
  1027d1:	40                   	inc    eax
  1027d2:	74 2e                	je     102802 <kernel_main+0xc52>
            if (a == separator) {
  1027d4:	8a 98 d8 60 11 00    	mov    bl,BYTE PTR [eax+0x1160d8]
  1027da:	80 fb 20             	cmp    bl,0x20
  1027dd:	74 f1                	je     1027d0 <kernel_main+0xc20>
            } else if (seps == num) {
  1027df:	83 f9 01             	cmp    ecx,0x1
  1027e2:	75 ed                	jne    1027d1 <kernel_main+0xc21>
                *r = a;
  1027e4:	88 9c 14 f8 00 00 00 	mov    BYTE PTR [esp+edx*1+0xf8],bl
    constexpr auto operator++() { index_++; }
  1027eb:	8b 94 24 48 01 00 00 	mov    edx,DWORD PTR [esp+0x148]
  1027f2:	42                   	inc    edx
  1027f3:	89 94 24 48 01 00 00 	mov    DWORD PTR [esp+0x148],edx
  1027fa:	b9 01 00 00 00       	mov    ecx,0x1
        for (auto &a : this->data_) {
  1027ff:	40                   	inc    eax
  102800:	75 d2                	jne    1027d4 <kernel_main+0xc24>
        if (seps < num)
  102802:	85 c9                	test   ecx,ecx
  102804:	7e 2a                	jle    102830 <kernel_main+0xc80>
        *r = 0;
  102806:	c6 84 14 f8 00 00 00 	mov    BYTE PTR [esp+edx*1+0xf8],0x0
  10280d:	00 
    return static_cast<remove_ref<T> &&>(t);
  10280e:	b9 15 00 00 00       	mov    ecx,0x15
  102813:	8d 7c 24 74          	lea    edi,[esp+0x74]
  102817:	8d 9c 24 f8 00 00 00 	lea    ebx,[esp+0xf8]
  10281e:	89 de                	mov    esi,ebx
  102820:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  102822:	b2 01                	mov    dl,0x1
  102824:	eb 20                	jmp    102846 <kernel_main+0xc96>
  102826:	90                   	nop
  102827:	90                   	nop
  102828:	90                   	nop
  102829:	90                   	nop
  10282a:	90                   	nop
  10282b:	90                   	nop
  10282c:	90                   	nop
  10282d:	90                   	nop
  10282e:	90                   	nop
  10282f:	90                   	nop
  102830:	31 d2                	xor    edx,edx
    constexpr optional() : value() {}
  102832:	31 c0                	xor    eax,eax
  102834:	b9 15 00 00 00       	mov    ecx,0x15
  102839:	8d 7c 24 74          	lea    edi,[esp+0x74]
  10283d:	f3 ab                	rep stos DWORD PTR es:[edi],eax
  10283f:	8d 9c 24 f8 00 00 00 	lea    ebx,[esp+0xf8]
    bool loaded_ = false;
  102846:	88 54 24 70          	mov    BYTE PTR [esp+0x70],dl
    const char *err = "(Unknown error)";
  10284a:	c7 84 24 c8 00 00 00 	mov    DWORD PTR [esp+0xc8],0x10005f
  102851:	5f 00 10 00 
  102855:	31 c0                	xor    eax,eax
  102857:	8d bc 24 f8 02 00 00 	lea    edi,[esp+0x2f8]
  10285e:	90                   	nop
  10285f:	90                   	nop
  102860:	31 c9                	xor    ecx,ecx
  102862:	90                   	nop
  102863:	90                   	nop
  102864:	90                   	nop
  102865:	90                   	nop
  102866:	90                   	nop
  102867:	90                   	nop
  102868:	90                   	nop
  102869:	90                   	nop
  10286a:	90                   	nop
  10286b:	90                   	nop
  10286c:	90                   	nop
  10286d:	90                   	nop
  10286e:	90                   	nop
  10286f:	90                   	nop
            if (this->operator[](a) == 0)
  102870:	80 7c 0c 14 00       	cmp    BYTE PTR [esp+ecx*1+0x14],0x0
  102875:	74 0b                	je     102882 <kernel_main+0xcd2>
        for (uint32 a = 0; a < N; a++) {
  102877:	41                   	inc    ecx
  102878:	83 f9 50             	cmp    ecx,0x50
  10287b:	75 f3                	jne    102870 <kernel_main+0xcc0>
  10287d:	b9 50 00 00 00       	mov    ecx,0x50
        for (uint32 a = 0; a < length(); a++) {
  102882:	39 c8                	cmp    eax,ecx
  102884:	73 1a                	jae    1028a0 <kernel_main+0xcf0>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102886:	83 f8 04             	cmp    eax,0x4
  102889:	74 45                	je     1028d0 <kernel_main+0xd20>
  10288b:	8a 88 51 00 10 00    	mov    cl,BYTE PTR [eax+0x100051]
  102891:	3a 4c 04 14          	cmp    cl,BYTE PTR [esp+eax*1+0x14]
        for (uint32 a = 0; a < length(); a++) {
  102895:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102898:	74 c6                	je     102860 <kernel_main+0xcb0>
  10289a:	eb 34                	jmp    1028d0 <kernel_main+0xd20>
  10289c:	90                   	nop
  10289d:	90                   	nop
  10289e:	90                   	nop
  10289f:	90                   	nop
  1028a0:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  1028a5:	90                   	nop
  1028a6:	90                   	nop
  1028a7:	90                   	nop
  1028a8:	90                   	nop
  1028a9:	90                   	nop
  1028aa:	90                   	nop
  1028ab:	90                   	nop
  1028ac:	90                   	nop
  1028ad:	90                   	nop
  1028ae:	90                   	nop
  1028af:	90                   	nop
            if (this->operator[](a) == 0)
  1028b0:	80 7c 04 18 00       	cmp    BYTE PTR [esp+eax*1+0x18],0x0
  1028b5:	74 08                	je     1028bf <kernel_main+0xd0f>
        for (uint32 a = 0; a < N; a++) {
  1028b7:	40                   	inc    eax
  1028b8:	83 f8 4c             	cmp    eax,0x4c
  1028bb:	75 f3                	jne    1028b0 <kernel_main+0xd00>
  1028bd:	eb 11                	jmp    1028d0 <kernel_main+0xd20>
        return p[length()] == 0;
  1028bf:	85 c0                	test   eax,eax
        if (command == "exit") {
  1028c1:	0f 84 9f 09 00 00    	je     103266 <kernel_main+0x16b6>
  1028c7:	90                   	nop
  1028c8:	90                   	nop
  1028c9:	90                   	nop
  1028ca:	90                   	nop
  1028cb:	90                   	nop
  1028cc:	90                   	nop
  1028cd:	90                   	nop
  1028ce:	90                   	nop
  1028cf:	90                   	nop
  1028d0:	31 c0                	xor    eax,eax
  1028d2:	90                   	nop
  1028d3:	90                   	nop
  1028d4:	90                   	nop
  1028d5:	90                   	nop
  1028d6:	90                   	nop
  1028d7:	90                   	nop
  1028d8:	90                   	nop
  1028d9:	90                   	nop
  1028da:	90                   	nop
  1028db:	90                   	nop
  1028dc:	90                   	nop
  1028dd:	90                   	nop
  1028de:	90                   	nop
  1028df:	90                   	nop
  1028e0:	31 c9                	xor    ecx,ecx
  1028e2:	90                   	nop
  1028e3:	90                   	nop
  1028e4:	90                   	nop
  1028e5:	90                   	nop
  1028e6:	90                   	nop
  1028e7:	90                   	nop
  1028e8:	90                   	nop
  1028e9:	90                   	nop
  1028ea:	90                   	nop
  1028eb:	90                   	nop
  1028ec:	90                   	nop
  1028ed:	90                   	nop
  1028ee:	90                   	nop
  1028ef:	90                   	nop
            if (this->operator[](a) == 0)
  1028f0:	80 7c 0c 14 00       	cmp    BYTE PTR [esp+ecx*1+0x14],0x0
  1028f5:	74 0b                	je     102902 <kernel_main+0xd52>
        for (uint32 a = 0; a < N; a++) {
  1028f7:	41                   	inc    ecx
  1028f8:	83 f9 50             	cmp    ecx,0x50
  1028fb:	75 f3                	jne    1028f0 <kernel_main+0xd40>
  1028fd:	b9 50 00 00 00       	mov    ecx,0x50
        for (uint32 a = 0; a < length(); a++) {
  102902:	39 c8                	cmp    eax,ecx
  102904:	73 1a                	jae    102920 <kernel_main+0xd70>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102906:	83 f8 05             	cmp    eax,0x5
  102909:	74 45                	je     102950 <kernel_main+0xda0>
  10290b:	8a 88 e9 00 10 00    	mov    cl,BYTE PTR [eax+0x1000e9]
  102911:	3a 4c 04 14          	cmp    cl,BYTE PTR [esp+eax*1+0x14]
        for (uint32 a = 0; a < length(); a++) {
  102915:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102918:	74 c6                	je     1028e0 <kernel_main+0xd30>
  10291a:	eb 34                	jmp    102950 <kernel_main+0xda0>
  10291c:	90                   	nop
  10291d:	90                   	nop
  10291e:	90                   	nop
  10291f:	90                   	nop
  102920:	b8 fb ff ff ff       	mov    eax,0xfffffffb
  102925:	90                   	nop
  102926:	90                   	nop
  102927:	90                   	nop
  102928:	90                   	nop
  102929:	90                   	nop
  10292a:	90                   	nop
  10292b:	90                   	nop
  10292c:	90                   	nop
  10292d:	90                   	nop
  10292e:	90                   	nop
  10292f:	90                   	nop
            if (this->operator[](a) == 0)
  102930:	80 7c 04 19 00       	cmp    BYTE PTR [esp+eax*1+0x19],0x0
  102935:	74 08                	je     10293f <kernel_main+0xd8f>
        for (uint32 a = 0; a < N; a++) {
  102937:	40                   	inc    eax
  102938:	83 f8 4b             	cmp    eax,0x4b
  10293b:	75 f3                	jne    102930 <kernel_main+0xd80>
  10293d:	eb 11                	jmp    102950 <kernel_main+0xda0>
        return p[length()] == 0;
  10293f:	85 c0                	test   eax,eax
        if (command == "reset") {
  102941:	75 0d                	jne    102950 <kernel_main+0xda0>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  102943:	66 ba 64 00          	mov    dx,0x64
  102947:	b0 fe                	mov    al,0xfe
  102949:	ee                   	out    dx,al
  10294a:	90                   	nop
  10294b:	90                   	nop
  10294c:	90                   	nop
  10294d:	90                   	nop
  10294e:	90                   	nop
  10294f:	90                   	nop
  102950:	31 c0                	xor    eax,eax
  102952:	90                   	nop
  102953:	90                   	nop
  102954:	90                   	nop
  102955:	90                   	nop
  102956:	90                   	nop
  102957:	90                   	nop
  102958:	90                   	nop
  102959:	90                   	nop
  10295a:	90                   	nop
  10295b:	90                   	nop
  10295c:	90                   	nop
  10295d:	90                   	nop
  10295e:	90                   	nop
  10295f:	90                   	nop
  102960:	31 c9                	xor    ecx,ecx
  102962:	90                   	nop
  102963:	90                   	nop
  102964:	90                   	nop
  102965:	90                   	nop
  102966:	90                   	nop
  102967:	90                   	nop
  102968:	90                   	nop
  102969:	90                   	nop
  10296a:	90                   	nop
  10296b:	90                   	nop
  10296c:	90                   	nop
  10296d:	90                   	nop
  10296e:	90                   	nop
  10296f:	90                   	nop
            if (this->operator[](a) == 0)
  102970:	80 7c 0c 14 00       	cmp    BYTE PTR [esp+ecx*1+0x14],0x0
  102975:	74 0b                	je     102982 <kernel_main+0xdd2>
        for (uint32 a = 0; a < N; a++) {
  102977:	41                   	inc    ecx
  102978:	83 f9 50             	cmp    ecx,0x50
  10297b:	75 f3                	jne    102970 <kernel_main+0xdc0>
  10297d:	b9 50 00 00 00       	mov    ecx,0x50
        for (uint32 a = 0; a < length(); a++) {
  102982:	39 c8                	cmp    eax,ecx
  102984:	73 1a                	jae    1029a0 <kernel_main+0xdf0>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102986:	83 f8 05             	cmp    eax,0x5
  102989:	74 45                	je     1029d0 <kernel_main+0xe20>
  10298b:	8a 88 86 00 10 00    	mov    cl,BYTE PTR [eax+0x100086]
  102991:	3a 4c 04 14          	cmp    cl,BYTE PTR [esp+eax*1+0x14]
        for (uint32 a = 0; a < length(); a++) {
  102995:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102998:	74 c6                	je     102960 <kernel_main+0xdb0>
  10299a:	eb 34                	jmp    1029d0 <kernel_main+0xe20>
  10299c:	90                   	nop
  10299d:	90                   	nop
  10299e:	90                   	nop
  10299f:	90                   	nop
  1029a0:	b8 fb ff ff ff       	mov    eax,0xfffffffb
  1029a5:	90                   	nop
  1029a6:	90                   	nop
  1029a7:	90                   	nop
  1029a8:	90                   	nop
  1029a9:	90                   	nop
  1029aa:	90                   	nop
  1029ab:	90                   	nop
  1029ac:	90                   	nop
  1029ad:	90                   	nop
  1029ae:	90                   	nop
  1029af:	90                   	nop
            if (this->operator[](a) == 0)
  1029b0:	80 7c 04 19 00       	cmp    BYTE PTR [esp+eax*1+0x19],0x0
  1029b5:	74 08                	je     1029bf <kernel_main+0xe0f>
        for (uint32 a = 0; a < N; a++) {
  1029b7:	40                   	inc    eax
  1029b8:	83 f8 4b             	cmp    eax,0x4b
  1029bb:	75 f3                	jne    1029b0 <kernel_main+0xe00>
  1029bd:	eb 11                	jmp    1029d0 <kernel_main+0xe20>
        return p[length()] == 0;
  1029bf:	85 c0                	test   eax,eax
        if (command == "clear") {
  1029c1:	75 0d                	jne    1029d0 <kernel_main+0xe20>
            term::clear();
  1029c3:	e8 88 e6 ff ff       	call   101050 <term::clear()>
  1029c8:	90                   	nop
  1029c9:	90                   	nop
  1029ca:	90                   	nop
  1029cb:	90                   	nop
  1029cc:	90                   	nop
  1029cd:	90                   	nop
  1029ce:	90                   	nop
  1029cf:	90                   	nop
  1029d0:	31 c0                	xor    eax,eax
  1029d2:	90                   	nop
  1029d3:	90                   	nop
  1029d4:	90                   	nop
  1029d5:	90                   	nop
  1029d6:	90                   	nop
  1029d7:	90                   	nop
  1029d8:	90                   	nop
  1029d9:	90                   	nop
  1029da:	90                   	nop
  1029db:	90                   	nop
  1029dc:	90                   	nop
  1029dd:	90                   	nop
  1029de:	90                   	nop
  1029df:	90                   	nop
  1029e0:	31 c9                	xor    ecx,ecx
  1029e2:	90                   	nop
  1029e3:	90                   	nop
  1029e4:	90                   	nop
  1029e5:	90                   	nop
  1029e6:	90                   	nop
  1029e7:	90                   	nop
  1029e8:	90                   	nop
  1029e9:	90                   	nop
  1029ea:	90                   	nop
  1029eb:	90                   	nop
  1029ec:	90                   	nop
  1029ed:	90                   	nop
  1029ee:	90                   	nop
  1029ef:	90                   	nop
            if (this->operator[](a) == 0)
  1029f0:	80 7c 0c 14 00       	cmp    BYTE PTR [esp+ecx*1+0x14],0x0
  1029f5:	74 0b                	je     102a02 <kernel_main+0xe52>
        for (uint32 a = 0; a < N; a++) {
  1029f7:	41                   	inc    ecx
  1029f8:	83 f9 50             	cmp    ecx,0x50
  1029fb:	75 f3                	jne    1029f0 <kernel_main+0xe40>
  1029fd:	b9 50 00 00 00       	mov    ecx,0x50
        for (uint32 a = 0; a < length(); a++) {
  102a02:	39 c8                	cmp    eax,ecx
  102a04:	73 2a                	jae    102a30 <kernel_main+0xe80>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102a06:	83 f8 04             	cmp    eax,0x4
  102a09:	0f 84 51 02 00 00    	je     102c60 <kernel_main+0x10b0>
  102a0f:	8a 88 0c 00 10 00    	mov    cl,BYTE PTR [eax+0x10000c]
  102a15:	3a 4c 04 14          	cmp    cl,BYTE PTR [esp+eax*1+0x14]
        for (uint32 a = 0; a < length(); a++) {
  102a19:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102a1c:	74 c2                	je     1029e0 <kernel_main+0xe30>
  102a1e:	e9 3d 02 00 00       	jmp    102c60 <kernel_main+0x10b0>
  102a23:	90                   	nop
  102a24:	90                   	nop
  102a25:	90                   	nop
  102a26:	90                   	nop
  102a27:	90                   	nop
  102a28:	90                   	nop
  102a29:	90                   	nop
  102a2a:	90                   	nop
  102a2b:	90                   	nop
  102a2c:	90                   	nop
  102a2d:	90                   	nop
  102a2e:	90                   	nop
  102a2f:	90                   	nop
  102a30:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  102a35:	90                   	nop
  102a36:	90                   	nop
  102a37:	90                   	nop
  102a38:	90                   	nop
  102a39:	90                   	nop
  102a3a:	90                   	nop
  102a3b:	90                   	nop
  102a3c:	90                   	nop
  102a3d:	90                   	nop
  102a3e:	90                   	nop
  102a3f:	90                   	nop
            if (this->operator[](a) == 0)
  102a40:	80 7c 04 18 00       	cmp    BYTE PTR [esp+eax*1+0x18],0x0
  102a45:	74 0b                	je     102a52 <kernel_main+0xea2>
        for (uint32 a = 0; a < N; a++) {
  102a47:	40                   	inc    eax
  102a48:	83 f8 4c             	cmp    eax,0x4c
  102a4b:	75 f3                	jne    102a40 <kernel_main+0xe90>
  102a4d:	e9 0e 02 00 00       	jmp    102c60 <kernel_main+0x10b0>
        return p[length()] == 0;
  102a52:	85 c0                	test   eax,eax
        if (command == "read") {
  102a54:	0f 85 06 02 00 00    	jne    102c60 <kernel_main+0x10b0>
  102a5a:	31 c0                	xor    eax,eax
  102a5c:	90                   	nop
  102a5d:	90                   	nop
  102a5e:	90                   	nop
  102a5f:	90                   	nop
            if (this->operator[](a) == 0)
  102a60:	80 7c 04 74 00       	cmp    BYTE PTR [esp+eax*1+0x74],0x0
  102a65:	74 0b                	je     102a72 <kernel_main+0xec2>
        for (uint32 a = 0; a < N; a++) {
  102a67:	40                   	inc    eax
  102a68:	83 f8 50             	cmp    eax,0x50
  102a6b:	75 f3                	jne    102a60 <kernel_main+0xeb0>
  102a6d:	b8 50 00 00 00       	mov    eax,0x50
    constexpr auto end() const { return this->data_ + length(); }
  102a72:	8d 4c 04 74          	lea    ecx,[esp+eax*1+0x74]
  102a76:	8d 54 24 74          	lea    edx,[esp+0x74]
    for (auto c : p) {
  102a7a:	39 ca                	cmp    edx,ecx
  102a7c:	74 55                	je     102ad3 <kernel_main+0xf23>
  102a7e:	31 c9                	xor    ecx,ecx
  102a80:	0f be 32             	movsx  esi,BYTE PTR [edx]
        r *= B;
  102a83:	c1 e1 04             	shl    ecx,0x4
        r += static_cast<int>(c - '0');
  102a86:	8d 4c 31 d0          	lea    ecx,[ecx+esi*1-0x30]
    for (auto c : p) {
  102a8a:	42                   	inc    edx
  102a8b:	48                   	dec    eax
  102a8c:	75 f2                	jne    102a80 <kernel_main+0xed0>
  102a8e:	eb 45                	jmp    102ad5 <kernel_main+0xf25>
  102a90:	31 f6                	xor    esi,esi
  102a92:	90                   	nop
  102a93:	90                   	nop
  102a94:	90                   	nop
  102a95:	90                   	nop
  102a96:	90                   	nop
  102a97:	90                   	nop
  102a98:	90                   	nop
  102a99:	90                   	nop
  102a9a:	90                   	nop
  102a9b:	90                   	nop
  102a9c:	90                   	nop
  102a9d:	90                   	nop
  102a9e:	90                   	nop
  102a9f:	90                   	nop
            for (auto a : range<0, (term::ROWS + 2) * term::COLS>) {
                term::write(char('$' + (rnd.next(40))));
  102aa0:	6a 28                	push   0x28
  102aa2:	57                   	push   edi
  102aa3:	e8 78 10 00 00       	call   103b20 <rand::random_gen::next(unsigned int)>
  102aa8:	83 c4 08             	add    esp,0x8
  102aab:	04 24                	add    al,0x24
  102aad:	0f be c0             	movsx  eax,al
  102ab0:	50                   	push   eax
  102ab1:	e8 8a e6 ff ff       	call   101140 <term::write(char)>
  102ab6:	83 c4 04             	add    esp,0x4
  102ab9:	b8 00 00 14 00       	mov    eax,0x140000
  102abe:	90                   	nop
  102abf:	90                   	nop
        asm volatile ("and %eax,%eax");
  102ac0:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  102ac2:	48                   	dec    eax
  102ac3:	75 fb                	jne    102ac0 <kernel_main+0xf10>
            value++;
  102ac5:	46                   	inc    esi
            return value != p.value;
  102ac6:	81 fe 70 08 00 00    	cmp    esi,0x870
  102acc:	75 d2                	jne    102aa0 <kernel_main+0xef0>
  102ace:	e9 9d fb ff ff       	jmp    102670 <kernel_main+0xac0>
  102ad3:	31 c9                	xor    ecx,ecx
            term::write("-> 0x", int_to_string<16>(*address).str(), "\n");
  102ad5:	8b 11                	mov    edx,DWORD PTR [ecx]
    constexpr array() : data_{T()} {}
  102ad7:	66 c7 84 24 14 01 00 	mov    WORD PTR [esp+0x114],0x0
  102ade:	00 00 00 
  102ae1:	c7 84 24 10 01 00 00 	mov    DWORD PTR [esp+0x110],0x0
  102ae8:	00 00 00 00 
  102aec:	c7 84 24 0c 01 00 00 	mov    DWORD PTR [esp+0x10c],0x0
  102af3:	00 00 00 00 
  102af7:	c7 84 24 08 01 00 00 	mov    DWORD PTR [esp+0x108],0x0
  102afe:	00 00 00 00 
  102b02:	c7 84 24 04 01 00 00 	mov    DWORD PTR [esp+0x104],0x0
  102b09:	00 00 00 00 
  102b0d:	c7 84 24 00 01 00 00 	mov    DWORD PTR [esp+0x100],0x0
  102b14:	00 00 00 00 
  102b18:	c7 84 24 fc 00 00 00 	mov    DWORD PTR [esp+0xfc],0x0
  102b1f:	00 00 00 00 
  102b23:	c7 84 24 f8 00 00 00 	mov    DWORD PTR [esp+0xf8],0x0
  102b2a:	00 00 00 00 
    int index_ = 0;
  102b2e:	c7 84 24 18 01 00 00 	mov    DWORD PTR [esp+0x118],0x0
  102b35:	00 00 00 00 
    if (x == 0)
  102b39:	85 d2                	test   edx,edx
  102b3b:	0f 84 83 00 00 00    	je     102bc4 <kernel_main+0x1014>
  102b41:	31 f6                	xor    esi,esi
  102b43:	bf 01 00 00 00       	mov    edi,0x1
  102b48:	89 d8                	mov    eax,ebx
  102b4a:	90                   	nop
  102b4b:	90                   	nop
  102b4c:	90                   	nop
  102b4d:	90                   	nop
  102b4e:	90                   	nop
  102b4f:	90                   	nop
  102b50:	89 c1                	mov    ecx,eax
        if ((x % B) < 10)
  102b52:	89 d0                	mov    eax,edx
  102b54:	83 e0 0f             	and    eax,0xf
  102b57:	89 c3                	mov    ebx,eax
  102b59:	80 cb 30             	or     bl,0x30
  102b5c:	88 d7                	mov    bh,dl
  102b5e:	80 c7 06             	add    bh,0x6
  102b61:	80 e7 0f             	and    bh,0xf
  102b64:	80 c7 41             	add    bh,0x41
  102b67:	83 f8 0a             	cmp    eax,0xa
  102b6a:	0f b6 c3             	movzx  eax,bl
  102b6d:	0f b6 df             	movzx  ebx,bh
  102b70:	0f 42 d8             	cmovb  ebx,eax
        r[a] = i2c(x);
  102b73:	88 9c 34 f8 00 00 00 	mov    BYTE PTR [esp+esi*1+0xf8],bl
        x /= B;
  102b7a:	c1 ea 04             	shr    edx,0x4
    for (; x > 0; a++) {
  102b7d:	46                   	inc    esi
  102b7e:	89 3c 24             	mov    DWORD PTR [esp],edi
  102b81:	47                   	inc    edi
  102b82:	8d 41 01             	lea    eax,[ecx+0x1]
  102b85:	85 d2                	test   edx,edx
  102b87:	75 c7                	jne    102b50 <kernel_main+0xfa0>
    r[a] = 0;
  102b89:	c6 84 34 f8 00 00 00 	mov    BYTE PTR [esp+esi*1+0xf8],0x0
  102b90:	00 
    for (auto b = 0; b < a / 2; b++) {
  102b91:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  102b97:	8d 9c 24 f8 00 00 00 	lea    ebx,[esp+0xf8]
  102b9e:	8b 34 24             	mov    esi,DWORD PTR [esp]
  102ba1:	74 2b                	je     102bce <kernel_main+0x101e>
  102ba3:	d1 ee                	shr    esi,1
  102ba5:	89 da                	mov    edx,ebx
  102ba7:	90                   	nop
  102ba8:	90                   	nop
  102ba9:	90                   	nop
  102baa:	90                   	nop
  102bab:	90                   	nop
  102bac:	90                   	nop
  102bad:	90                   	nop
  102bae:	90                   	nop
  102baf:	90                   	nop
        r[b] ^= r[a - b - 1];
  102bb0:	0f b6 02             	movzx  eax,BYTE PTR [edx]
  102bb3:	32 01                	xor    al,BYTE PTR [ecx]
  102bb5:	88 02                	mov    BYTE PTR [edx],al
        r[a - b - 1] ^= r[b];
  102bb7:	32 01                	xor    al,BYTE PTR [ecx]
  102bb9:	88 01                	mov    BYTE PTR [ecx],al
        r[b] ^= r[a - b - 1];
  102bbb:	30 02                	xor    BYTE PTR [edx],al
    for (auto b = 0; b < a / 2; b++) {
  102bbd:	42                   	inc    edx
  102bbe:	49                   	dec    ecx
  102bbf:	4e                   	dec    esi
  102bc0:	75 ee                	jne    102bb0 <kernel_main+0x1000>
  102bc2:	eb 0a                	jmp    102bce <kernel_main+0x101e>
        r[a++] = '0';
  102bc4:	66 c7 84 24 f8 00 00 	mov    WORD PTR [esp+0xf8],0x30
  102bcb:	00 30 00 
    return r;
  102bce:	b9 09 00 00 00       	mov    ecx,0x9
  102bd3:	8d bc 24 d0 00 00 00 	lea    edi,[esp+0xd0]
  102bda:	89 de                	mov    esi,ebx
  102bdc:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  102bde:	6a 2d                	push   0x2d
  102be0:	e8 5b e5 ff ff       	call   101140 <term::write(char)>
  102be5:	83 c4 04             	add    esp,0x4
  102be8:	6a 3e                	push   0x3e
  102bea:	e8 51 e5 ff ff       	call   101140 <term::write(char)>
  102bef:	83 c4 04             	add    esp,0x4
  102bf2:	6a 20                	push   0x20
  102bf4:	e8 47 e5 ff ff       	call   101140 <term::write(char)>
  102bf9:	83 c4 04             	add    esp,0x4
  102bfc:	6a 30                	push   0x30
  102bfe:	e8 3d e5 ff ff       	call   101140 <term::write(char)>
  102c03:	83 c4 04             	add    esp,0x4
  102c06:	6a 78                	push   0x78
  102c08:	e8 33 e5 ff ff       	call   101140 <term::write(char)>
  102c0d:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102c10:	8a 84 24 d0 00 00 00 	mov    al,BYTE PTR [esp+0xd0]
  102c17:	84 c0                	test   al,al
  102c19:	74 29                	je     102c44 <kernel_main+0x1094>
  102c1b:	8d b4 24 d1 00 00 00 	lea    esi,[esp+0xd1]
  102c22:	90                   	nop
  102c23:	90                   	nop
  102c24:	90                   	nop
  102c25:	90                   	nop
  102c26:	90                   	nop
  102c27:	90                   	nop
  102c28:	90                   	nop
  102c29:	90                   	nop
  102c2a:	90                   	nop
  102c2b:	90                   	nop
  102c2c:	90                   	nop
  102c2d:	90                   	nop
  102c2e:	90                   	nop
  102c2f:	90                   	nop
        write(s[a]);
  102c30:	0f be c0             	movsx  eax,al
  102c33:	50                   	push   eax
  102c34:	e8 07 e5 ff ff       	call   101140 <term::write(char)>
  102c39:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102c3c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  102c3f:	46                   	inc    esi
  102c40:	84 c0                	test   al,al
  102c42:	75 ec                	jne    102c30 <kernel_main+0x1080>
        write(s[a]);
  102c44:	6a 0a                	push   0xa
  102c46:	e8 f5 e4 ff ff       	call   101140 <term::write(char)>
  102c4b:	83 c4 04             	add    esp,0x4
  102c4e:	8d bc 24 f8 02 00 00 	lea    edi,[esp+0x2f8]
  102c55:	90                   	nop
  102c56:	90                   	nop
  102c57:	90                   	nop
  102c58:	90                   	nop
  102c59:	90                   	nop
  102c5a:	90                   	nop
  102c5b:	90                   	nop
  102c5c:	90                   	nop
  102c5d:	90                   	nop
  102c5e:	90                   	nop
  102c5f:	90                   	nop
  102c60:	31 c0                	xor    eax,eax
  102c62:	90                   	nop
  102c63:	90                   	nop
  102c64:	90                   	nop
  102c65:	90                   	nop
  102c66:	90                   	nop
  102c67:	90                   	nop
  102c68:	90                   	nop
  102c69:	90                   	nop
  102c6a:	90                   	nop
  102c6b:	90                   	nop
  102c6c:	90                   	nop
  102c6d:	90                   	nop
  102c6e:	90                   	nop
  102c6f:	90                   	nop
  102c70:	31 c9                	xor    ecx,ecx
  102c72:	90                   	nop
  102c73:	90                   	nop
  102c74:	90                   	nop
  102c75:	90                   	nop
  102c76:	90                   	nop
  102c77:	90                   	nop
  102c78:	90                   	nop
  102c79:	90                   	nop
  102c7a:	90                   	nop
  102c7b:	90                   	nop
  102c7c:	90                   	nop
  102c7d:	90                   	nop
  102c7e:	90                   	nop
  102c7f:	90                   	nop
            if (this->operator[](a) == 0)
  102c80:	80 7c 0c 14 00       	cmp    BYTE PTR [esp+ecx*1+0x14],0x0
  102c85:	74 0b                	je     102c92 <kernel_main+0x10e2>
        for (uint32 a = 0; a < N; a++) {
  102c87:	41                   	inc    ecx
  102c88:	83 f9 50             	cmp    ecx,0x50
  102c8b:	75 f3                	jne    102c80 <kernel_main+0x10d0>
  102c8d:	b9 50 00 00 00       	mov    ecx,0x50
        for (uint32 a = 0; a < length(); a++) {
  102c92:	39 c8                	cmp    eax,ecx
  102c94:	73 1a                	jae    102cb0 <kernel_main+0x1100>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102c96:	83 f8 04             	cmp    eax,0x4
  102c99:	74 45                	je     102ce0 <kernel_main+0x1130>
  102c9b:	8a 88 8c 00 10 00    	mov    cl,BYTE PTR [eax+0x10008c]
  102ca1:	3a 4c 04 14          	cmp    cl,BYTE PTR [esp+eax*1+0x14]
        for (uint32 a = 0; a < length(); a++) {
  102ca5:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102ca8:	74 c6                	je     102c70 <kernel_main+0x10c0>
  102caa:	eb 34                	jmp    102ce0 <kernel_main+0x1130>
  102cac:	90                   	nop
  102cad:	90                   	nop
  102cae:	90                   	nop
  102caf:	90                   	nop
  102cb0:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  102cb5:	90                   	nop
  102cb6:	90                   	nop
  102cb7:	90                   	nop
  102cb8:	90                   	nop
  102cb9:	90                   	nop
  102cba:	90                   	nop
  102cbb:	90                   	nop
  102cbc:	90                   	nop
  102cbd:	90                   	nop
  102cbe:	90                   	nop
  102cbf:	90                   	nop
            if (this->operator[](a) == 0)
  102cc0:	80 7c 04 18 00       	cmp    BYTE PTR [esp+eax*1+0x18],0x0
  102cc5:	74 08                	je     102ccf <kernel_main+0x111f>
        for (uint32 a = 0; a < N; a++) {
  102cc7:	40                   	inc    eax
  102cc8:	83 f8 4c             	cmp    eax,0x4c
  102ccb:	75 f3                	jne    102cc0 <kernel_main+0x1110>
  102ccd:	eb 11                	jmp    102ce0 <kernel_main+0x1130>
        return p[length()] == 0;
  102ccf:	85 c0                	test   eax,eax
        if (command == "flip") {
  102cd1:	75 0d                	jne    102ce0 <kernel_main+0x1130>
            term::Term.flipped = !term::Term.flipped;
  102cd3:	80 35 0d 50 10 00 01 	xor    BYTE PTR ds:0x10500d,0x1
  102cda:	90                   	nop
  102cdb:	90                   	nop
  102cdc:	90                   	nop
  102cdd:	90                   	nop
  102cde:	90                   	nop
  102cdf:	90                   	nop
  102ce0:	31 c0                	xor    eax,eax
  102ce2:	90                   	nop
  102ce3:	90                   	nop
  102ce4:	90                   	nop
  102ce5:	90                   	nop
  102ce6:	90                   	nop
  102ce7:	90                   	nop
  102ce8:	90                   	nop
  102ce9:	90                   	nop
  102cea:	90                   	nop
  102ceb:	90                   	nop
  102cec:	90                   	nop
  102ced:	90                   	nop
  102cee:	90                   	nop
  102cef:	90                   	nop
  102cf0:	31 c9                	xor    ecx,ecx
  102cf2:	90                   	nop
  102cf3:	90                   	nop
  102cf4:	90                   	nop
  102cf5:	90                   	nop
  102cf6:	90                   	nop
  102cf7:	90                   	nop
  102cf8:	90                   	nop
  102cf9:	90                   	nop
  102cfa:	90                   	nop
  102cfb:	90                   	nop
  102cfc:	90                   	nop
  102cfd:	90                   	nop
  102cfe:	90                   	nop
  102cff:	90                   	nop
            if (this->operator[](a) == 0)
  102d00:	80 7c 0c 14 00       	cmp    BYTE PTR [esp+ecx*1+0x14],0x0
  102d05:	74 0b                	je     102d12 <kernel_main+0x1162>
        for (uint32 a = 0; a < N; a++) {
  102d07:	41                   	inc    ecx
  102d08:	83 f9 50             	cmp    ecx,0x50
  102d0b:	75 f3                	jne    102d00 <kernel_main+0x1150>
  102d0d:	b9 50 00 00 00       	mov    ecx,0x50
        for (uint32 a = 0; a < length(); a++) {
  102d12:	39 c8                	cmp    eax,ecx
  102d14:	73 2a                	jae    102d40 <kernel_main+0x1190>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102d16:	83 f8 04             	cmp    eax,0x4
  102d19:	0f 84 41 01 00 00    	je     102e60 <kernel_main+0x12b0>
  102d1f:	8a 88 e4 00 10 00    	mov    cl,BYTE PTR [eax+0x1000e4]
  102d25:	3a 4c 04 14          	cmp    cl,BYTE PTR [esp+eax*1+0x14]
        for (uint32 a = 0; a < length(); a++) {
  102d29:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102d2c:	74 c2                	je     102cf0 <kernel_main+0x1140>
  102d2e:	e9 2d 01 00 00       	jmp    102e60 <kernel_main+0x12b0>
  102d33:	90                   	nop
  102d34:	90                   	nop
  102d35:	90                   	nop
  102d36:	90                   	nop
  102d37:	90                   	nop
  102d38:	90                   	nop
  102d39:	90                   	nop
  102d3a:	90                   	nop
  102d3b:	90                   	nop
  102d3c:	90                   	nop
  102d3d:	90                   	nop
  102d3e:	90                   	nop
  102d3f:	90                   	nop
  102d40:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  102d45:	90                   	nop
  102d46:	90                   	nop
  102d47:	90                   	nop
  102d48:	90                   	nop
  102d49:	90                   	nop
  102d4a:	90                   	nop
  102d4b:	90                   	nop
  102d4c:	90                   	nop
  102d4d:	90                   	nop
  102d4e:	90                   	nop
  102d4f:	90                   	nop
            if (this->operator[](a) == 0)
  102d50:	80 7c 04 18 00       	cmp    BYTE PTR [esp+eax*1+0x18],0x0
  102d55:	74 0b                	je     102d62 <kernel_main+0x11b2>
        for (uint32 a = 0; a < N; a++) {
  102d57:	40                   	inc    eax
  102d58:	83 f8 4c             	cmp    eax,0x4c
  102d5b:	75 f3                	jne    102d50 <kernel_main+0x11a0>
  102d5d:	e9 fe 00 00 00       	jmp    102e60 <kernel_main+0x12b0>
        return p[length()] == 0;
  102d62:	85 c0                	test   eax,eax
        if (command == "stoi") {
  102d64:	0f 85 f6 00 00 00    	jne    102e60 <kernel_main+0x12b0>
  102d6a:	31 c0                	xor    eax,eax
  102d6c:	90                   	nop
  102d6d:	90                   	nop
  102d6e:	90                   	nop
  102d6f:	90                   	nop
            if (this->operator[](a) == 0)
  102d70:	80 7c 04 74 00       	cmp    BYTE PTR [esp+eax*1+0x74],0x0
  102d75:	74 08                	je     102d7f <kernel_main+0x11cf>
        for (uint32 a = 0; a < N; a++) {
  102d77:	40                   	inc    eax
  102d78:	83 f8 50             	cmp    eax,0x50
  102d7b:	75 f3                	jne    102d70 <kernel_main+0x11c0>
  102d7d:	eb 04                	jmp    102d83 <kernel_main+0x11d3>
        for (uint32 a = 0; a < length(); a++) {
  102d7f:	85 c0                	test   eax,eax
  102d81:	74 64                	je     102de7 <kernel_main+0x1237>
  102d83:	6a 6e                	push   0x6e
  102d85:	e8 b6 e3 ff ff       	call   101140 <term::write(char)>
  102d8a:	83 c4 04             	add    esp,0x4
  102d8d:	6a 6f                	push   0x6f
  102d8f:	e8 ac e3 ff ff       	call   101140 <term::write(char)>
  102d94:	83 c4 04             	add    esp,0x4
  102d97:	6a 6e                	push   0x6e
  102d99:	e8 a2 e3 ff ff       	call   101140 <term::write(char)>
  102d9e:	83 c4 04             	add    esp,0x4
  102da1:	6a 2d                	push   0x2d
  102da3:	e8 98 e3 ff ff       	call   101140 <term::write(char)>
  102da8:	83 c4 04             	add    esp,0x4
  102dab:	6a 65                	push   0x65
  102dad:	e8 8e e3 ff ff       	call   101140 <term::write(char)>
  102db2:	83 c4 04             	add    esp,0x4
  102db5:	6a 6d                	push   0x6d
  102db7:	e8 84 e3 ff ff       	call   101140 <term::write(char)>
  102dbc:	83 c4 04             	add    esp,0x4
  102dbf:	6a 70                	push   0x70
  102dc1:	e8 7a e3 ff ff       	call   101140 <term::write(char)>
  102dc6:	83 c4 04             	add    esp,0x4
  102dc9:	6a 74                	push   0x74
  102dcb:	e8 70 e3 ff ff       	call   101140 <term::write(char)>
  102dd0:	83 c4 04             	add    esp,0x4
  102dd3:	6a 79                	push   0x79
  102dd5:	e8 66 e3 ff ff       	call   101140 <term::write(char)>
  102dda:	83 c4 04             	add    esp,0x4
  102ddd:	6a 20                	push   0x20
  102ddf:	e8 5c e3 ff ff       	call   101140 <term::write(char)>
  102de4:	83 c4 04             	add    esp,0x4
  102de7:	6a 4f                	push   0x4f
  102de9:	e8 52 e3 ff ff       	call   101140 <term::write(char)>
  102dee:	83 c4 04             	add    esp,0x4
  102df1:	6a 4b                	push   0x4b
  102df3:	e8 48 e3 ff ff       	call   101140 <term::write(char)>
  102df8:	83 c4 04             	add    esp,0x4
  102dfb:	6a 3a                	push   0x3a
  102dfd:	e8 3e e3 ff ff       	call   101140 <term::write(char)>
  102e02:	83 c4 04             	add    esp,0x4
  102e05:	6a 20                	push   0x20
  102e07:	e8 34 e3 ff ff       	call   101140 <term::write(char)>
  102e0c:	83 c4 04             	add    esp,0x4
  102e0f:	6a 27                	push   0x27
  102e11:	e8 2a e3 ff ff       	call   101140 <term::write(char)>
  102e16:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102e19:	8a 44 24 74          	mov    al,BYTE PTR [esp+0x74]
  102e1d:	84 c0                	test   al,al
  102e1f:	74 23                	je     102e44 <kernel_main+0x1294>
  102e21:	8d 74 24 75          	lea    esi,[esp+0x75]
  102e25:	90                   	nop
  102e26:	90                   	nop
  102e27:	90                   	nop
  102e28:	90                   	nop
  102e29:	90                   	nop
  102e2a:	90                   	nop
  102e2b:	90                   	nop
  102e2c:	90                   	nop
  102e2d:	90                   	nop
  102e2e:	90                   	nop
  102e2f:	90                   	nop
        write(s[a]);
  102e30:	0f be c0             	movsx  eax,al
  102e33:	50                   	push   eax
  102e34:	e8 07 e3 ff ff       	call   101140 <term::write(char)>
  102e39:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102e3c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  102e3f:	46                   	inc    esi
  102e40:	84 c0                	test   al,al
  102e42:	75 ec                	jne    102e30 <kernel_main+0x1280>
        write(s[a]);
  102e44:	6a 27                	push   0x27
  102e46:	e8 f5 e2 ff ff       	call   101140 <term::write(char)>
  102e4b:	83 c4 04             	add    esp,0x4
  102e4e:	6a 0a                	push   0xa
  102e50:	e8 eb e2 ff ff       	call   101140 <term::write(char)>
  102e55:	83 c4 04             	add    esp,0x4
  102e58:	90                   	nop
  102e59:	90                   	nop
  102e5a:	90                   	nop
  102e5b:	90                   	nop
  102e5c:	90                   	nop
  102e5d:	90                   	nop
  102e5e:	90                   	nop
  102e5f:	90                   	nop
  102e60:	31 c0                	xor    eax,eax
  102e62:	90                   	nop
  102e63:	90                   	nop
  102e64:	90                   	nop
  102e65:	90                   	nop
  102e66:	90                   	nop
  102e67:	90                   	nop
  102e68:	90                   	nop
  102e69:	90                   	nop
  102e6a:	90                   	nop
  102e6b:	90                   	nop
  102e6c:	90                   	nop
  102e6d:	90                   	nop
  102e6e:	90                   	nop
  102e6f:	90                   	nop
  102e70:	31 c9                	xor    ecx,ecx
  102e72:	90                   	nop
  102e73:	90                   	nop
  102e74:	90                   	nop
  102e75:	90                   	nop
  102e76:	90                   	nop
  102e77:	90                   	nop
  102e78:	90                   	nop
  102e79:	90                   	nop
  102e7a:	90                   	nop
  102e7b:	90                   	nop
  102e7c:	90                   	nop
  102e7d:	90                   	nop
  102e7e:	90                   	nop
  102e7f:	90                   	nop
            if (this->operator[](a) == 0)
  102e80:	80 7c 0c 14 00       	cmp    BYTE PTR [esp+ecx*1+0x14],0x0
  102e85:	74 0b                	je     102e92 <kernel_main+0x12e2>
        for (uint32 a = 0; a < N; a++) {
  102e87:	41                   	inc    ecx
  102e88:	83 f9 50             	cmp    ecx,0x50
  102e8b:	75 f3                	jne    102e80 <kernel_main+0x12d0>
  102e8d:	b9 50 00 00 00       	mov    ecx,0x50
        for (uint32 a = 0; a < length(); a++) {
  102e92:	39 c8                	cmp    eax,ecx
  102e94:	73 1a                	jae    102eb0 <kernel_main+0x1300>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102e96:	83 f8 03             	cmp    eax,0x3
  102e99:	0f 84 81 00 00 00    	je     102f20 <kernel_main+0x1370>
  102e9f:	8a 88 5b 00 10 00    	mov    cl,BYTE PTR [eax+0x10005b]
  102ea5:	3a 4c 04 14          	cmp    cl,BYTE PTR [esp+eax*1+0x14]
        for (uint32 a = 0; a < length(); a++) {
  102ea9:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102eac:	74 c2                	je     102e70 <kernel_main+0x12c0>
  102eae:	eb 70                	jmp    102f20 <kernel_main+0x1370>
  102eb0:	b8 fd ff ff ff       	mov    eax,0xfffffffd
  102eb5:	90                   	nop
  102eb6:	90                   	nop
  102eb7:	90                   	nop
  102eb8:	90                   	nop
  102eb9:	90                   	nop
  102eba:	90                   	nop
  102ebb:	90                   	nop
  102ebc:	90                   	nop
  102ebd:	90                   	nop
  102ebe:	90                   	nop
  102ebf:	90                   	nop
            if (this->operator[](a) == 0)
  102ec0:	80 7c 04 17 00       	cmp    BYTE PTR [esp+eax*1+0x17],0x0
  102ec5:	74 08                	je     102ecf <kernel_main+0x131f>
        for (uint32 a = 0; a < N; a++) {
  102ec7:	40                   	inc    eax
  102ec8:	83 f8 4d             	cmp    eax,0x4d
  102ecb:	75 f3                	jne    102ec0 <kernel_main+0x1310>
  102ecd:	eb 51                	jmp    102f20 <kernel_main+0x1370>
        return p[length()] == 0;
  102ecf:	85 c0                	test   eax,eax
        if (command == "mod") {
  102ed1:	75 4d                	jne    102f20 <kernel_main+0x1370>
  102ed3:	8b 44 24 04          	mov    eax,DWORD PTR [esp+0x4]
            auto mod = reinterpret_cast<void (*)(void)>(mods[0].mod_start);
  102ed7:	8b 30                	mov    esi,DWORD PTR [eax]
  102ed9:	6a 3e                	push   0x3e
  102edb:	e8 60 e2 ff ff       	call   101140 <term::write(char)>
  102ee0:	83 c4 04             	add    esp,0x4
  102ee3:	6a 3e                	push   0x3e
  102ee5:	e8 56 e2 ff ff       	call   101140 <term::write(char)>
  102eea:	83 c4 04             	add    esp,0x4
  102eed:	6a 3e                	push   0x3e
  102eef:	e8 4c e2 ff ff       	call   101140 <term::write(char)>
  102ef4:	83 c4 04             	add    esp,0x4
  102ef7:	6a 20                	push   0x20
  102ef9:	e8 42 e2 ff ff       	call   101140 <term::write(char)>
  102efe:	83 c4 04             	add    esp,0x4
  102f01:	b8 00 00 64 00       	mov    eax,0x640000
  102f06:	90                   	nop
  102f07:	90                   	nop
  102f08:	90                   	nop
  102f09:	90                   	nop
  102f0a:	90                   	nop
  102f0b:	90                   	nop
  102f0c:	90                   	nop
  102f0d:	90                   	nop
  102f0e:	90                   	nop
  102f0f:	90                   	nop
        asm volatile ("and %eax,%eax");
  102f10:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  102f12:	48                   	dec    eax
  102f13:	75 fb                	jne    102f10 <kernel_main+0x1360>
            mod();
  102f15:	ff d6                	call   esi
  102f17:	90                   	nop
  102f18:	90                   	nop
  102f19:	90                   	nop
  102f1a:	90                   	nop
  102f1b:	90                   	nop
  102f1c:	90                   	nop
  102f1d:	90                   	nop
  102f1e:	90                   	nop
  102f1f:	90                   	nop
  102f20:	31 c0                	xor    eax,eax
  102f22:	90                   	nop
  102f23:	90                   	nop
  102f24:	90                   	nop
  102f25:	90                   	nop
  102f26:	90                   	nop
  102f27:	90                   	nop
  102f28:	90                   	nop
  102f29:	90                   	nop
  102f2a:	90                   	nop
  102f2b:	90                   	nop
  102f2c:	90                   	nop
  102f2d:	90                   	nop
  102f2e:	90                   	nop
  102f2f:	90                   	nop
  102f30:	31 c9                	xor    ecx,ecx
  102f32:	90                   	nop
  102f33:	90                   	nop
  102f34:	90                   	nop
  102f35:	90                   	nop
  102f36:	90                   	nop
  102f37:	90                   	nop
  102f38:	90                   	nop
  102f39:	90                   	nop
  102f3a:	90                   	nop
  102f3b:	90                   	nop
  102f3c:	90                   	nop
  102f3d:	90                   	nop
  102f3e:	90                   	nop
  102f3f:	90                   	nop
            if (this->operator[](a) == 0)
  102f40:	80 7c 0c 14 00       	cmp    BYTE PTR [esp+ecx*1+0x14],0x0
  102f45:	74 0b                	je     102f52 <kernel_main+0x13a2>
        for (uint32 a = 0; a < N; a++) {
  102f47:	41                   	inc    ecx
  102f48:	83 f9 50             	cmp    ecx,0x50
  102f4b:	75 f3                	jne    102f40 <kernel_main+0x1390>
  102f4d:	b9 50 00 00 00       	mov    ecx,0x50
        for (uint32 a = 0; a < length(); a++) {
  102f52:	39 c8                	cmp    eax,ecx
  102f54:	73 1a                	jae    102f70 <kernel_main+0x13c0>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102f56:	83 f8 04             	cmp    eax,0x4
  102f59:	74 45                	je     102fa0 <kernel_main+0x13f0>
  102f5b:	8a 88 56 00 10 00    	mov    cl,BYTE PTR [eax+0x100056]
  102f61:	3a 4c 04 14          	cmp    cl,BYTE PTR [esp+eax*1+0x14]
        for (uint32 a = 0; a < length(); a++) {
  102f65:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102f68:	74 c6                	je     102f30 <kernel_main+0x1380>
  102f6a:	eb 34                	jmp    102fa0 <kernel_main+0x13f0>
  102f6c:	90                   	nop
  102f6d:	90                   	nop
  102f6e:	90                   	nop
  102f6f:	90                   	nop
  102f70:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  102f75:	90                   	nop
  102f76:	90                   	nop
  102f77:	90                   	nop
  102f78:	90                   	nop
  102f79:	90                   	nop
  102f7a:	90                   	nop
  102f7b:	90                   	nop
  102f7c:	90                   	nop
  102f7d:	90                   	nop
  102f7e:	90                   	nop
  102f7f:	90                   	nop
            if (this->operator[](a) == 0)
  102f80:	80 7c 04 18 00       	cmp    BYTE PTR [esp+eax*1+0x18],0x0
  102f85:	74 08                	je     102f8f <kernel_main+0x13df>
        for (uint32 a = 0; a < N; a++) {
  102f87:	40                   	inc    eax
  102f88:	83 f8 4c             	cmp    eax,0x4c
  102f8b:	75 f3                	jne    102f80 <kernel_main+0x13d0>
  102f8d:	eb 11                	jmp    102fa0 <kernel_main+0x13f0>
        return p[length()] == 0;
  102f8f:	85 c0                	test   eax,eax
        if (command == "game") {
  102f91:	0f 84 db 02 00 00    	je     103272 <kernel_main+0x16c2>
  102f97:	90                   	nop
  102f98:	90                   	nop
  102f99:	90                   	nop
  102f9a:	90                   	nop
  102f9b:	90                   	nop
  102f9c:	90                   	nop
  102f9d:	90                   	nop
  102f9e:	90                   	nop
  102f9f:	90                   	nop
  102fa0:	31 c0                	xor    eax,eax
  102fa2:	90                   	nop
  102fa3:	90                   	nop
  102fa4:	90                   	nop
  102fa5:	90                   	nop
  102fa6:	90                   	nop
  102fa7:	90                   	nop
  102fa8:	90                   	nop
  102fa9:	90                   	nop
  102faa:	90                   	nop
  102fab:	90                   	nop
  102fac:	90                   	nop
  102fad:	90                   	nop
  102fae:	90                   	nop
  102faf:	90                   	nop
  102fb0:	31 c9                	xor    ecx,ecx
  102fb2:	90                   	nop
  102fb3:	90                   	nop
  102fb4:	90                   	nop
  102fb5:	90                   	nop
  102fb6:	90                   	nop
  102fb7:	90                   	nop
  102fb8:	90                   	nop
  102fb9:	90                   	nop
  102fba:	90                   	nop
  102fbb:	90                   	nop
  102fbc:	90                   	nop
  102fbd:	90                   	nop
  102fbe:	90                   	nop
  102fbf:	90                   	nop
            if (this->operator[](a) == 0)
  102fc0:	80 7c 0c 14 00       	cmp    BYTE PTR [esp+ecx*1+0x14],0x0
  102fc5:	74 0b                	je     102fd2 <kernel_main+0x1422>
        for (uint32 a = 0; a < N; a++) {
  102fc7:	41                   	inc    ecx
  102fc8:	83 f9 50             	cmp    ecx,0x50
  102fcb:	75 f3                	jne    102fc0 <kernel_main+0x1410>
  102fcd:	b9 50 00 00 00       	mov    ecx,0x50
        for (uint32 a = 0; a < length(); a++) {
  102fd2:	39 c8                	cmp    eax,ecx
  102fd4:	73 2a                	jae    103000 <kernel_main+0x1450>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102fd6:	83 f8 06             	cmp    eax,0x6
  102fd9:	0f 84 01 02 00 00    	je     1031e0 <kernel_main+0x1630>
  102fdf:	8a 88 42 00 10 00    	mov    cl,BYTE PTR [eax+0x100042]
  102fe5:	3a 4c 04 14          	cmp    cl,BYTE PTR [esp+eax*1+0x14]
        for (uint32 a = 0; a < length(); a++) {
  102fe9:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102fec:	74 c2                	je     102fb0 <kernel_main+0x1400>
  102fee:	e9 ed 01 00 00       	jmp    1031e0 <kernel_main+0x1630>
  102ff3:	90                   	nop
  102ff4:	90                   	nop
  102ff5:	90                   	nop
  102ff6:	90                   	nop
  102ff7:	90                   	nop
  102ff8:	90                   	nop
  102ff9:	90                   	nop
  102ffa:	90                   	nop
  102ffb:	90                   	nop
  102ffc:	90                   	nop
  102ffd:	90                   	nop
  102ffe:	90                   	nop
  102fff:	90                   	nop
  103000:	b8 fa ff ff ff       	mov    eax,0xfffffffa
  103005:	90                   	nop
  103006:	90                   	nop
  103007:	90                   	nop
  103008:	90                   	nop
  103009:	90                   	nop
  10300a:	90                   	nop
  10300b:	90                   	nop
  10300c:	90                   	nop
  10300d:	90                   	nop
  10300e:	90                   	nop
  10300f:	90                   	nop
            if (this->operator[](a) == 0)
  103010:	80 7c 04 1a 00       	cmp    BYTE PTR [esp+eax*1+0x1a],0x0
  103015:	74 0b                	je     103022 <kernel_main+0x1472>
        for (uint32 a = 0; a < N; a++) {
  103017:	40                   	inc    eax
  103018:	83 f8 4a             	cmp    eax,0x4a
  10301b:	75 f3                	jne    103010 <kernel_main+0x1460>
  10301d:	e9 be 01 00 00       	jmp    1031e0 <kernel_main+0x1630>
        return p[length()] == 0;
  103022:	85 c0                	test   eax,eax
        if (command == "matrix") {
  103024:	0f 85 b6 01 00 00    	jne    1031e0 <kernel_main+0x1630>
  10302a:	31 c0                	xor    eax,eax
  10302c:	90                   	nop
  10302d:	90                   	nop
  10302e:	90                   	nop
  10302f:	90                   	nop
            if (this->operator[](a) == 0)
  103030:	80 7c 04 74 00       	cmp    BYTE PTR [esp+eax*1+0x74],0x0
  103035:	74 08                	je     10303f <kernel_main+0x148f>
        for (uint32 a = 0; a < N; a++) {
  103037:	40                   	inc    eax
  103038:	83 f8 50             	cmp    eax,0x50
  10303b:	75 f3                	jne    103030 <kernel_main+0x1480>
  10303d:	eb 04                	jmp    103043 <kernel_main+0x1493>
        for (uint32 a = 0; a < length(); a++) {
  10303f:	85 c0                	test   eax,eax
  103041:	74 51                	je     103094 <kernel_main+0x14e4>
  103043:	31 c0                	xor    eax,eax
  103045:	90                   	nop
  103046:	90                   	nop
  103047:	90                   	nop
  103048:	90                   	nop
  103049:	90                   	nop
  10304a:	90                   	nop
  10304b:	90                   	nop
  10304c:	90                   	nop
  10304d:	90                   	nop
  10304e:	90                   	nop
  10304f:	90                   	nop
            if (this->operator[](a) == 0)
  103050:	80 7c 04 74 00       	cmp    BYTE PTR [esp+eax*1+0x74],0x0
  103055:	74 0b                	je     103062 <kernel_main+0x14b2>
        for (uint32 a = 0; a < N; a++) {
  103057:	40                   	inc    eax
  103058:	83 f8 50             	cmp    eax,0x50
  10305b:	75 f3                	jne    103050 <kernel_main+0x14a0>
  10305d:	b8 50 00 00 00       	mov    eax,0x50
    constexpr auto end() const { return this->data_ + length(); }
  103062:	8d 4c 04 74          	lea    ecx,[esp+eax*1+0x74]
  103066:	8d 54 24 74          	lea    edx,[esp+0x74]
    for (auto c : p) {
  10306a:	39 ca                	cmp    edx,ecx
  10306c:	74 22                	je     103090 <kernel_main+0x14e0>
  10306e:	89 d1                	mov    ecx,edx
  103070:	31 f6                	xor    esi,esi
  103072:	90                   	nop
  103073:	90                   	nop
  103074:	90                   	nop
  103075:	90                   	nop
  103076:	90                   	nop
  103077:	90                   	nop
  103078:	90                   	nop
  103079:	90                   	nop
  10307a:	90                   	nop
  10307b:	90                   	nop
  10307c:	90                   	nop
  10307d:	90                   	nop
  10307e:	90                   	nop
  10307f:	90                   	nop
  103080:	0f be 11             	movsx  edx,BYTE PTR [ecx]
        r *= B;
  103083:	8d 34 b6             	lea    esi,[esi+esi*4]
        r += static_cast<int>(c - '0');
  103086:	8d 74 72 d0          	lea    esi,[edx+esi*2-0x30]
    for (auto c : p) {
  10308a:	41                   	inc    ecx
  10308b:	48                   	dec    eax
  10308c:	75 f2                	jne    103080 <kernel_main+0x14d0>
  10308e:	eb 09                	jmp    103099 <kernel_main+0x14e9>
  103090:	31 f6                	xor    esi,esi
  103092:	eb 05                	jmp    103099 <kernel_main+0x14e9>
  103094:	be 01 00 00 00       	mov    esi,0x1
            term::clear();
  103099:	e8 b2 df ff ff       	call   101050 <term::clear()>
        colour = static_cast<uint8>(fg | (bg << 4));
  10309e:	66 c7 05 0c 50 10 00 	mov    WORD PTR ds:0x10500c,0x102
  1030a5:	02 01 
            term::Term.wrap = true;
  1030a7:	c6 05 0e 50 10 00 01 	mov    BYTE PTR ds:0x10500e,0x1
            for (int a = 0; a < n; a++) {
  1030ae:	85 f6                	test   esi,esi
  1030b0:	0f 8e ff 00 00 00    	jle    1031b5 <kernel_main+0x1605>
  1030b6:	31 c0                	xor    eax,eax
  1030b8:	89 74 24 08          	mov    DWORD PTR [esp+0x8],esi
  1030bc:	eb 12                	jmp    1030d0 <kernel_main+0x1520>
  1030be:	90                   	nop
  1030bf:	90                   	nop
  1030c0:	8b 04 24             	mov    eax,DWORD PTR [esp]
  1030c3:	40                   	inc    eax
  1030c4:	8b 74 24 08          	mov    esi,DWORD PTR [esp+0x8]
  1030c8:	39 f0                	cmp    eax,esi
  1030ca:	0f 84 e5 00 00 00    	je     1031b5 <kernel_main+0x1605>
  1030d0:	89 04 24             	mov    DWORD PTR [esp],eax
  1030d3:	31 f6                	xor    esi,esi
  1030d5:	eb 41                	jmp    103118 <kernel_main+0x1568>
            increment_cursor(col, row, COLS, ROWS, COLS - (col % COLS));
  1030d7:	8b 0d 04 50 10 00    	mov    ecx,DWORD PTR ds:0x105004
  1030dd:	89 c8                	mov    eax,ecx
  1030df:	ba 67 66 66 66       	mov    edx,0x66666667
  1030e4:	f7 ea                	imul   edx
  1030e6:	89 d0                	mov    eax,edx
  1030e8:	c1 e8 1f             	shr    eax,0x1f
  1030eb:	c1 fa 05             	sar    edx,0x5
  1030ee:	01 c2                	add    edx,eax
  1030f0:	c1 e2 04             	shl    edx,0x4
  1030f3:	8d 04 92             	lea    eax,[edx+edx*4]
  1030f6:	29 c8                	sub    eax,ecx
  1030f8:	83 c0 50             	add    eax,0x50
  1030fb:	b9 04 50 10 00       	mov    ecx,0x105004
  103100:	ba 08 50 10 00       	mov    edx,0x105008
  103105:	50                   	push   eax
  103106:	6a 19                	push   0x19
  103108:	6a 50                	push   0x50
  10310a:	e8 e1 01 00 00       	call   1032f0 <term::$_0::increment_cursor(int&, int&, int, int, int)>
  10310f:	83 c4 0c             	add    esp,0xc
            value++;
  103112:	46                   	inc    esi
            return value != p.value;
  103113:	83 fe 50             	cmp    esi,0x50
                for (auto _ : range<0, term::COLS>) {
  103116:	74 a8                	je     1030c0 <kernel_main+0x1510>
  103118:	31 ff                	xor    edi,edi
  10311a:	90                   	nop
  10311b:	90                   	nop
  10311c:	90                   	nop
  10311d:	90                   	nop
  10311e:	90                   	nop
  10311f:	90                   	nop
                        if (rnd.next(10) == 1) {
  103120:	6a 0a                	push   0xa
  103122:	8d 9c 24 fc 02 00 00 	lea    ebx,[esp+0x2fc]
  103129:	53                   	push   ebx
  10312a:	e8 f1 09 00 00       	call   103b20 <rand::random_gen::next(unsigned int)>
  10312f:	83 c4 08             	add    esp,0x8
  103132:	83 f8 01             	cmp    eax,0x1
  103135:	74 39                	je     103170 <kernel_main+0x15c0>
                        term::write(char('$' + (rnd.next(60))));
  103137:	6a 3c                	push   0x3c
  103139:	53                   	push   ebx
  10313a:	e8 e1 09 00 00       	call   103b20 <rand::random_gen::next(unsigned int)>
  10313f:	83 c4 08             	add    esp,0x8
  103142:	04 24                	add    al,0x24
  103144:	0f be c0             	movsx  eax,al
  103147:	50                   	push   eax
  103148:	e8 f3 df ff ff       	call   101140 <term::write(char)>
  10314d:	83 c4 04             	add    esp,0x4
  103150:	b8 00 00 1e 00       	mov    eax,0x1e0000
  103155:	90                   	nop
  103156:	90                   	nop
  103157:	90                   	nop
  103158:	90                   	nop
  103159:	90                   	nop
  10315a:	90                   	nop
  10315b:	90                   	nop
  10315c:	90                   	nop
  10315d:	90                   	nop
  10315e:	90                   	nop
  10315f:	90                   	nop
        asm volatile ("and %eax,%eax");
  103160:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  103162:	48                   	dec    eax
  103163:	75 fb                	jne    103160 <kernel_main+0x15b0>
            value++;
  103165:	47                   	inc    edi
            return value != p.value;
  103166:	83 ff 19             	cmp    edi,0x19
                    for (auto _ : range<0, term::ROWS>) {
  103169:	75 b5                	jne    103120 <kernel_main+0x1570>
  10316b:	eb a5                	jmp    103112 <kernel_main+0x1562>
  10316d:	90                   	nop
  10316e:	90                   	nop
  10316f:	90                   	nop
        if (!flipped) {
  103170:	80 3d 0d 50 10 00 00 	cmp    BYTE PTR ds:0x10500d,0x0
  103177:	0f 84 5a ff ff ff    	je     1030d7 <kernel_main+0x1527>
            increment_cursor(row, col, ROWS, COLS, ROWS - (row % ROWS));
  10317d:	8b 0d 08 50 10 00    	mov    ecx,DWORD PTR ds:0x105008
  103183:	89 c8                	mov    eax,ecx
  103185:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  10318a:	f7 ea                	imul   edx
  10318c:	89 d0                	mov    eax,edx
  10318e:	c1 e8 1f             	shr    eax,0x1f
  103191:	c1 fa 03             	sar    edx,0x3
  103194:	01 c2                	add    edx,eax
  103196:	8d 04 92             	lea    eax,[edx+edx*4]
  103199:	8d 04 80             	lea    eax,[eax+eax*4]
  10319c:	29 c8                	sub    eax,ecx
  10319e:	83 c0 19             	add    eax,0x19
  1031a1:	b9 08 50 10 00       	mov    ecx,0x105008
  1031a6:	ba 04 50 10 00       	mov    edx,0x105004
  1031ab:	50                   	push   eax
  1031ac:	6a 50                	push   0x50
  1031ae:	6a 19                	push   0x19
  1031b0:	e9 55 ff ff ff       	jmp    10310a <kernel_main+0x155a>
            term::Term.wrap = false;
  1031b5:	c6 05 0e 50 10 00 00 	mov    BYTE PTR ds:0x10500e,0x0
        colour = static_cast<uint8>(fg | (bg << 4));
  1031bc:	66 c7 05 0c 50 10 00 	mov    WORD PTR ds:0x10500c,0xf
  1031c3:	0f 00 
  1031c5:	8d bc 24 f8 02 00 00 	lea    edi,[esp+0x2f8]
  1031cc:	8d 9c 24 f8 00 00 00 	lea    ebx,[esp+0xf8]
  1031d3:	90                   	nop
  1031d4:	90                   	nop
  1031d5:	90                   	nop
  1031d6:	90                   	nop
  1031d7:	90                   	nop
  1031d8:	90                   	nop
  1031d9:	90                   	nop
  1031da:	90                   	nop
  1031db:	90                   	nop
  1031dc:	90                   	nop
  1031dd:	90                   	nop
  1031de:	90                   	nop
  1031df:	90                   	nop
  1031e0:	31 c0                	xor    eax,eax
  1031e2:	90                   	nop
  1031e3:	90                   	nop
  1031e4:	90                   	nop
  1031e5:	90                   	nop
  1031e6:	90                   	nop
  1031e7:	90                   	nop
  1031e8:	90                   	nop
  1031e9:	90                   	nop
  1031ea:	90                   	nop
  1031eb:	90                   	nop
  1031ec:	90                   	nop
  1031ed:	90                   	nop
  1031ee:	90                   	nop
  1031ef:	90                   	nop
  1031f0:	31 c9                	xor    ecx,ecx
  1031f2:	90                   	nop
  1031f3:	90                   	nop
  1031f4:	90                   	nop
  1031f5:	90                   	nop
  1031f6:	90                   	nop
  1031f7:	90                   	nop
  1031f8:	90                   	nop
  1031f9:	90                   	nop
  1031fa:	90                   	nop
  1031fb:	90                   	nop
  1031fc:	90                   	nop
  1031fd:	90                   	nop
  1031fe:	90                   	nop
  1031ff:	90                   	nop
            if (this->operator[](a) == 0)
  103200:	80 7c 0c 14 00       	cmp    BYTE PTR [esp+ecx*1+0x14],0x0
  103205:	74 0b                	je     103212 <kernel_main+0x1662>
        for (uint32 a = 0; a < N; a++) {
  103207:	41                   	inc    ecx
  103208:	83 f9 50             	cmp    ecx,0x50
  10320b:	75 f3                	jne    103200 <kernel_main+0x1650>
  10320d:	b9 50 00 00 00       	mov    ecx,0x50
        for (uint32 a = 0; a < length(); a++) {
  103212:	39 c8                	cmp    eax,ecx
  103214:	73 2a                	jae    103240 <kernel_main+0x1690>
            if (p[a] == 0 || p[a] != this->operator[](a))
  103216:	83 f8 08             	cmp    eax,0x8
  103219:	0f 84 51 f4 ff ff    	je     102670 <kernel_main+0xac0>
  10321f:	8a 88 91 00 10 00    	mov    cl,BYTE PTR [eax+0x100091]
  103225:	3a 4c 04 14          	cmp    cl,BYTE PTR [esp+eax*1+0x14]
        for (uint32 a = 0; a < length(); a++) {
  103229:	8d 40 01             	lea    eax,[eax+0x1]
  10322c:	74 c2                	je     1031f0 <kernel_main+0x1640>
  10322e:	e9 3d f4 ff ff       	jmp    102670 <kernel_main+0xac0>
  103233:	90                   	nop
  103234:	90                   	nop
  103235:	90                   	nop
  103236:	90                   	nop
  103237:	90                   	nop
  103238:	90                   	nop
  103239:	90                   	nop
  10323a:	90                   	nop
  10323b:	90                   	nop
  10323c:	90                   	nop
  10323d:	90                   	nop
  10323e:	90                   	nop
  10323f:	90                   	nop
  103240:	b8 f8 ff ff ff       	mov    eax,0xfffffff8
  103245:	90                   	nop
  103246:	90                   	nop
  103247:	90                   	nop
  103248:	90                   	nop
  103249:	90                   	nop
  10324a:	90                   	nop
  10324b:	90                   	nop
  10324c:	90                   	nop
  10324d:	90                   	nop
  10324e:	90                   	nop
  10324f:	90                   	nop
            if (this->operator[](a) == 0)
  103250:	80 7c 04 1c 00       	cmp    BYTE PTR [esp+eax*1+0x1c],0x0
  103255:	0f 84 0a f4 ff ff    	je     102665 <kernel_main+0xab5>
        for (uint32 a = 0; a < N; a++) {
  10325b:	40                   	inc    eax
  10325c:	83 f8 48             	cmp    eax,0x48
  10325f:	75 ef                	jne    103250 <kernel_main+0x16a0>
  103261:	e9 0a f4 ff ff       	jmp    102670 <kernel_main+0xac0>
    asm("hlt");
  103266:	f4                   	hlt    
  103267:	90                   	nop
  103268:	90                   	nop
  103269:	90                   	nop
  10326a:	90                   	nop
  10326b:	90                   	nop
  10326c:	90                   	nop
  10326d:	90                   	nop
  10326e:	90                   	nop
  10326f:	90                   	nop
    while (true)
  103270:	eb fe                	jmp    103270 <kernel_main+0x16c0>
  103272:	8d b4 24 f8 00 00 00 	lea    esi,[esp+0xf8]
            game_of_life g;
  103279:	56                   	push   esi
  10327a:	e8 41 07 00 00       	call   1039c0 <game_of_life::game_of_life()>
  10327f:	83 c4 04             	add    esp,0x4
            }
    }

    void run(int gens = 10) {
        for (int a = 0; a < gens; a++) {
            step();
  103282:	56                   	push   esi
  103283:	e8 58 0a 00 00       	call   103ce0 <game_of_life::step()>
  103288:	83 c4 04             	add    esp,0x4
  10328b:	31 f6                	xor    esi,esi
  10328d:	90                   	nop
  10328e:	90                   	nop
  10328f:	90                   	nop
  103290:	bf 19 00 00 00       	mov    edi,0x19
  103295:	89 34 24             	mov    DWORD PTR [esp],esi
  103298:	8d 9c 24 d0 00 00 00 	lea    ebx,[esp+0xd0]
  10329f:	90                   	nop
        return bit_member(*this, static_cast<int>(i));
  1032a0:	56                   	push   esi
  1032a1:	8d 84 24 fc 00 00 00 	lea    eax,[esp+0xfc]
  1032a8:	50                   	push   eax
  1032a9:	53                   	push   ebx
  1032aa:	e8 f1 09 00 00       	call   103ca0 <mem::bit_sequence<2000u>::bit_member::bit_member(mem::bit_sequence<2000u>&, int)>
  1032af:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  1032b2:	80 bc 24 d8 00 00 00 	cmp    BYTE PTR [esp+0xd8],0x0
  1032b9:	00 

    void draw() {
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                auto c = board(x, y);
                term::write(c ? 'X' : '-');
  1032ba:	b8 58 00 00 00       	mov    eax,0x58
  1032bf:	b9 2d 00 00 00       	mov    ecx,0x2d
  1032c4:	0f 44 c1             	cmove  eax,ecx
  1032c7:	50                   	push   eax
  1032c8:	e8 73 de ff ff       	call   101140 <term::write(char)>
  1032cd:	83 c4 04             	add    esp,0x4
            for (int y = 0; y < height; y++) {
  1032d0:	83 c6 50             	add    esi,0x50
  1032d3:	4f                   	dec    edi
  1032d4:	75 ca                	jne    1032a0 <kernel_main+0x16f0>
  1032d6:	8b 34 24             	mov    esi,DWORD PTR [esp]
        for (int x = 0; x < width; x++) {
  1032d9:	46                   	inc    esi
  1032da:	83 fe 50             	cmp    esi,0x50
  1032dd:	75 b1                	jne    103290 <kernel_main+0x16e0>
  1032df:	90                   	nop
            while(true);
  1032e0:	eb fe                	jmp    1032e0 <kernel_main+0x1730>
        term::fatal_error("FAIL (shutting down)\n");
  1032e2:	68 2c 00 10 00       	push   0x10002c
  1032e7:	e8 94 06 00 00       	call   103980 <void term::fatal_error<char const*>(char const*)>
  1032ec:	90                   	nop
  1032ed:	90                   	nop
  1032ee:	90                   	nop
  1032ef:	90                   	nop

001032f0 <term::$_0::increment_cursor(int&, int&, int, int, int)>:
                          int cross_limit, int times = 0) {
  1032f0:	55                   	push   ebp
  1032f1:	89 e5                	mov    ebp,esp
  1032f3:	53                   	push   ebx
  1032f4:	57                   	push   edi
  1032f5:	56                   	push   esi
  1032f6:	83 ec 08             	sub    esp,0x8
  1032f9:	89 55 f0             	mov    DWORD PTR [ebp-0x10],edx
  1032fc:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
        for (int a = 0; a < times; a++) {
  1032ff:	85 c0                	test   eax,eax
  103301:	0f 8e 13 03 00 00    	jle    10361a <term::$_0::increment_cursor(int&, int&, int, int, int)+0x32a>
  103307:	89 cf                	mov    edi,ecx
  103309:	80 3d 0e 50 10 00 00 	cmp    BYTE PTR ds:0x10500e,0x0
  103310:	75 25                	jne    103337 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x47>
  103312:	8b 1d 0c 50 10 00    	mov    ebx,DWORD PTR ds:0x10500c
  103318:	c1 e3 08             	shl    ebx,0x8
  10331b:	83 cb 20             	or     ebx,0x20
  10331e:	8b 35 00 50 10 00    	mov    esi,DWORD PTR ds:0x105000
  103324:	31 c9                	xor    ecx,ecx
  103326:	89 7d ec             	mov    DWORD PTR [ebp-0x14],edi
  103329:	eb 61                	jmp    10338c <term::$_0::increment_cursor(int&, int&, int, int, int)+0x9c>
  10332b:	90                   	nop
  10332c:	90                   	nop
  10332d:	90                   	nop
  10332e:	90                   	nop
  10332f:	90                   	nop
  103330:	48                   	dec    eax
  103331:	0f 84 e3 02 00 00    	je     10361a <term::$_0::increment_cursor(int&, int&, int, int, int)+0x32a>
            main++;
  103337:	8b 0f                	mov    ecx,DWORD PTR [edi]
  103339:	41                   	inc    ecx
  10333a:	89 0f                	mov    DWORD PTR [edi],ecx
            if (main == main_limit) {
  10333c:	3b 4d 08             	cmp    ecx,DWORD PTR [ebp+0x8]
  10333f:	75 1f                	jne    103360 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x70>
                main = 0;
  103341:	c7 07 00 00 00 00    	mov    DWORD PTR [edi],0x0
  103347:	8b 4d f0             	mov    ecx,DWORD PTR [ebp-0x10]
                cross++;
  10334a:	8b 11                	mov    edx,DWORD PTR [ecx]
  10334c:	42                   	inc    edx
  10334d:	89 11                	mov    DWORD PTR [ecx],edx
            if (cross == cross_limit) {
  10334f:	3b 55 0c             	cmp    edx,DWORD PTR [ebp+0xc]
  103352:	75 dc                	jne    103330 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x40>
  103354:	eb 14                	jmp    10336a <term::$_0::increment_cursor(int&, int&, int, int, int)+0x7a>
  103356:	90                   	nop
  103357:	90                   	nop
  103358:	90                   	nop
  103359:	90                   	nop
  10335a:	90                   	nop
  10335b:	90                   	nop
  10335c:	90                   	nop
  10335d:	90                   	nop
  10335e:	90                   	nop
  10335f:	90                   	nop
  103360:	8b 4d f0             	mov    ecx,DWORD PTR [ebp-0x10]
  103363:	8b 11                	mov    edx,DWORD PTR [ecx]
  103365:	3b 55 0c             	cmp    edx,DWORD PTR [ebp+0xc]
  103368:	75 c6                	jne    103330 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x40>
  10336a:	c7 07 00 00 00 00    	mov    DWORD PTR [edi],0x0
  103370:	8b 4d f0             	mov    ecx,DWORD PTR [ebp-0x10]
                    cross = 0;
  103373:	c7 01 00 00 00 00    	mov    DWORD PTR [ecx],0x0
  103379:	eb b5                	jmp    103330 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x40>
  10337b:	90                   	nop
  10337c:	90                   	nop
  10337d:	90                   	nop
  10337e:	90                   	nop
  10337f:	90                   	nop
        for (int a = 0; a < times; a++) {
  103380:	41                   	inc    ecx
  103381:	39 c1                	cmp    ecx,eax
  103383:	8b 7d ec             	mov    edi,DWORD PTR [ebp-0x14]
  103386:	0f 84 8e 02 00 00    	je     10361a <term::$_0::increment_cursor(int&, int&, int, int, int)+0x32a>
  10338c:	89 fa                	mov    edx,edi
            main++;
  10338e:	8b 3f                	mov    edi,DWORD PTR [edi]
  103390:	47                   	inc    edi
  103391:	89 3a                	mov    DWORD PTR [edx],edi
            if (main == main_limit) {
  103393:	3b 7d 08             	cmp    edi,DWORD PTR [ebp+0x8]
  103396:	75 18                	jne    1033b0 <term::$_0::increment_cursor(int&, int&, int, int, int)+0xc0>
                main = 0;
  103398:	c7 02 00 00 00 00    	mov    DWORD PTR [edx],0x0
  10339e:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
                cross++;
  1033a1:	8b 3a                	mov    edi,DWORD PTR [edx]
  1033a3:	47                   	inc    edi
  1033a4:	89 3a                	mov    DWORD PTR [edx],edi
            if (cross == cross_limit) {
  1033a6:	3b 7d 0c             	cmp    edi,DWORD PTR [ebp+0xc]
  1033a9:	75 d5                	jne    103380 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x90>
  1033ab:	eb 0d                	jmp    1033ba <term::$_0::increment_cursor(int&, int&, int, int, int)+0xca>
  1033ad:	90                   	nop
  1033ae:	90                   	nop
  1033af:	90                   	nop
  1033b0:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
  1033b3:	8b 3a                	mov    edi,DWORD PTR [edx]
  1033b5:	3b 7d 0c             	cmp    edi,DWORD PTR [ebp+0xc]
  1033b8:	75 c6                	jne    103380 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x90>
  1033ba:	8b 55 ec             	mov    edx,DWORD PTR [ebp-0x14]
  1033bd:	c7 02 00 00 00 00    	mov    DWORD PTR [edx],0x0
  1033c3:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
                    cross--;
  1033c6:	ff 0a                	dec    DWORD PTR [edx]
  1033c8:	bf 00 f1 ff ff       	mov    edi,0xfffff100
  1033cd:	90                   	nop
  1033ce:	90                   	nop
  1033cf:	90                   	nop
                        VGA_BUF[a] = VGA_BUF[a + COLS];
  1033d0:	0f b7 94 3e a0 0f 00 	movzx  edx,WORD PTR [esi+edi*1+0xfa0]
  1033d7:	00 
  1033d8:	66 89 94 3e 00 0f 00 	mov    WORD PTR [esi+edi*1+0xf00],dx
  1033df:	00 
            return value != p.value;
  1033e0:	83 c7 02             	add    edi,0x2
                    for (auto a : range<0, (ROWS - 1) * COLS>) {
  1033e3:	75 eb                	jne    1033d0 <term::$_0::increment_cursor(int&, int&, int, int, int)+0xe0>
                        VGA_BUF[a] = static_cast<uint16>((colour << 8) | ' ');
  1033e5:	66 89 9e 00 0f 00 00 	mov    WORD PTR [esi+0xf00],bx
  1033ec:	66 89 9e 02 0f 00 00 	mov    WORD PTR [esi+0xf02],bx
  1033f3:	66 89 9e 04 0f 00 00 	mov    WORD PTR [esi+0xf04],bx
  1033fa:	66 89 9e 06 0f 00 00 	mov    WORD PTR [esi+0xf06],bx
  103401:	66 89 9e 08 0f 00 00 	mov    WORD PTR [esi+0xf08],bx
  103408:	66 89 9e 0a 0f 00 00 	mov    WORD PTR [esi+0xf0a],bx
  10340f:	66 89 9e 0c 0f 00 00 	mov    WORD PTR [esi+0xf0c],bx
  103416:	66 89 9e 0e 0f 00 00 	mov    WORD PTR [esi+0xf0e],bx
  10341d:	66 89 9e 10 0f 00 00 	mov    WORD PTR [esi+0xf10],bx
  103424:	66 89 9e 12 0f 00 00 	mov    WORD PTR [esi+0xf12],bx
  10342b:	66 89 9e 14 0f 00 00 	mov    WORD PTR [esi+0xf14],bx
  103432:	66 89 9e 16 0f 00 00 	mov    WORD PTR [esi+0xf16],bx
  103439:	66 89 9e 18 0f 00 00 	mov    WORD PTR [esi+0xf18],bx
  103440:	66 89 9e 1a 0f 00 00 	mov    WORD PTR [esi+0xf1a],bx
  103447:	66 89 9e 1c 0f 00 00 	mov    WORD PTR [esi+0xf1c],bx
  10344e:	66 89 9e 1e 0f 00 00 	mov    WORD PTR [esi+0xf1e],bx
  103455:	66 89 9e 20 0f 00 00 	mov    WORD PTR [esi+0xf20],bx
  10345c:	66 89 9e 22 0f 00 00 	mov    WORD PTR [esi+0xf22],bx
  103463:	66 89 9e 24 0f 00 00 	mov    WORD PTR [esi+0xf24],bx
  10346a:	66 89 9e 26 0f 00 00 	mov    WORD PTR [esi+0xf26],bx
  103471:	66 89 9e 28 0f 00 00 	mov    WORD PTR [esi+0xf28],bx
  103478:	66 89 9e 2a 0f 00 00 	mov    WORD PTR [esi+0xf2a],bx
  10347f:	66 89 9e 2c 0f 00 00 	mov    WORD PTR [esi+0xf2c],bx
  103486:	66 89 9e 2e 0f 00 00 	mov    WORD PTR [esi+0xf2e],bx
  10348d:	66 89 9e 30 0f 00 00 	mov    WORD PTR [esi+0xf30],bx
  103494:	66 89 9e 32 0f 00 00 	mov    WORD PTR [esi+0xf32],bx
  10349b:	66 89 9e 34 0f 00 00 	mov    WORD PTR [esi+0xf34],bx
  1034a2:	66 89 9e 36 0f 00 00 	mov    WORD PTR [esi+0xf36],bx
  1034a9:	66 89 9e 38 0f 00 00 	mov    WORD PTR [esi+0xf38],bx
  1034b0:	66 89 9e 3a 0f 00 00 	mov    WORD PTR [esi+0xf3a],bx
  1034b7:	66 89 9e 3c 0f 00 00 	mov    WORD PTR [esi+0xf3c],bx
  1034be:	66 89 9e 3e 0f 00 00 	mov    WORD PTR [esi+0xf3e],bx
  1034c5:	66 89 9e 40 0f 00 00 	mov    WORD PTR [esi+0xf40],bx
  1034cc:	66 89 9e 42 0f 00 00 	mov    WORD PTR [esi+0xf42],bx
  1034d3:	66 89 9e 44 0f 00 00 	mov    WORD PTR [esi+0xf44],bx
  1034da:	66 89 9e 46 0f 00 00 	mov    WORD PTR [esi+0xf46],bx
  1034e1:	66 89 9e 48 0f 00 00 	mov    WORD PTR [esi+0xf48],bx
  1034e8:	66 89 9e 4a 0f 00 00 	mov    WORD PTR [esi+0xf4a],bx
  1034ef:	66 89 9e 4c 0f 00 00 	mov    WORD PTR [esi+0xf4c],bx
  1034f6:	66 89 9e 4e 0f 00 00 	mov    WORD PTR [esi+0xf4e],bx
  1034fd:	66 89 9e 50 0f 00 00 	mov    WORD PTR [esi+0xf50],bx
  103504:	66 89 9e 52 0f 00 00 	mov    WORD PTR [esi+0xf52],bx
  10350b:	66 89 9e 54 0f 00 00 	mov    WORD PTR [esi+0xf54],bx
  103512:	66 89 9e 56 0f 00 00 	mov    WORD PTR [esi+0xf56],bx
  103519:	66 89 9e 58 0f 00 00 	mov    WORD PTR [esi+0xf58],bx
  103520:	66 89 9e 5a 0f 00 00 	mov    WORD PTR [esi+0xf5a],bx
  103527:	66 89 9e 5c 0f 00 00 	mov    WORD PTR [esi+0xf5c],bx
  10352e:	66 89 9e 5e 0f 00 00 	mov    WORD PTR [esi+0xf5e],bx
  103535:	66 89 9e 60 0f 00 00 	mov    WORD PTR [esi+0xf60],bx
  10353c:	66 89 9e 62 0f 00 00 	mov    WORD PTR [esi+0xf62],bx
  103543:	66 89 9e 64 0f 00 00 	mov    WORD PTR [esi+0xf64],bx
  10354a:	66 89 9e 66 0f 00 00 	mov    WORD PTR [esi+0xf66],bx
  103551:	66 89 9e 68 0f 00 00 	mov    WORD PTR [esi+0xf68],bx
  103558:	66 89 9e 6a 0f 00 00 	mov    WORD PTR [esi+0xf6a],bx
  10355f:	66 89 9e 6c 0f 00 00 	mov    WORD PTR [esi+0xf6c],bx
  103566:	66 89 9e 6e 0f 00 00 	mov    WORD PTR [esi+0xf6e],bx
  10356d:	66 89 9e 70 0f 00 00 	mov    WORD PTR [esi+0xf70],bx
  103574:	66 89 9e 72 0f 00 00 	mov    WORD PTR [esi+0xf72],bx
  10357b:	66 89 9e 74 0f 00 00 	mov    WORD PTR [esi+0xf74],bx
  103582:	66 89 9e 76 0f 00 00 	mov    WORD PTR [esi+0xf76],bx
  103589:	66 89 9e 78 0f 00 00 	mov    WORD PTR [esi+0xf78],bx
  103590:	66 89 9e 7a 0f 00 00 	mov    WORD PTR [esi+0xf7a],bx
  103597:	66 89 9e 7c 0f 00 00 	mov    WORD PTR [esi+0xf7c],bx
  10359e:	66 89 9e 7e 0f 00 00 	mov    WORD PTR [esi+0xf7e],bx
  1035a5:	66 89 9e 80 0f 00 00 	mov    WORD PTR [esi+0xf80],bx
  1035ac:	66 89 9e 82 0f 00 00 	mov    WORD PTR [esi+0xf82],bx
  1035b3:	66 89 9e 84 0f 00 00 	mov    WORD PTR [esi+0xf84],bx
  1035ba:	66 89 9e 86 0f 00 00 	mov    WORD PTR [esi+0xf86],bx
  1035c1:	66 89 9e 88 0f 00 00 	mov    WORD PTR [esi+0xf88],bx
  1035c8:	66 89 9e 8a 0f 00 00 	mov    WORD PTR [esi+0xf8a],bx
  1035cf:	66 89 9e 8c 0f 00 00 	mov    WORD PTR [esi+0xf8c],bx
  1035d6:	66 89 9e 8e 0f 00 00 	mov    WORD PTR [esi+0xf8e],bx
  1035dd:	66 89 9e 90 0f 00 00 	mov    WORD PTR [esi+0xf90],bx
  1035e4:	66 89 9e 92 0f 00 00 	mov    WORD PTR [esi+0xf92],bx
  1035eb:	66 89 9e 94 0f 00 00 	mov    WORD PTR [esi+0xf94],bx
  1035f2:	66 89 9e 96 0f 00 00 	mov    WORD PTR [esi+0xf96],bx
  1035f9:	66 89 9e 98 0f 00 00 	mov    WORD PTR [esi+0xf98],bx
  103600:	66 89 9e 9a 0f 00 00 	mov    WORD PTR [esi+0xf9a],bx
  103607:	66 89 9e 9c 0f 00 00 	mov    WORD PTR [esi+0xf9c],bx
  10360e:	66 89 9e 9e 0f 00 00 	mov    WORD PTR [esi+0xf9e],bx
  103615:	e9 66 fd ff ff       	jmp    103380 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x90>
    }
  10361a:	83 c4 08             	add    esp,0x8
  10361d:	5e                   	pop    esi
  10361e:	5f                   	pop    edi
  10361f:	5b                   	pop    ebx
  103620:	5d                   	pop    ebp
  103621:	c3                   	ret    
  103622:	cc                   	int3   
  103623:	cc                   	int3   
  103624:	cc                   	int3   
  103625:	cc                   	int3   
  103626:	cc                   	int3   
  103627:	cc                   	int3   
  103628:	cc                   	int3   
  103629:	cc                   	int3   
  10362a:	cc                   	int3   
  10362b:	cc                   	int3   
  10362c:	cc                   	int3   
  10362d:	cc                   	int3   
  10362e:	cc                   	int3   
  10362f:	cc                   	int3   

00103630 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)>:
    for (auto &a : {p...}) {
        write(a);
    }
}

template <class... S>[[noreturn]] void fatal_error(S... msg) {
  103630:	55                   	push   ebp
  103631:	89 e5                	mov    ebp,esp
  103633:	57                   	push   edi
  103634:	56                   	push   esi
  103635:	8b 75 0c             	mov    esi,DWORD PTR [ebp+0xc]
  103638:	8b 7d 08             	mov    edi,DWORD PTR [ebp+0x8]
    for (int a = 0; s[a] != 0; a++) {
  10363b:	8a 07                	mov    al,BYTE PTR [edi]
  10363d:	84 c0                	test   al,al
  10363f:	74 23                	je     103664 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x34>
  103641:	47                   	inc    edi
  103642:	90                   	nop
  103643:	90                   	nop
  103644:	90                   	nop
  103645:	90                   	nop
  103646:	90                   	nop
  103647:	90                   	nop
  103648:	90                   	nop
  103649:	90                   	nop
  10364a:	90                   	nop
  10364b:	90                   	nop
  10364c:	90                   	nop
  10364d:	90                   	nop
  10364e:	90                   	nop
  10364f:	90                   	nop
        write(s[a]);
  103650:	0f be c0             	movsx  eax,al
  103653:	50                   	push   eax
  103654:	e8 e7 da ff ff       	call   101140 <term::write(char)>
  103659:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10365c:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  10365f:	47                   	inc    edi
  103660:	84 c0                	test   al,al
  103662:	75 ec                	jne    103650 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x20>
  103664:	8b 7d 10             	mov    edi,DWORD PTR [ebp+0x10]
  103667:	8a 06                	mov    al,BYTE PTR [esi]
  103669:	84 c0                	test   al,al
  10366b:	74 17                	je     103684 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x54>
  10366d:	46                   	inc    esi
  10366e:	90                   	nop
  10366f:	90                   	nop
        write(s[a]);
  103670:	0f be c0             	movsx  eax,al
  103673:	50                   	push   eax
  103674:	e8 c7 da ff ff       	call   101140 <term::write(char)>
  103679:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10367c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10367f:	46                   	inc    esi
  103680:	84 c0                	test   al,al
  103682:	75 ec                	jne    103670 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x40>
  103684:	8a 07                	mov    al,BYTE PTR [edi]
  103686:	84 c0                	test   al,al
  103688:	74 1a                	je     1036a4 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x74>
  10368a:	47                   	inc    edi
  10368b:	90                   	nop
  10368c:	90                   	nop
  10368d:	90                   	nop
  10368e:	90                   	nop
  10368f:	90                   	nop
        write(s[a]);
  103690:	0f be c0             	movsx  eax,al
  103693:	50                   	push   eax
  103694:	e8 a7 da ff ff       	call   101140 <term::write(char)>
  103699:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10369c:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  10369f:	47                   	inc    edi
  1036a0:	84 c0                	test   al,al
  1036a2:	75 ec                	jne    103690 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x60>
    asm("hlt");
  1036a4:	f4                   	hlt    
  1036a5:	90                   	nop
  1036a6:	90                   	nop
  1036a7:	90                   	nop
  1036a8:	90                   	nop
  1036a9:	90                   	nop
  1036aa:	90                   	nop
  1036ab:	90                   	nop
  1036ac:	90                   	nop
  1036ad:	90                   	nop
  1036ae:	90                   	nop
  1036af:	90                   	nop
    while (true)
  1036b0:	eb fe                	jmp    1036b0 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x80>
  1036b2:	cc                   	int3   
  1036b3:	cc                   	int3   
  1036b4:	cc                   	int3   
  1036b5:	cc                   	int3   
  1036b6:	cc                   	int3   
  1036b7:	cc                   	int3   
  1036b8:	cc                   	int3   
  1036b9:	cc                   	int3   
  1036ba:	cc                   	int3   
  1036bb:	cc                   	int3   
  1036bc:	cc                   	int3   
  1036bd:	cc                   	int3   
  1036be:	cc                   	int3   
  1036bf:	cc                   	int3   

001036c0 <auto int_to_string<10, unsigned int>(unsigned int)>:
template <int B = 10, class I> constexpr auto int_to_string(I x) {
  1036c0:	55                   	push   ebp
  1036c1:	89 e5                	mov    ebp,esp
  1036c3:	53                   	push   ebx
  1036c4:	57                   	push   edi
  1036c5:	56                   	push   esi
  1036c6:	83 e4 f8             	and    esp,0xfffffff8
  1036c9:	83 ec 28             	sub    esp,0x28
  1036cc:	8b 5d 0c             	mov    ebx,DWORD PTR [ebp+0xc]
    constexpr array() : data_{T()} {}
  1036cf:	66 c7 44 24 1c 00 00 	mov    WORD PTR [esp+0x1c],0x0
  1036d6:	c7 44 24 18 00 00 00 	mov    DWORD PTR [esp+0x18],0x0
  1036dd:	00 
  1036de:	c7 44 24 14 00 00 00 	mov    DWORD PTR [esp+0x14],0x0
  1036e5:	00 
  1036e6:	c7 44 24 10 00 00 00 	mov    DWORD PTR [esp+0x10],0x0
  1036ed:	00 
  1036ee:	c7 44 24 0c 00 00 00 	mov    DWORD PTR [esp+0xc],0x0
  1036f5:	00 
  1036f6:	c7 44 24 08 00 00 00 	mov    DWORD PTR [esp+0x8],0x0
  1036fd:	00 
  1036fe:	c7 44 24 04 00 00 00 	mov    DWORD PTR [esp+0x4],0x0
  103705:	00 
  103706:	c7 04 24 00 00 00 00 	mov    DWORD PTR [esp],0x0
    int index_ = 0;
  10370d:	c7 44 24 20 00 00 00 	mov    DWORD PTR [esp+0x20],0x0
  103714:	00 
    if (x == 0)
  103715:	85 db                	test   ebx,ebx
  103717:	74 5b                	je     103774 <auto int_to_string<10, unsigned int>(unsigned int)+0xb4>
  103719:	31 f6                	xor    esi,esi
  10371b:	bf cd cc cc cc       	mov    edi,0xcccccccd
        x /= B;
  103720:	89 d8                	mov    eax,ebx
  103722:	f7 e7                	mul    edi
  103724:	c1 ea 03             	shr    edx,0x3
  103727:	8d 04 12             	lea    eax,[edx+edx*1]
  10372a:	8d 04 80             	lea    eax,[eax+eax*4]
  10372d:	89 d9                	mov    ecx,ebx
  10372f:	29 c1                	sub    ecx,eax
            return '0' + (x % B);
  103731:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  103734:	88 0c 34             	mov    BYTE PTR [esp+esi*1],cl
    for (; x > 0; a++) {
  103737:	46                   	inc    esi
  103738:	83 fb 09             	cmp    ebx,0x9
  10373b:	89 d3                	mov    ebx,edx
  10373d:	77 e1                	ja     103720 <auto int_to_string<10, unsigned int>(unsigned int)+0x60>
    r[a] = 0;
  10373f:	c6 04 34 00          	mov    BYTE PTR [esp+esi*1],0x0
    for (auto b = 0; b < a / 2; b++) {
  103743:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  103749:	74 2f                	je     10377a <auto int_to_string<10, unsigned int>(unsigned int)+0xba>
  10374b:	8d 44 34 ff          	lea    eax,[esp+esi*1-0x1]
  10374f:	d1 ee                	shr    esi,1
  103751:	89 e1                	mov    ecx,esp
  103753:	90                   	nop
  103754:	90                   	nop
  103755:	90                   	nop
  103756:	90                   	nop
  103757:	90                   	nop
  103758:	90                   	nop
  103759:	90                   	nop
  10375a:	90                   	nop
  10375b:	90                   	nop
  10375c:	90                   	nop
  10375d:	90                   	nop
  10375e:	90                   	nop
  10375f:	90                   	nop
        r[b] ^= r[a - b - 1];
  103760:	0f b6 11             	movzx  edx,BYTE PTR [ecx]
  103763:	32 10                	xor    dl,BYTE PTR [eax]
  103765:	88 11                	mov    BYTE PTR [ecx],dl
        r[a - b - 1] ^= r[b];
  103767:	32 10                	xor    dl,BYTE PTR [eax]
  103769:	88 10                	mov    BYTE PTR [eax],dl
        r[b] ^= r[a - b - 1];
  10376b:	30 11                	xor    BYTE PTR [ecx],dl
    for (auto b = 0; b < a / 2; b++) {
  10376d:	48                   	dec    eax
  10376e:	41                   	inc    ecx
  10376f:	4e                   	dec    esi
  103770:	75 ee                	jne    103760 <auto int_to_string<10, unsigned int>(unsigned int)+0xa0>
  103772:	eb 06                	jmp    10377a <auto int_to_string<10, unsigned int>(unsigned int)+0xba>
        r[a++] = '0';
  103774:	66 c7 04 24 30 00    	mov    WORD PTR [esp],0x30
  10377a:	89 e6                	mov    esi,esp
    return r;
  10377c:	b9 09 00 00 00       	mov    ecx,0x9
  103781:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  103784:	89 c7                	mov    edi,eax
  103786:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
}
  103788:	8d 65 f4             	lea    esp,[ebp-0xc]
  10378b:	5e                   	pop    esi
  10378c:	5f                   	pop    edi
  10378d:	5b                   	pop    ebx
  10378e:	5d                   	pop    ebp
  10378f:	c2 04 00             	ret    0x4
  103792:	cc                   	int3   
  103793:	cc                   	int3   
  103794:	cc                   	int3   
  103795:	cc                   	int3   
  103796:	cc                   	int3   
  103797:	cc                   	int3   
  103798:	cc                   	int3   
  103799:	cc                   	int3   
  10379a:	cc                   	int3   
  10379b:	cc                   	int3   
  10379c:	cc                   	int3   
  10379d:	cc                   	int3   
  10379e:	cc                   	int3   
  10379f:	cc                   	int3   

001037a0 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)>:
template <class... S> void write(S... p) {
  1037a0:	55                   	push   ebp
  1037a1:	89 e5                	mov    ebp,esp
  1037a3:	57                   	push   edi
  1037a4:	56                   	push   esi
  1037a5:	8b 75 0c             	mov    esi,DWORD PTR [ebp+0xc]
  1037a8:	8b 7d 08             	mov    edi,DWORD PTR [ebp+0x8]
    for (int a = 0; s[a] != 0; a++) {
  1037ab:	8a 07                	mov    al,BYTE PTR [edi]
  1037ad:	84 c0                	test   al,al
  1037af:	74 23                	je     1037d4 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)+0x34>
  1037b1:	47                   	inc    edi
  1037b2:	90                   	nop
  1037b3:	90                   	nop
  1037b4:	90                   	nop
  1037b5:	90                   	nop
  1037b6:	90                   	nop
  1037b7:	90                   	nop
  1037b8:	90                   	nop
  1037b9:	90                   	nop
  1037ba:	90                   	nop
  1037bb:	90                   	nop
  1037bc:	90                   	nop
  1037bd:	90                   	nop
  1037be:	90                   	nop
  1037bf:	90                   	nop
        write(s[a]);
  1037c0:	0f be c0             	movsx  eax,al
  1037c3:	50                   	push   eax
  1037c4:	e8 77 d9 ff ff       	call   101140 <term::write(char)>
  1037c9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  1037cc:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  1037cf:	47                   	inc    edi
  1037d0:	84 c0                	test   al,al
  1037d2:	75 ec                	jne    1037c0 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)+0x20>
  1037d4:	8b 7d 10             	mov    edi,DWORD PTR [ebp+0x10]
  1037d7:	8a 06                	mov    al,BYTE PTR [esi]
  1037d9:	84 c0                	test   al,al
  1037db:	74 17                	je     1037f4 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)+0x54>
  1037dd:	46                   	inc    esi
  1037de:	90                   	nop
  1037df:	90                   	nop
        write(s[a]);
  1037e0:	0f be c0             	movsx  eax,al
  1037e3:	50                   	push   eax
  1037e4:	e8 57 d9 ff ff       	call   101140 <term::write(char)>
  1037e9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  1037ec:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  1037ef:	46                   	inc    esi
  1037f0:	84 c0                	test   al,al
  1037f2:	75 ec                	jne    1037e0 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)+0x40>
  1037f4:	8b 75 14             	mov    esi,DWORD PTR [ebp+0x14]
  1037f7:	8a 07                	mov    al,BYTE PTR [edi]
  1037f9:	84 c0                	test   al,al
  1037fb:	74 17                	je     103814 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)+0x74>
  1037fd:	47                   	inc    edi
  1037fe:	90                   	nop
  1037ff:	90                   	nop
        write(s[a]);
  103800:	0f be c0             	movsx  eax,al
  103803:	50                   	push   eax
  103804:	e8 37 d9 ff ff       	call   101140 <term::write(char)>
  103809:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10380c:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  10380f:	47                   	inc    edi
  103810:	84 c0                	test   al,al
  103812:	75 ec                	jne    103800 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)+0x60>
  103814:	8b 7d 18             	mov    edi,DWORD PTR [ebp+0x18]
  103817:	8a 06                	mov    al,BYTE PTR [esi]
  103819:	84 c0                	test   al,al
  10381b:	74 17                	je     103834 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)+0x94>
  10381d:	46                   	inc    esi
  10381e:	90                   	nop
  10381f:	90                   	nop
        write(s[a]);
  103820:	0f be c0             	movsx  eax,al
  103823:	50                   	push   eax
  103824:	e8 17 d9 ff ff       	call   101140 <term::write(char)>
  103829:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10382c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10382f:	46                   	inc    esi
  103830:	84 c0                	test   al,al
  103832:	75 ec                	jne    103820 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)+0x80>
  103834:	8a 07                	mov    al,BYTE PTR [edi]
  103836:	84 c0                	test   al,al
  103838:	74 1a                	je     103854 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)+0xb4>
  10383a:	47                   	inc    edi
  10383b:	90                   	nop
  10383c:	90                   	nop
  10383d:	90                   	nop
  10383e:	90                   	nop
  10383f:	90                   	nop
        write(s[a]);
  103840:	0f be c0             	movsx  eax,al
  103843:	50                   	push   eax
  103844:	e8 f7 d8 ff ff       	call   101140 <term::write(char)>
  103849:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10384c:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  10384f:	47                   	inc    edi
  103850:	84 c0                	test   al,al
  103852:	75 ec                	jne    103840 <void term::write<char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*)+0xa0>
}
  103854:	5e                   	pop    esi
  103855:	5f                   	pop    edi
  103856:	5d                   	pop    ebp
  103857:	c3                   	ret    
  103858:	cc                   	int3   
  103859:	cc                   	int3   
  10385a:	cc                   	int3   
  10385b:	cc                   	int3   
  10385c:	cc                   	int3   
  10385d:	cc                   	int3   
  10385e:	cc                   	int3   
  10385f:	cc                   	int3   

00103860 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)>:
template <class... S> void write(S... p) {
  103860:	55                   	push   ebp
  103861:	89 e5                	mov    ebp,esp
  103863:	53                   	push   ebx
  103864:	57                   	push   edi
  103865:	56                   	push   esi
  103866:	83 ec 1c             	sub    esp,0x1c
  103869:	8b 45 18             	mov    eax,DWORD PTR [ebp+0x18]
  10386c:	8b 4d 14             	mov    ecx,DWORD PTR [ebp+0x14]
  10386f:	8b 5d 10             	mov    ebx,DWORD PTR [ebp+0x10]
  103872:	8b 75 0c             	mov    esi,DWORD PTR [ebp+0xc]
  103875:	8b 7d 08             	mov    edi,DWORD PTR [ebp+0x8]
    for (auto &a : {p...}) {
  103878:	89 7d d8             	mov    DWORD PTR [ebp-0x28],edi
  10387b:	89 75 dc             	mov    DWORD PTR [ebp-0x24],esi
  10387e:	89 5d e0             	mov    DWORD PTR [ebp-0x20],ebx
  103881:	89 4d e4             	mov    DWORD PTR [ebp-0x1c],ecx
  103884:	89 45 e8             	mov    DWORD PTR [ebp-0x18],eax
  103887:	8b 45 1c             	mov    eax,DWORD PTR [ebp+0x1c]
  10388a:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
  10388d:	8b 45 20             	mov    eax,DWORD PTR [ebp+0x20]
  103890:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
    for (int a = 0; s[a] != 0; a++) {
  103893:	8a 07                	mov    al,BYTE PTR [edi]
  103895:	84 c0                	test   al,al
  103897:	74 1b                	je     1038b4 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x54>
  103899:	47                   	inc    edi
  10389a:	90                   	nop
  10389b:	90                   	nop
  10389c:	90                   	nop
  10389d:	90                   	nop
  10389e:	90                   	nop
  10389f:	90                   	nop
        write(s[a]);
  1038a0:	0f be c0             	movsx  eax,al
  1038a3:	50                   	push   eax
  1038a4:	e8 97 d8 ff ff       	call   101140 <term::write(char)>
  1038a9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  1038ac:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  1038af:	47                   	inc    edi
  1038b0:	84 c0                	test   al,al
  1038b2:	75 ec                	jne    1038a0 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x40>
  1038b4:	8a 06                	mov    al,BYTE PTR [esi]
  1038b6:	84 c0                	test   al,al
  1038b8:	74 1a                	je     1038d4 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x74>
  1038ba:	46                   	inc    esi
  1038bb:	90                   	nop
  1038bc:	90                   	nop
  1038bd:	90                   	nop
  1038be:	90                   	nop
  1038bf:	90                   	nop
        write(s[a]);
  1038c0:	0f be c0             	movsx  eax,al
  1038c3:	50                   	push   eax
  1038c4:	e8 77 d8 ff ff       	call   101140 <term::write(char)>
  1038c9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  1038cc:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  1038cf:	46                   	inc    esi
  1038d0:	84 c0                	test   al,al
  1038d2:	75 ec                	jne    1038c0 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x60>
  1038d4:	8a 03                	mov    al,BYTE PTR [ebx]
  1038d6:	84 c0                	test   al,al
  1038d8:	8b 7d 14             	mov    edi,DWORD PTR [ebp+0x14]
  1038db:	74 17                	je     1038f4 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x94>
  1038dd:	43                   	inc    ebx
  1038de:	90                   	nop
  1038df:	90                   	nop
        write(s[a]);
  1038e0:	0f be c0             	movsx  eax,al
  1038e3:	50                   	push   eax
  1038e4:	e8 57 d8 ff ff       	call   101140 <term::write(char)>
  1038e9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  1038ec:	0f b6 03             	movzx  eax,BYTE PTR [ebx]
  1038ef:	43                   	inc    ebx
  1038f0:	84 c0                	test   al,al
  1038f2:	75 ec                	jne    1038e0 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x80>
  1038f4:	8a 07                	mov    al,BYTE PTR [edi]
  1038f6:	84 c0                	test   al,al
  1038f8:	8b 75 18             	mov    esi,DWORD PTR [ebp+0x18]
  1038fb:	74 17                	je     103914 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xb4>
  1038fd:	47                   	inc    edi
  1038fe:	90                   	nop
  1038ff:	90                   	nop
        write(s[a]);
  103900:	0f be c0             	movsx  eax,al
  103903:	50                   	push   eax
  103904:	e8 37 d8 ff ff       	call   101140 <term::write(char)>
  103909:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10390c:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  10390f:	47                   	inc    edi
  103910:	84 c0                	test   al,al
  103912:	75 ec                	jne    103900 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xa0>
  103914:	8a 06                	mov    al,BYTE PTR [esi]
  103916:	84 c0                	test   al,al
  103918:	74 1a                	je     103934 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xd4>
  10391a:	46                   	inc    esi
  10391b:	90                   	nop
  10391c:	90                   	nop
  10391d:	90                   	nop
  10391e:	90                   	nop
  10391f:	90                   	nop
        write(s[a]);
  103920:	0f be c0             	movsx  eax,al
  103923:	50                   	push   eax
  103924:	e8 17 d8 ff ff       	call   101140 <term::write(char)>
  103929:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10392c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10392f:	46                   	inc    esi
  103930:	84 c0                	test   al,al
  103932:	75 ec                	jne    103920 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xc0>
        write(a);
  103934:	8b 75 ec             	mov    esi,DWORD PTR [ebp-0x14]
    for (int a = 0; s[a] != 0; a++) {
  103937:	8a 06                	mov    al,BYTE PTR [esi]
  103939:	84 c0                	test   al,al
  10393b:	74 17                	je     103954 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xf4>
  10393d:	46                   	inc    esi
  10393e:	90                   	nop
  10393f:	90                   	nop
        write(s[a]);
  103940:	0f be c0             	movsx  eax,al
  103943:	50                   	push   eax
  103944:	e8 f7 d7 ff ff       	call   101140 <term::write(char)>
  103949:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10394c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10394f:	46                   	inc    esi
  103950:	84 c0                	test   al,al
  103952:	75 ec                	jne    103940 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xe0>
        write(a);
  103954:	8b 75 f0             	mov    esi,DWORD PTR [ebp-0x10]
    for (int a = 0; s[a] != 0; a++) {
  103957:	8a 06                	mov    al,BYTE PTR [esi]
  103959:	84 c0                	test   al,al
  10395b:	74 17                	je     103974 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x114>
  10395d:	46                   	inc    esi
  10395e:	90                   	nop
  10395f:	90                   	nop
        write(s[a]);
  103960:	0f be c0             	movsx  eax,al
  103963:	50                   	push   eax
  103964:	e8 d7 d7 ff ff       	call   101140 <term::write(char)>
  103969:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10396c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10396f:	46                   	inc    esi
  103970:	84 c0                	test   al,al
  103972:	75 ec                	jne    103960 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x100>
}
  103974:	83 c4 1c             	add    esp,0x1c
  103977:	5e                   	pop    esi
  103978:	5f                   	pop    edi
  103979:	5b                   	pop    ebx
  10397a:	5d                   	pop    ebp
  10397b:	c3                   	ret    
  10397c:	cc                   	int3   
  10397d:	cc                   	int3   
  10397e:	cc                   	int3   
  10397f:	cc                   	int3   

00103980 <void term::fatal_error<char const*>(char const*)>:
template <class... S>[[noreturn]] void fatal_error(S... msg) {
  103980:	55                   	push   ebp
  103981:	89 e5                	mov    ebp,esp
  103983:	56                   	push   esi
  103984:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
    for (int a = 0; s[a] != 0; a++) {
  103987:	8a 06                	mov    al,BYTE PTR [esi]
  103989:	84 c0                	test   al,al
  10398b:	74 17                	je     1039a4 <void term::fatal_error<char const*>(char const*)+0x24>
  10398d:	46                   	inc    esi
  10398e:	90                   	nop
  10398f:	90                   	nop
        write(s[a]);
  103990:	0f be c0             	movsx  eax,al
  103993:	50                   	push   eax
  103994:	e8 a7 d7 ff ff       	call   101140 <term::write(char)>
  103999:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10399c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10399f:	46                   	inc    esi
  1039a0:	84 c0                	test   al,al
  1039a2:	75 ec                	jne    103990 <void term::fatal_error<char const*>(char const*)+0x10>
    asm("hlt");
  1039a4:	f4                   	hlt    
  1039a5:	90                   	nop
  1039a6:	90                   	nop
  1039a7:	90                   	nop
  1039a8:	90                   	nop
  1039a9:	90                   	nop
  1039aa:	90                   	nop
  1039ab:	90                   	nop
  1039ac:	90                   	nop
  1039ad:	90                   	nop
  1039ae:	90                   	nop
  1039af:	90                   	nop
    while (true)
  1039b0:	eb fe                	jmp    1039b0 <void term::fatal_error<char const*>(char const*)+0x30>
  1039b2:	cc                   	int3   
  1039b3:	cc                   	int3   
  1039b4:	cc                   	int3   
  1039b5:	cc                   	int3   
  1039b6:	cc                   	int3   
  1039b7:	cc                   	int3   
  1039b8:	cc                   	int3   
  1039b9:	cc                   	int3   
  1039ba:	cc                   	int3   
  1039bb:	cc                   	int3   
  1039bc:	cc                   	int3   
  1039bd:	cc                   	int3   
  1039be:	cc                   	int3   
  1039bf:	cc                   	int3   

001039c0 <game_of_life::game_of_life()>:
    game_of_life() {
  1039c0:	55                   	push   ebp
  1039c1:	89 e5                	mov    ebp,esp
  1039c3:	53                   	push   ebx
  1039c4:	57                   	push   edi
  1039c5:	56                   	push   esi
  1039c6:	83 e4 f8             	and    esp,0xfffffff8
  1039c9:	81 ec e0 09 00 00    	sub    esp,0x9e0
  1039cf:	8b 7d 08             	mov    edi,DWORD PTR [ebp+0x8]
    int index_ = 0;
  1039d2:	8d b7 fc 00 00 00    	lea    esi,[edi+0xfc]
    constexpr array(U &&... p) : data_{static_cast<T>(p)...} {}
  1039d8:	68 fb 00 00 00       	push   0xfb
  1039dd:	6a 00                	push   0x0
  1039df:	57                   	push   edi
  1039e0:	e8 9b d8 ff ff       	call   101280 <memset>
  1039e5:	83 c4 0c             	add    esp,0xc
    int index_ = 0;
  1039e8:	c7 87 fc 01 00 00 00 	mov    DWORD PTR [edi+0x1fc],0x0
  1039ef:	00 00 00 
    constexpr array(U &&... p) : data_{static_cast<T>(p)...} {}
  1039f2:	68 ff 00 00 00       	push   0xff
  1039f7:	6a 00                	push   0x0
  1039f9:	56                   	push   esi
  1039fa:	e8 81 d8 ff ff       	call   101280 <memset>
  1039ff:	83 c4 0c             	add    esp,0xc
    int index_ = 0;
  103a02:	8d 44 24 18          	lea    eax,[esp+0x18]
  103a06:	68 bc 09 00 00       	push   0x9bc
  103a0b:	6a 00                	push   0x0
  103a0d:	50                   	push   eax
  103a0e:	e8 6d d8 ff ff       	call   101280 <memset>
  103a13:	83 c4 0c             	add    esp,0xc
        mt[0] = seed & static_cast<uint32>(~0);
  103a16:	c7 44 24 10 71 15 00 	mov    DWORD PTR [esp+0x10],0x1571
  103a1d:	00 
            mt[mti] =
  103a1e:	c7 44 24 14 96 ee 98 	mov    DWORD PTR [esp+0x14],0x4d98ee96
  103a25:	4d 
  103a26:	c7 44 24 18 95 f0 25 	mov    DWORD PTR [esp+0x18],0xaf25f095
  103a2d:	af 
  103a2e:	c7 84 24 d4 09 00 00 	mov    DWORD PTR [esp+0x9d4],0x3
  103a35:	03 00 00 00 
  103a39:	b9 02 00 00 00       	mov    ecx,0x2
  103a3e:	b8 03 00 00 00       	mov    eax,0x3
  103a43:	90                   	nop
  103a44:	90                   	nop
  103a45:	90                   	nop
  103a46:	90                   	nop
  103a47:	90                   	nop
  103a48:	90                   	nop
  103a49:	90                   	nop
  103a4a:	90                   	nop
  103a4b:	90                   	nop
  103a4c:	90                   	nop
  103a4d:	90                   	nop
  103a4e:	90                   	nop
  103a4f:	90                   	nop
                (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
  103a50:	8b 4c 8c 10          	mov    ecx,DWORD PTR [esp+ecx*4+0x10]
  103a54:	89 ca                	mov    edx,ecx
  103a56:	c1 ea 1e             	shr    edx,0x1e
  103a59:	31 ca                	xor    edx,ecx
  103a5b:	69 ca 65 89 07 6c    	imul   ecx,edx,0x6c078965
  103a61:	01 c1                	add    ecx,eax
            mt[mti] =
  103a63:	89 4c 84 10          	mov    DWORD PTR [esp+eax*4+0x10],ecx
            mt[mti] &= static_cast<uint32>(~0);
  103a67:	8b 8c 24 d4 09 00 00 	mov    ecx,DWORD PTR [esp+0x9d4]
        for (mti = 1; mti < N; mti++) {
  103a6e:	8d 41 01             	lea    eax,[ecx+0x1]
  103a71:	89 84 24 d4 09 00 00 	mov    DWORD PTR [esp+0x9d4],eax
  103a78:	3d 70 02 00 00       	cmp    eax,0x270
  103a7d:	72 d1                	jb     103a50 <game_of_life::game_of_life()+0x90>
  103a7f:	bb 64 00 00 00       	mov    ebx,0x64
  103a84:	8d 7c 24 10          	lea    edi,[esp+0x10]
  103a88:	90                   	nop
  103a89:	90                   	nop
  103a8a:	90                   	nop
  103a8b:	90                   	nop
  103a8c:	90                   	nop
  103a8d:	90                   	nop
  103a8e:	90                   	nop
  103a8f:	90                   	nop
                auto x=rnd.next()%width;
  103a90:	6a 00                	push   0x0
  103a92:	57                   	push   edi
  103a93:	e8 88 00 00 00       	call   103b20 <rand::random_gen::next(unsigned int)>
  103a98:	83 c4 08             	add    esp,0x8
  103a9b:	89 c6                	mov    esi,eax
  103a9d:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  103aa2:	f7 e1                	mul    ecx
  103aa4:	c1 ea 02             	shr    edx,0x2
  103aa7:	83 e2 f0             	and    edx,0xfffffff0
  103aaa:	8d 04 92             	lea    eax,[edx+edx*4]
  103aad:	29 c6                	sub    esi,eax
                auto y=rnd.next()%height;
  103aaf:	6a 00                	push   0x0
  103ab1:	57                   	push   edi
  103ab2:	e8 69 00 00 00       	call   103b20 <rand::random_gen::next(unsigned int)>
  103ab7:	83 c4 08             	add    esp,0x8
  103aba:	89 c1                	mov    ecx,eax
  103abc:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  103ac1:	f7 e2                	mul    edx
  103ac3:	c1 ea 03             	shr    edx,0x3
  103ac6:	8d 04 92             	lea    eax,[edx+edx*4]
  103ac9:	8d 04 80             	lea    eax,[eax+eax*4]
  103acc:	29 c1                	sub    ecx,eax
                board_[width * y + x]=1;
  103ace:	8d 04 89             	lea    eax,[ecx+ecx*4]
  103ad1:	c1 e0 04             	shl    eax,0x4
  103ad4:	01 f0                	add    eax,esi
        return bit_member(*this, static_cast<int>(i));
  103ad6:	50                   	push   eax
  103ad7:	ff 75 08             	push   DWORD PTR [ebp+0x8]
  103ada:	8d 44 24 08          	lea    eax,[esp+0x8]
  103ade:	50                   	push   eax
  103adf:	e8 bc 01 00 00       	call   103ca0 <mem::bit_sequence<2000u>::bit_member::bit_member(mem::bit_sequence<2000u>&, int)>
  103ae4:	83 c4 0c             	add    esp,0xc
            b_.bytes_[pos_ / 8] &= (p << (pos_ % 8));
  103ae7:	8b 34 24             	mov    esi,DWORD PTR [esp]
  103aea:	8b 44 24 04          	mov    eax,DWORD PTR [esp+0x4]
  103aee:	89 c1                	mov    ecx,eax
  103af0:	80 e1 07             	and    cl,0x7
  103af3:	ba 01 00 00 00       	mov    edx,0x1
  103af8:	d3 e2                	shl    edx,cl
  103afa:	8d 48 07             	lea    ecx,[eax+0x7]
  103afd:	85 c0                	test   eax,eax
  103aff:	0f 49 c8             	cmovns ecx,eax
  103b02:	c1 f9 03             	sar    ecx,0x3
  103b05:	20 14 0e             	and    BYTE PTR [esi+ecx*1],dl
            for(int a=0; a<100; a++) {
  103b08:	4b                   	dec    ebx
  103b09:	75 85                	jne    103a90 <game_of_life::game_of_life()+0xd0>
    }
  103b0b:	8d 65 f4             	lea    esp,[ebp-0xc]
  103b0e:	5e                   	pop    esi
  103b0f:	5f                   	pop    edi
  103b10:	5b                   	pop    ebx
  103b11:	5d                   	pop    ebp
  103b12:	c3                   	ret    
  103b13:	cc                   	int3   
  103b14:	cc                   	int3   
  103b15:	cc                   	int3   
  103b16:	cc                   	int3   
  103b17:	cc                   	int3   
  103b18:	cc                   	int3   
  103b19:	cc                   	int3   
  103b1a:	cc                   	int3   
  103b1b:	cc                   	int3   
  103b1c:	cc                   	int3   
  103b1d:	cc                   	int3   
  103b1e:	cc                   	int3   
  103b1f:	cc                   	int3   

00103b20 <rand::random_gen::next(unsigned int)>:
        }
    }

    uint32 next(uint32 limit = 0) {
  103b20:	55                   	push   ebp
  103b21:	89 e5                	mov    ebp,esp
  103b23:	53                   	push   ebx
  103b24:	57                   	push   edi
  103b25:	56                   	push   esi
  103b26:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
  103b29:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
        uint32 y = 0;

        if (mti >= N) { /* generate N words at one time */
  103b2c:	8b 90 c4 09 00 00    	mov    edx,DWORD PTR [eax+0x9c4]
  103b32:	81 fa 70 02 00 00    	cmp    edx,0x270
  103b38:	0f 82 d7 00 00 00    	jb     103c15 <rand::random_gen::next(unsigned int)+0xf5>
            uint32 kk = 0;

            for (; kk < N - M; kk++) {
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  103b3e:	8b 30                	mov    esi,DWORD PTR [eax]
  103b40:	ba 1d ff ff ff       	mov    edx,0xffffff1d
  103b45:	90                   	nop
  103b46:	90                   	nop
  103b47:	90                   	nop
  103b48:	90                   	nop
  103b49:	90                   	nop
  103b4a:	90                   	nop
  103b4b:	90                   	nop
  103b4c:	90                   	nop
  103b4d:	90                   	nop
  103b4e:	90                   	nop
  103b4f:	90                   	nop
  103b50:	81 e6 00 00 00 80    	and    esi,0x80000000
  103b56:	8b bc 90 90 03 00 00 	mov    edi,DWORD PTR [eax+edx*4+0x390]
  103b5d:	89 fb                	mov    ebx,edi
  103b5f:	81 e3 fe ff ff 7f    	and    ebx,0x7ffffffe
  103b65:	09 f3                	or     ebx,esi
                mt[kk] = mt[kk + M] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  103b67:	d1 eb                	shr    ebx,1
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  103b69:	89 fe                	mov    esi,edi
                mt[kk] = mt[kk + M] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  103b6b:	83 e7 01             	and    edi,0x1
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  103b6e:	8b 3c bd f0 00 10 00 	mov    edi,DWORD PTR [edi*4+0x1000f0]
  103b75:	33 bc 90 c0 09 00 00 	xor    edi,DWORD PTR [eax+edx*4+0x9c0]
  103b7c:	31 df                	xor    edi,ebx
  103b7e:	89 bc 90 8c 03 00 00 	mov    DWORD PTR [eax+edx*4+0x38c],edi
            for (; kk < N - M; kk++) {
  103b85:	42                   	inc    edx
  103b86:	75 c8                	jne    103b50 <rand::random_gen::next(unsigned int)+0x30>
            }
            for (; kk < N - 1; kk++) {
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  103b88:	8b b0 8c 03 00 00    	mov    esi,DWORD PTR [eax+0x38c]
  103b8e:	ba 74 fe ff ff       	mov    edx,0xfffffe74
  103b93:	90                   	nop
  103b94:	90                   	nop
  103b95:	90                   	nop
  103b96:	90                   	nop
  103b97:	90                   	nop
  103b98:	90                   	nop
  103b99:	90                   	nop
  103b9a:	90                   	nop
  103b9b:	90                   	nop
  103b9c:	90                   	nop
  103b9d:	90                   	nop
  103b9e:	90                   	nop
  103b9f:	90                   	nop
  103ba0:	81 e6 00 00 00 80    	and    esi,0x80000000
  103ba6:	8b bc 90 c0 09 00 00 	mov    edi,DWORD PTR [eax+edx*4+0x9c0]
  103bad:	89 fb                	mov    ebx,edi
  103baf:	81 e3 fe ff ff 7f    	and    ebx,0x7ffffffe
  103bb5:	09 f3                	or     ebx,esi
                mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  103bb7:	d1 eb                	shr    ebx,1
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  103bb9:	89 fe                	mov    esi,edi
                mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  103bbb:	83 e7 01             	and    edi,0x1
  103bbe:	8b 3c bd f0 00 10 00 	mov    edi,DWORD PTR [edi*4+0x1000f0]
  103bc5:	33 bc 90 30 06 00 00 	xor    edi,DWORD PTR [eax+edx*4+0x630]
  103bcc:	31 df                	xor    edi,ebx
  103bce:	89 bc 90 bc 09 00 00 	mov    DWORD PTR [eax+edx*4+0x9bc],edi
            for (; kk < N - 1; kk++) {
  103bd5:	42                   	inc    edx
  103bd6:	75 c8                	jne    103ba0 <rand::random_gen::next(unsigned int)+0x80>
  103bd8:	ba 00 00 00 80       	mov    edx,0x80000000
            }
            y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);
  103bdd:	23 90 bc 09 00 00    	and    edx,DWORD PTR [eax+0x9bc]
  103be3:	8b 30                	mov    esi,DWORD PTR [eax]
  103be5:	89 f7                	mov    edi,esi
  103be7:	81 e7 fe ff ff 7f    	and    edi,0x7ffffffe
  103bed:	09 d7                	or     edi,edx
            mt[N - 1] = mt[M - 1] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  103bef:	d1 ef                	shr    edi,1
  103bf1:	83 e6 01             	and    esi,0x1
  103bf4:	8b 14 b5 f0 00 10 00 	mov    edx,DWORD PTR [esi*4+0x1000f0]
  103bfb:	33 90 30 06 00 00    	xor    edx,DWORD PTR [eax+0x630]
  103c01:	31 fa                	xor    edx,edi
  103c03:	89 90 bc 09 00 00    	mov    DWORD PTR [eax+0x9bc],edx

            mti = 0;
  103c09:	c7 80 c4 09 00 00 00 	mov    DWORD PTR [eax+0x9c4],0x0
  103c10:	00 00 00 
  103c13:	31 d2                	xor    edx,edx
        }

        y = mt[mti++];
  103c15:	8d 72 01             	lea    esi,[edx+0x1]
  103c18:	89 b0 c4 09 00 00    	mov    DWORD PTR [eax+0x9c4],esi
  103c1e:	8b 04 90             	mov    eax,DWORD PTR [eax+edx*4]

        /* Tempering */
        y ^= (y >> 11);
  103c21:	89 c2                	mov    edx,eax
  103c23:	c1 ea 0b             	shr    edx,0xb
  103c26:	31 c2                	xor    edx,eax
        y ^= (y << 7) & 0x9d2c5680UL;
  103c28:	89 d0                	mov    eax,edx
  103c2a:	c1 e0 07             	shl    eax,0x7
  103c2d:	25 80 56 2c 9d       	and    eax,0x9d2c5680
  103c32:	31 d0                	xor    eax,edx
        y ^= (y << 15) & 0xefc60000UL;
  103c34:	89 c2                	mov    edx,eax
  103c36:	c1 e2 0f             	shl    edx,0xf
  103c39:	81 e2 00 00 c6 ef    	and    edx,0xefc60000
  103c3f:	31 c2                	xor    edx,eax
        y ^= (y >> 18);
  103c41:	89 d0                	mov    eax,edx
  103c43:	c1 e8 12             	shr    eax,0x12
  103c46:	31 d0                	xor    eax,edx

        if (limit == 0)
  103c48:	85 c9                	test   ecx,ecx
  103c4a:	74 06                	je     103c52 <rand::random_gen::next(unsigned int)+0x132>
            return y;
        else
            return y % limit;
  103c4c:	31 d2                	xor    edx,edx
  103c4e:	f7 f1                	div    ecx
  103c50:	89 d0                	mov    eax,edx
    }
  103c52:	5e                   	pop    esi
  103c53:	5f                   	pop    edi
  103c54:	5b                   	pop    ebx
  103c55:	5d                   	pop    ebp
  103c56:	c3                   	ret    
  103c57:	cc                   	int3   
  103c58:	cc                   	int3   
  103c59:	cc                   	int3   
  103c5a:	cc                   	int3   
  103c5b:	cc                   	int3   
  103c5c:	cc                   	int3   
  103c5d:	cc                   	int3   
  103c5e:	cc                   	int3   
  103c5f:	cc                   	int3   

00103c60 <mem::bit_sequence<1000u>::bit_member::bit_member(mem::bit_sequence<1000u>&, int)>:
            : b_(b), pos_(pos), val_(b[pos]) {}
  103c60:	55                   	push   ebp
  103c61:	89 e5                	mov    ebp,esp
  103c63:	56                   	push   esi
  103c64:	83 e4 f8             	and    esp,0xfffffff8
  103c67:	83 ec 10             	sub    esp,0x10
  103c6a:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
  103c6d:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
  103c70:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  103c73:	89 0e                	mov    DWORD PTR [esi],ecx
  103c75:	89 46 04             	mov    DWORD PTR [esi+0x4],eax
  103c78:	89 e2                	mov    edx,esp
        return bit_member(*this, static_cast<int>(i));
  103c7a:	50                   	push   eax
  103c7b:	51                   	push   ecx
  103c7c:	52                   	push   edx
  103c7d:	e8 de ff ff ff       	call   103c60 <mem::bit_sequence<1000u>::bit_member::bit_member(mem::bit_sequence<1000u>&, int)>
  103c82:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  103c85:	8a 44 24 08          	mov    al,BYTE PTR [esp+0x8]
            : b_(b), pos_(pos), val_(b[pos]) {}
  103c89:	88 46 08             	mov    BYTE PTR [esi+0x8],al
  103c8c:	8d 65 fc             	lea    esp,[ebp-0x4]
  103c8f:	5e                   	pop    esi
  103c90:	5d                   	pop    ebp
  103c91:	c3                   	ret    
  103c92:	cc                   	int3   
  103c93:	cc                   	int3   
  103c94:	cc                   	int3   
  103c95:	cc                   	int3   
  103c96:	cc                   	int3   
  103c97:	cc                   	int3   
  103c98:	cc                   	int3   
  103c99:	cc                   	int3   
  103c9a:	cc                   	int3   
  103c9b:	cc                   	int3   
  103c9c:	cc                   	int3   
  103c9d:	cc                   	int3   
  103c9e:	cc                   	int3   
  103c9f:	cc                   	int3   

00103ca0 <mem::bit_sequence<2000u>::bit_member::bit_member(mem::bit_sequence<2000u>&, int)>:
  103ca0:	55                   	push   ebp
  103ca1:	89 e5                	mov    ebp,esp
  103ca3:	56                   	push   esi
  103ca4:	83 e4 f8             	and    esp,0xfffffff8
  103ca7:	83 ec 10             	sub    esp,0x10
  103caa:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
  103cad:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
  103cb0:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  103cb3:	89 0e                	mov    DWORD PTR [esi],ecx
  103cb5:	89 46 04             	mov    DWORD PTR [esi+0x4],eax
  103cb8:	89 e2                	mov    edx,esp
        return bit_member(*this, static_cast<int>(i));
  103cba:	50                   	push   eax
  103cbb:	51                   	push   ecx
  103cbc:	52                   	push   edx
  103cbd:	e8 de ff ff ff       	call   103ca0 <mem::bit_sequence<2000u>::bit_member::bit_member(mem::bit_sequence<2000u>&, int)>
  103cc2:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  103cc5:	8a 44 24 08          	mov    al,BYTE PTR [esp+0x8]
            : b_(b), pos_(pos), val_(b[pos]) {}
  103cc9:	88 46 08             	mov    BYTE PTR [esi+0x8],al
  103ccc:	8d 65 fc             	lea    esp,[ebp-0x4]
  103ccf:	5e                   	pop    esi
  103cd0:	5d                   	pop    ebp
  103cd1:	c3                   	ret    
  103cd2:	cc                   	int3   
  103cd3:	cc                   	int3   
  103cd4:	cc                   	int3   
  103cd5:	cc                   	int3   
  103cd6:	cc                   	int3   
  103cd7:	cc                   	int3   
  103cd8:	cc                   	int3   
  103cd9:	cc                   	int3   
  103cda:	cc                   	int3   
  103cdb:	cc                   	int3   
  103cdc:	cc                   	int3   
  103cdd:	cc                   	int3   
  103cde:	cc                   	int3   
  103cdf:	cc                   	int3   

00103ce0 <game_of_life::step()>:
    void step() {
  103ce0:	55                   	push   ebp
  103ce1:	89 e5                	mov    ebp,esp
  103ce3:	53                   	push   ebx
  103ce4:	57                   	push   edi
  103ce5:	56                   	push   esi
  103ce6:	83 e4 f8             	and    esp,0xfffffff8
  103ce9:	83 ec 38             	sub    esp,0x38
  103cec:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
        term::clear();
  103cef:	e8 5c d3 ff ff       	call   101050 <term::clear()>
  103cf4:	81 c6 00 01 00 00    	add    esi,0x100
  103cfa:	31 db                	xor    ebx,ebx
  103cfc:	89 34 24             	mov    DWORD PTR [esp],esi
  103cff:	eb 1d                	jmp    103d1e <game_of_life::step()+0x3e>
  103d01:	90                   	nop
  103d02:	90                   	nop
  103d03:	90                   	nop
  103d04:	90                   	nop
  103d05:	90                   	nop
  103d06:	90                   	nop
  103d07:	90                   	nop
  103d08:	90                   	nop
  103d09:	90                   	nop
  103d0a:	90                   	nop
  103d0b:	90                   	nop
  103d0c:	90                   	nop
  103d0d:	90                   	nop
  103d0e:	90                   	nop
  103d0f:	90                   	nop
  103d10:	8b 5c 24 04          	mov    ebx,DWORD PTR [esp+0x4]
        for (int x = 0; x < width; x++) {
  103d14:	43                   	inc    ebx
  103d15:	83 fb 50             	cmp    ebx,0x50
  103d18:	0f 84 b2 00 00 00    	je     103dd0 <game_of_life::step()+0xf0>
  103d1e:	89 5c 24 04          	mov    DWORD PTR [esp+0x4],ebx
  103d22:	31 ff                	xor    edi,edi
  103d24:	eb 5e                	jmp    103d84 <game_of_life::step()+0xa4>
  103d26:	90                   	nop
  103d27:	90                   	nop
  103d28:	90                   	nop
  103d29:	90                   	nop
  103d2a:	90                   	nop
  103d2b:	90                   	nop
  103d2c:	90                   	nop
  103d2d:	90                   	nop
  103d2e:	90                   	nop
  103d2f:	90                   	nop
        return bit_member(*this, static_cast<int>(i));
  103d30:	53                   	push   ebx
  103d31:	56                   	push   esi
  103d32:	8d 44 24 20          	lea    eax,[esp+0x20]
  103d36:	50                   	push   eax
  103d37:	e8 64 ff ff ff       	call   103ca0 <mem::bit_sequence<2000u>::bit_member::bit_member(mem::bit_sequence<2000u>&, int)>
  103d3c:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  103d3f:	0f b6 74 24 20       	movzx  esi,BYTE PTR [esp+0x20]
        return bit_member(*this, static_cast<int>(i));
  103d44:	53                   	push   ebx
  103d45:	ff 74 24 04          	push   DWORD PTR [esp+0x4]
  103d49:	8d 44 24 10          	lea    eax,[esp+0x10]
  103d4d:	50                   	push   eax
  103d4e:	e8 4d ff ff ff       	call   103ca0 <mem::bit_sequence<2000u>::bit_member::bit_member(mem::bit_sequence<2000u>&, int)>
  103d53:	83 c4 0c             	add    esp,0xc
  103d56:	89 f0                	mov    eax,esi
            b_.bytes_[pos_ / 8] &= (p << (pos_ % 8));
  103d58:	83 f0 01             	xor    eax,0x1
  103d5b:	8b 74 24 08          	mov    esi,DWORD PTR [esp+0x8]
  103d5f:	8b 54 24 0c          	mov    edx,DWORD PTR [esp+0xc]
  103d63:	89 d1                	mov    ecx,edx
  103d65:	80 e1 07             	and    cl,0x7
  103d68:	d3 e0                	shl    eax,cl
  103d6a:	8d 4a 07             	lea    ecx,[edx+0x7]
  103d6d:	85 d2                	test   edx,edx
  103d6f:	0f 49 ca             	cmovns ecx,edx
  103d72:	c1 f9 03             	sar    ecx,0x3
  103d75:	20 04 0e             	and    BYTE PTR [esi+ecx*1],al
  103d78:	8b 34 24             	mov    esi,DWORD PTR [esp]
            for (int y = 0; y < height; y++) {
  103d7b:	47                   	inc    edi
  103d7c:	83 c3 50             	add    ebx,0x50
  103d7f:	83 ff 19             	cmp    edi,0x19
  103d82:	74 8c                	je     103d10 <game_of_life::step()+0x30>
        return bit_member(*this, static_cast<int>(i));
  103d84:	53                   	push   ebx
  103d85:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  103d88:	50                   	push   eax
  103d89:	8d 44 24 30          	lea    eax,[esp+0x30]
  103d8d:	50                   	push   eax
  103d8e:	e8 0d ff ff ff       	call   103ca0 <mem::bit_sequence<2000u>::bit_member::bit_member(mem::bit_sequence<2000u>&, int)>
  103d93:	83 c4 0c             	add    esp,0xc
                int n = neighbours(x, y);
  103d96:	57                   	push   edi
  103d97:	ff 74 24 08          	push   DWORD PTR [esp+0x8]
  103d9b:	ff 75 08             	push   DWORD PTR [ebp+0x8]
  103d9e:	e8 9d 00 00 00       	call   103e40 <game_of_life::neighbours(int, int) const>
  103da3:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  103da6:	80 7c 24 30 00       	cmp    BYTE PTR [esp+0x30],0x0
  103dab:	0f 94 c1             	sete   cl
                if ((c == 1 && (n < 2 || n > 3)) || (c == 0 && n == 3))
  103dae:	89 c2                	mov    edx,eax
  103db0:	83 e2 fe             	and    edx,0xfffffffe
  103db3:	83 fa 02             	cmp    edx,0x2
  103db6:	0f 94 c2             	sete   dl
  103db9:	83 f8 03             	cmp    eax,0x3
  103dbc:	0f 94 c0             	sete   al
  103dbf:	84 c8                	test   al,cl
  103dc1:	0f 85 69 ff ff ff    	jne    103d30 <game_of_life::step()+0x50>
  103dc7:	08 d1                	or     cl,dl
  103dc9:	75 b0                	jne    103d7b <game_of_life::step()+0x9b>
  103dcb:	e9 60 ff ff ff       	jmp    103d30 <game_of_life::step()+0x50>
  103dd0:	31 f6                	xor    esi,esi
  103dd2:	8d 7c 24 08          	lea    edi,[esp+0x8]
  103dd6:	90                   	nop
  103dd7:	90                   	nop
  103dd8:	90                   	nop
  103dd9:	90                   	nop
  103dda:	90                   	nop
  103ddb:	90                   	nop
  103ddc:	90                   	nop
  103ddd:	90                   	nop
  103dde:	90                   	nop
  103ddf:	90                   	nop
        return bit_member(*this, static_cast<int>(i));
  103de0:	56                   	push   esi
  103de1:	ff 74 24 04          	push   DWORD PTR [esp+0x4]
  103de5:	8d 44 24 20          	lea    eax,[esp+0x20]
  103de9:	50                   	push   eax
  103dea:	e8 b1 fe ff ff       	call   103ca0 <mem::bit_sequence<2000u>::bit_member::bit_member(mem::bit_sequence<2000u>&, int)>
  103def:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  103df2:	0f b6 5c 24 20       	movzx  ebx,BYTE PTR [esp+0x20]
        return bit_member(*this, static_cast<int>(i));
  103df7:	56                   	push   esi
  103df8:	ff 75 08             	push   DWORD PTR [ebp+0x8]
  103dfb:	57                   	push   edi
  103dfc:	e8 9f fe ff ff       	call   103ca0 <mem::bit_sequence<2000u>::bit_member::bit_member(mem::bit_sequence<2000u>&, int)>
  103e01:	83 c4 0c             	add    esp,0xc
            b_.bytes_[pos_ / 8] &= (p << (pos_ % 8));
  103e04:	8b 54 24 08          	mov    edx,DWORD PTR [esp+0x8]
  103e08:	8b 44 24 0c          	mov    eax,DWORD PTR [esp+0xc]
  103e0c:	89 c1                	mov    ecx,eax
  103e0e:	80 e1 07             	and    cl,0x7
  103e11:	d3 e3                	shl    ebx,cl
  103e13:	8d 48 07             	lea    ecx,[eax+0x7]
  103e16:	85 c0                	test   eax,eax
  103e18:	0f 49 c8             	cmovns ecx,eax
  103e1b:	c1 f9 03             	sar    ecx,0x3
  103e1e:	20 1c 0a             	and    BYTE PTR [edx+ecx*1],bl
        for (uint32 a = 0; a < board_.size(); a++) {
  103e21:	46                   	inc    esi
  103e22:	81 fe d0 07 00 00    	cmp    esi,0x7d0
  103e28:	75 b6                	jne    103de0 <game_of_life::step()+0x100>
    }
  103e2a:	8d 65 f4             	lea    esp,[ebp-0xc]
  103e2d:	5e                   	pop    esi
  103e2e:	5f                   	pop    edi
  103e2f:	5b                   	pop    ebx
  103e30:	5d                   	pop    ebp
  103e31:	c3                   	ret    
  103e32:	cc                   	int3   
  103e33:	cc                   	int3   
  103e34:	cc                   	int3   
  103e35:	cc                   	int3   
  103e36:	cc                   	int3   
  103e37:	cc                   	int3   
  103e38:	cc                   	int3   
  103e39:	cc                   	int3   
  103e3a:	cc                   	int3   
  103e3b:	cc                   	int3   
  103e3c:	cc                   	int3   
  103e3d:	cc                   	int3   
  103e3e:	cc                   	int3   
  103e3f:	cc                   	int3   

00103e40 <game_of_life::neighbours(int, int) const>:
        // screen.write(width + 1, 1, "Alive: " + str(alive));
        // screen.write(width + 1, 2, "Max alive: " + str(maxAlive));
        // screen.refresh();
    }

    int neighbours(int x, int y) const {
  103e40:	55                   	push   ebp
  103e41:	89 e5                	mov    ebp,esp
  103e43:	53                   	push   ebx
  103e44:	57                   	push   edi
  103e45:	56                   	push   esi
  103e46:	83 ec 08             	sub    esp,0x8
  103e49:	8b 75 10             	mov    esi,DWORD PTR [ebp+0x10]
  103e4c:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  103e4f:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
        int r = 0;
        if (x > 0) {
  103e52:	85 d2                	test   edx,edx
  103e54:	0f 8e 83 00 00 00    	jle    103edd <game_of_life::neighbours(int, int) const+0x9d>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  103e5a:	89 f0                	mov    eax,esi
  103e5c:	c1 e0 04             	shl    eax,0x4
  103e5f:	8d 3c 80             	lea    edi,[eax+eax*4]
  103e62:	8d 44 3a ff          	lea    eax,[edx+edi*1-0x1]
        auto b = bytes_[i / 8];
  103e66:	8d 5c 3a 06          	lea    ebx,[edx+edi*1+0x6]
  103e6a:	85 c0                	test   eax,eax
  103e6c:	0f 49 d8             	cmovns ebx,eax
  103e6f:	c1 fb 03             	sar    ebx,0x3
  103e72:	0f b6 1c 19          	movzx  ebx,BYTE PTR [ecx+ebx*1]
        return (b & (1 << (i % 8))) != 0;
  103e76:	24 07                	and    al,0x7
  103e78:	0f b6 c8             	movzx  ecx,al
  103e7b:	31 c0                	xor    eax,eax
  103e7d:	0f a3 cb             	bt     ebx,ecx
  103e80:	0f 92 c0             	setb   al
            r += board(x - 1, y);
            if (y > 0)
  103e83:	85 f6                	test   esi,esi
  103e85:	7e 29                	jle    103eb0 <game_of_life::neighbours(int, int) const+0x70>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  103e87:	8d 5c 3a af          	lea    ebx,[edx+edi*1-0x51]
        auto b = bytes_[i / 8];
  103e8b:	8d 4c 3a b6          	lea    ecx,[edx+edi*1-0x4a]
  103e8f:	85 db                	test   ebx,ebx
  103e91:	0f 49 cb             	cmovns ecx,ebx
  103e94:	c1 f9 03             	sar    ecx,0x3
  103e97:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  103e9a:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  103e9e:	80 e3 07             	and    bl,0x7
  103ea1:	0f b6 db             	movzx  ebx,bl
  103ea4:	0f a3 d9             	bt     ecx,ebx
                r += board(x - 1, y - 1);
  103ea7:	83 d0 00             	adc    eax,0x0
            if (y < height - 1)
  103eaa:	83 7d 10 17          	cmp    DWORD PTR [ebp+0x10],0x17
  103eae:	7f 23                	jg     103ed3 <game_of_life::neighbours(int, int) const+0x93>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  103eb0:	8d 5c 3a 4f          	lea    ebx,[edx+edi*1+0x4f]
        auto b = bytes_[i / 8];
  103eb4:	8d 4c 3a 56          	lea    ecx,[edx+edi*1+0x56]
  103eb8:	85 db                	test   ebx,ebx
  103eba:	0f 49 cb             	cmovns ecx,ebx
  103ebd:	c1 f9 03             	sar    ecx,0x3
  103ec0:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  103ec3:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  103ec7:	80 e3 07             	and    bl,0x7
  103eca:	0f b6 db             	movzx  ebx,bl
  103ecd:	0f a3 d9             	bt     ecx,ebx
                r += board(x - 1, y + 1);
  103ed0:	83 d0 00             	adc    eax,0x0
        }
        if (x < width - 1) {
  103ed3:	83 fa 4e             	cmp    edx,0x4e
  103ed6:	7e 0f                	jle    103ee7 <game_of_life::neighbours(int, int) const+0xa7>
  103ed8:	e9 a4 00 00 00       	jmp    103f81 <game_of_life::neighbours(int, int) const+0x141>
  103edd:	89 f0                	mov    eax,esi
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  103edf:	c1 e0 04             	shl    eax,0x4
  103ee2:	8d 3c 80             	lea    edi,[eax+eax*4]
  103ee5:	31 c0                	xor    eax,eax
  103ee7:	8d 5c 3a 01          	lea    ebx,[edx+edi*1+0x1]
        auto b = bytes_[i / 8];
  103eeb:	8d 4c 3a 08          	lea    ecx,[edx+edi*1+0x8]
  103eef:	85 db                	test   ebx,ebx
  103ef1:	0f 49 cb             	cmovns ecx,ebx
  103ef4:	c1 f9 03             	sar    ecx,0x3
  103ef7:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  103efa:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  103efe:	80 e3 07             	and    bl,0x7
  103f01:	0f b6 db             	movzx  ebx,bl
  103f04:	0f a3 d9             	bt     ecx,ebx
            r += board(x + 1, y);
  103f07:	83 d0 00             	adc    eax,0x0
  103f0a:	89 d1                	mov    ecx,edx
  103f0c:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
            if (y > 0)
  103f0f:	85 d2                	test   edx,edx
  103f11:	89 7d ec             	mov    DWORD PTR [ebp-0x14],edi
  103f14:	7e 3d                	jle    103f53 <game_of_life::neighbours(int, int) const+0x113>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  103f16:	8d 5c 39 b1          	lea    ebx,[ecx+edi*1-0x4f]
  103f1a:	89 c2                	mov    edx,eax
  103f1c:	89 f8                	mov    eax,edi
  103f1e:	89 cf                	mov    edi,ecx
        auto b = bytes_[i / 8];
  103f20:	8d 4c 01 b8          	lea    ecx,[ecx+eax*1-0x48]
  103f24:	85 db                	test   ebx,ebx
  103f26:	0f 49 cb             	cmovns ecx,ebx
  103f29:	c1 f9 03             	sar    ecx,0x3
  103f2c:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  103f30:	80 e3 07             	and    bl,0x7
  103f33:	0f b6 db             	movzx  ebx,bl
  103f36:	0f a3 d9             	bt     ecx,ebx
                r += board(x + 1, y - 1);
  103f39:	83 d2 00             	adc    edx,0x0
  103f3c:	89 55 f0             	mov    DWORD PTR [ebp-0x10],edx
            if (y < height - 1)
  103f3f:	83 7d 10 17          	cmp    DWORD PTR [ebp+0x10],0x17
  103f43:	7e 13                	jle    103f58 <game_of_life::neighbours(int, int) const+0x118>
  103f45:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  103f48:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
  103f4b:	8b 7d ec             	mov    edi,DWORD PTR [ebp-0x14]
  103f4e:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
  103f51:	eb 40                	jmp    103f93 <game_of_life::neighbours(int, int) const+0x153>
  103f53:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
  103f56:	89 cf                	mov    edi,ecx
  103f58:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  103f5b:	8d 5c 07 51          	lea    ebx,[edi+eax*1+0x51]
        auto b = bytes_[i / 8];
  103f5f:	8d 4c 07 58          	lea    ecx,[edi+eax*1+0x58]
  103f63:	85 db                	test   ebx,ebx
  103f65:	0f 49 cb             	cmovns ecx,ebx
  103f68:	c1 f9 03             	sar    ecx,0x3
  103f6b:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  103f6e:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  103f72:	80 e3 07             	and    bl,0x7
  103f75:	0f b6 fb             	movzx  edi,bl
  103f78:	0f a3 f9             	bt     ecx,edi
  103f7b:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
                r += board(x + 1, y + 1);
  103f7e:	83 d0 00             	adc    eax,0x0
  103f81:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
  103f84:	89 d1                	mov    ecx,edx
  103f86:	c1 e1 04             	shl    ecx,0x4
        }
        if (y > 0) {
  103f89:	85 d2                	test   edx,edx
  103f8b:	8d 3c 89             	lea    edi,[ecx+ecx*4]
  103f8e:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  103f91:	7e 28                	jle    103fbb <game_of_life::neighbours(int, int) const+0x17b>
  103f93:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  103f96:	8d 5c 39 b0          	lea    ebx,[ecx+edi*1-0x50]
        auto b = bytes_[i / 8];
  103f9a:	8d 4c 39 b7          	lea    ecx,[ecx+edi*1-0x49]
  103f9e:	85 db                	test   ebx,ebx
  103fa0:	0f 49 cb             	cmovns ecx,ebx
  103fa3:	c1 f9 03             	sar    ecx,0x3
  103fa6:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  103faa:	80 e3 07             	and    bl,0x7
  103fad:	0f b6 db             	movzx  ebx,bl
  103fb0:	0f a3 d9             	bt     ecx,ebx
            r += board(x, y - 1);
  103fb3:	83 d0 00             	adc    eax,0x0
        }
        if (y < height - 1) {
  103fb6:	83 fa 17             	cmp    edx,0x17
  103fb9:	7f 23                	jg     103fde <game_of_life::neighbours(int, int) const+0x19e>
  103fbb:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  103fbe:	8d 5c 39 50          	lea    ebx,[ecx+edi*1+0x50]
        auto b = bytes_[i / 8];
  103fc2:	8d 4c 39 57          	lea    ecx,[ecx+edi*1+0x57]
  103fc6:	85 db                	test   ebx,ebx
  103fc8:	0f 49 cb             	cmovns ecx,ebx
  103fcb:	c1 f9 03             	sar    ecx,0x3
  103fce:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  103fd2:	80 e3 07             	and    bl,0x7
  103fd5:	0f b6 d3             	movzx  edx,bl
  103fd8:	0f a3 d1             	bt     ecx,edx
            r += board(x, y + 1);
  103fdb:	83 d0 00             	adc    eax,0x0
        }
        return r;
  103fde:	83 c4 08             	add    esp,0x8
  103fe1:	5e                   	pop    esi
  103fe2:	5f                   	pop    edi
  103fe3:	5b                   	pop    ebx
  103fe4:	5d                   	pop    ebp
  103fe5:	c3                   	ret    
