
kernel.elf:     file format elf32-i386


Disassembly of section .text:

00101000 <start>:
  101000:	89 25 00 70 11 00    	mov    DWORD PTR ds:0x117000,esp
  101006:	50                   	push   eax
  101007:	53                   	push   ebx
  101008:	e8 63 0a 00 00       	call   101a70 <kernel_main>
  10100d:	f4                   	hlt    

0010100e <hang>:
  10100e:	eb fe                	jmp    10100e <hang>

00101010 <memset>:
    return static_cast<remove_ref<T> &&>(t);
}


/// Auto-referenced by clang for some big initializations.
extern "C" void *memset(void *dest, int ch, uint32 count) {
  101010:	55                   	push   ebp
  101011:	89 e5                	mov    ebp,esp
  101013:	56                   	push   esi
  101014:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
  101017:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
    for (uint32 a = 0; a < count; a++)
  10101a:	85 c9                	test   ecx,ecx
  10101c:	74 18                	je     101036 <memset+0x26>
  10101e:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  101021:	89 c6                	mov    esi,eax
  101023:	90                   	nop
  101024:	90                   	nop
  101025:	90                   	nop
  101026:	90                   	nop
  101027:	90                   	nop
  101028:	90                   	nop
  101029:	90                   	nop
  10102a:	90                   	nop
  10102b:	90                   	nop
  10102c:	90                   	nop
  10102d:	90                   	nop
  10102e:	90                   	nop
  10102f:	90                   	nop
        reinterpret_cast<uint8 *>(dest)[a] = static_cast<uint8>(ch);
  101030:	88 16                	mov    BYTE PTR [esi],dl
    for (uint32 a = 0; a < count; a++)
  101032:	46                   	inc    esi
  101033:	49                   	dec    ecx
  101034:	75 fa                	jne    101030 <memset+0x20>
    return dest;
  101036:	5e                   	pop    esi
  101037:	5d                   	pop    ebp
  101038:	c3                   	ret    
  101039:	90                   	nop
  10103a:	90                   	nop
  10103b:	90                   	nop
  10103c:	90                   	nop
  10103d:	90                   	nop
  10103e:	90                   	nop
  10103f:	90                   	nop

00101040 <halt()>:
static_assert(test_string2.extract_word(0).value == "xy" &&
              test_string2.extract_word(1) &&
              test_string2.extract_word(1).value == "z");
} // namespace

[[noreturn]] void halt() {
  101040:	55                   	push   ebp
  101041:	89 e5                	mov    ebp,esp
    asm("hlt");
  101043:	f4                   	hlt    
  101044:	90                   	nop
  101045:	90                   	nop
  101046:	90                   	nop
  101047:	90                   	nop
  101048:	90                   	nop
  101049:	90                   	nop
  10104a:	90                   	nop
  10104b:	90                   	nop
  10104c:	90                   	nop
  10104d:	90                   	nop
  10104e:	90                   	nop
  10104f:	90                   	nop
    while (true)
  101050:	eb fe                	jmp    101050 <halt()+0x10>
  101052:	90                   	nop
  101053:	90                   	nop
  101054:	90                   	nop
  101055:	90                   	nop
  101056:	90                   	nop
  101057:	90                   	nop
  101058:	90                   	nop
  101059:	90                   	nop
  10105a:	90                   	nop
  10105b:	90                   	nop
  10105c:	90                   	nop
  10105d:	90                   	nop
  10105e:	90                   	nop
  10105f:	90                   	nop

00101060 <term::set(int, unsigned char, char)>:

constexpr auto index(int col = terminal.col, int row = terminal.row) {
    return (max_col * row) + col;
}

void set(int index, uint8 colour, char symbol) {
  101060:	55                   	push   ebp
  101061:	89 e5                	mov    ebp,esp
  101063:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  101066:	0f be 4d 10          	movsx  ecx,BYTE PTR [ebp+0x10]
    VGA_BUF[index] = static_cast<uint16>((colour << 8) | symbol);
  10106a:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  10106d:	c1 e2 08             	shl    edx,0x8
  101070:	09 ca                	or     edx,ecx
  101072:	8b 0d 00 60 10 00    	mov    ecx,DWORD PTR ds:0x106000
  101078:	66 89 14 41          	mov    WORD PTR [ecx+eax*2],dx
}
  10107c:	5d                   	pop    ebp
  10107d:	c3                   	ret    
  10107e:	90                   	nop
  10107f:	90                   	nop

00101080 <term::clear()>:

void clear() {
  101080:	55                   	push   ebp
  101081:	89 e5                	mov    ebp,esp
  101083:	a1 0c 60 10 00       	mov    eax,ds:0x10600c
  101088:	c1 e0 08             	shl    eax,0x8
  10108b:	83 c8 20             	or     eax,0x20
  10108e:	b9 00 0f 00 00       	mov    ecx,0xf00
    for (int a = 0; a < max_col; a++) {
  101093:	03 0d 00 60 10 00    	add    ecx,DWORD PTR ds:0x106000
  101099:	ba b0 ff ff ff       	mov    edx,0xffffffb0
  10109e:	90                   	nop
  10109f:	90                   	nop
    VGA_BUF[index] = static_cast<uint16>((colour << 8) | symbol);
  1010a0:	66 89 84 51 a0 f1 ff 	mov    WORD PTR [ecx+edx*2-0xe60],ax
  1010a7:	ff 
  1010a8:	66 89 84 51 40 f2 ff 	mov    WORD PTR [ecx+edx*2-0xdc0],ax
  1010af:	ff 
  1010b0:	66 89 84 51 e0 f2 ff 	mov    WORD PTR [ecx+edx*2-0xd20],ax
  1010b7:	ff 
  1010b8:	66 89 84 51 80 f3 ff 	mov    WORD PTR [ecx+edx*2-0xc80],ax
  1010bf:	ff 
  1010c0:	66 89 84 51 20 f4 ff 	mov    WORD PTR [ecx+edx*2-0xbe0],ax
  1010c7:	ff 
  1010c8:	66 89 84 51 c0 f4 ff 	mov    WORD PTR [ecx+edx*2-0xb40],ax
  1010cf:	ff 
  1010d0:	66 89 84 51 60 f5 ff 	mov    WORD PTR [ecx+edx*2-0xaa0],ax
  1010d7:	ff 
  1010d8:	66 89 84 51 00 f6 ff 	mov    WORD PTR [ecx+edx*2-0xa00],ax
  1010df:	ff 
  1010e0:	66 89 84 51 a0 f6 ff 	mov    WORD PTR [ecx+edx*2-0x960],ax
  1010e7:	ff 
  1010e8:	66 89 84 51 40 f7 ff 	mov    WORD PTR [ecx+edx*2-0x8c0],ax
  1010ef:	ff 
  1010f0:	66 89 84 51 e0 f7 ff 	mov    WORD PTR [ecx+edx*2-0x820],ax
  1010f7:	ff 
  1010f8:	66 89 84 51 80 f8 ff 	mov    WORD PTR [ecx+edx*2-0x780],ax
  1010ff:	ff 
  101100:	66 89 84 51 20 f9 ff 	mov    WORD PTR [ecx+edx*2-0x6e0],ax
  101107:	ff 
  101108:	66 89 84 51 c0 f9 ff 	mov    WORD PTR [ecx+edx*2-0x640],ax
  10110f:	ff 
  101110:	66 89 84 51 60 fa ff 	mov    WORD PTR [ecx+edx*2-0x5a0],ax
  101117:	ff 
  101118:	66 89 84 51 00 fb ff 	mov    WORD PTR [ecx+edx*2-0x500],ax
  10111f:	ff 
  101120:	66 89 84 51 a0 fb ff 	mov    WORD PTR [ecx+edx*2-0x460],ax
  101127:	ff 
  101128:	66 89 84 51 40 fc ff 	mov    WORD PTR [ecx+edx*2-0x3c0],ax
  10112f:	ff 
  101130:	66 89 84 51 e0 fc ff 	mov    WORD PTR [ecx+edx*2-0x320],ax
  101137:	ff 
  101138:	66 89 84 51 80 fd ff 	mov    WORD PTR [ecx+edx*2-0x280],ax
  10113f:	ff 
  101140:	66 89 84 51 20 fe ff 	mov    WORD PTR [ecx+edx*2-0x1e0],ax
  101147:	ff 
  101148:	66 89 84 51 c0 fe ff 	mov    WORD PTR [ecx+edx*2-0x140],ax
  10114f:	ff 
  101150:	66 89 84 51 60 ff ff 	mov    WORD PTR [ecx+edx*2-0xa0],ax
  101157:	ff 
  101158:	66 89 04 51          	mov    WORD PTR [ecx+edx*2],ax
  10115c:	66 89 84 51 a0 00 00 	mov    WORD PTR [ecx+edx*2+0xa0],ax
  101163:	00 
    for (int a = 0; a < max_col; a++) {
  101164:	42                   	inc    edx
  101165:	0f 85 35 ff ff ff    	jne    1010a0 <term::clear()+0x20>
        for (int b = 0; b < max_row; b++) {
            set(index(a, b), terminal.colour, ' ');
        }
    }
}
  10116b:	5d                   	pop    ebp
  10116c:	c3                   	ret    
  10116d:	90                   	nop
  10116e:	90                   	nop
  10116f:	90                   	nop

00101170 <term::write(char)>:

void write(char c) {
  101170:	55                   	push   ebp
  101171:	89 e5                	mov    ebp,esp
    switch (c) {
  101173:	0f be 45 08          	movsx  eax,BYTE PTR [ebp+0x8]
  101177:	83 f8 09             	cmp    eax,0x9
  10117a:	74 43                	je     1011bf <term::write(char)+0x4f>
  10117c:	83 f8 0a             	cmp    eax,0xa
  10117f:	75 59                	jne    1011da <term::write(char)+0x6a>
        if (!flipped) {
  101181:	80 3d 0d 60 10 00 00 	cmp    BYTE PTR ds:0x10600d,0x0
  101188:	0f 84 95 00 00 00    	je     101223 <term::write(char)+0xb3>
            increment_cursor(row, col, max_row, max_col, max_row - (row % max_row));
  10118e:	8b 0d 08 60 10 00    	mov    ecx,DWORD PTR ds:0x106008
  101194:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  101199:	89 c8                	mov    eax,ecx
  10119b:	f7 ea                	imul   edx
  10119d:	89 d0                	mov    eax,edx
  10119f:	c1 e8 1f             	shr    eax,0x1f
  1011a2:	c1 fa 03             	sar    edx,0x3
  1011a5:	01 c2                	add    edx,eax
  1011a7:	8d 04 92             	lea    eax,[edx+edx*4]
  1011aa:	8d 04 80             	lea    eax,[eax+eax*4]
  1011ad:	29 c8                	sub    eax,ecx
  1011af:	83 c0 19             	add    eax,0x19
  1011b2:	b9 08 60 10 00       	mov    ecx,0x106008
  1011b7:	ba 04 60 10 00       	mov    edx,0x106004
  1011bc:	50                   	push   eax
  1011bd:	eb 56                	jmp    101215 <term::write(char)+0xa5>
        if (!flipped) {
  1011bf:	80 3d 0d 60 10 00 00 	cmp    BYTE PTR ds:0x10600d,0x0
  1011c6:	0f 84 88 00 00 00    	je     101254 <term::write(char)+0xe4>
            increment_cursor(row, col, max_row, max_col, n);
  1011cc:	b9 08 60 10 00       	mov    ecx,0x106008
  1011d1:	ba 04 60 10 00       	mov    edx,0x106004
  1011d6:	6a 04                	push   0x4
  1011d8:	eb 3b                	jmp    101215 <term::write(char)+0xa5>
        break;
    case '\t':
        terminal.advance(4);
        break;
    default:
        set(index(), terminal.colour, c);
  1011da:	8b 0d 08 60 10 00    	mov    ecx,DWORD PTR ds:0x106008
    return (max_col * row) + col;
  1011e0:	8d 0c 89             	lea    ecx,[ecx+ecx*4]
  1011e3:	c1 e1 04             	shl    ecx,0x4
  1011e6:	03 0d 04 60 10 00    	add    ecx,DWORD PTR ds:0x106004
    VGA_BUF[index] = static_cast<uint16>((colour << 8) | symbol);
  1011ec:	8b 15 0c 60 10 00    	mov    edx,DWORD PTR ds:0x10600c
  1011f2:	c1 e2 08             	shl    edx,0x8
  1011f5:	09 c2                	or     edx,eax
  1011f7:	a1 00 60 10 00       	mov    eax,ds:0x106000
  1011fc:	66 89 14 48          	mov    WORD PTR [eax+ecx*2],dx
        if (!flipped) {
  101200:	80 3d 0d 60 10 00 00 	cmp    BYTE PTR ds:0x10600d,0x0
  101207:	74 59                	je     101262 <term::write(char)+0xf2>
            increment_cursor(row, col, max_row, max_col, n);
  101209:	b9 08 60 10 00       	mov    ecx,0x106008
  10120e:	ba 04 60 10 00       	mov    edx,0x106004
  101213:	6a 01                	push   0x1
  101215:	6a 50                	push   0x50
  101217:	6a 19                	push   0x19
  101219:	e8 12 26 00 00       	call   103830 <term::$_2::increment_cursor(int&, int&, int, int, int)>
  10121e:	83 c4 0c             	add    esp,0xc
        terminal.advance();
        break;
    }
}
  101221:	5d                   	pop    ebp
  101222:	c3                   	ret    
            increment_cursor(col, row, max_col, max_row, max_col - (col % max_col));
  101223:	8b 0d 04 60 10 00    	mov    ecx,DWORD PTR ds:0x106004
  101229:	ba 67 66 66 66       	mov    edx,0x66666667
  10122e:	89 c8                	mov    eax,ecx
  101230:	f7 ea                	imul   edx
  101232:	89 d0                	mov    eax,edx
  101234:	c1 e8 1f             	shr    eax,0x1f
  101237:	c1 fa 05             	sar    edx,0x5
  10123a:	01 c2                	add    edx,eax
  10123c:	c1 e2 04             	shl    edx,0x4
  10123f:	8d 04 92             	lea    eax,[edx+edx*4]
  101242:	29 c8                	sub    eax,ecx
  101244:	83 c0 50             	add    eax,0x50
  101247:	b9 04 60 10 00       	mov    ecx,0x106004
  10124c:	ba 08 60 10 00       	mov    edx,0x106008
  101251:	50                   	push   eax
  101252:	eb 1a                	jmp    10126e <term::write(char)+0xfe>
            increment_cursor(col, row, max_col, max_row, n);
  101254:	b9 04 60 10 00       	mov    ecx,0x106004
  101259:	ba 08 60 10 00       	mov    edx,0x106008
  10125e:	6a 04                	push   0x4
  101260:	eb 0c                	jmp    10126e <term::write(char)+0xfe>
  101262:	b9 04 60 10 00       	mov    ecx,0x106004
  101267:	ba 08 60 10 00       	mov    edx,0x106008
  10126c:	6a 01                	push   0x1
  10126e:	6a 19                	push   0x19
  101270:	6a 50                	push   0x50
  101272:	e8 b9 25 00 00       	call   103830 <term::$_2::increment_cursor(int&, int&, int, int, int)>
  101277:	83 c4 0c             	add    esp,0xc
}
  10127a:	5d                   	pop    ebp
  10127b:	c3                   	ret    
  10127c:	90                   	nop
  10127d:	90                   	nop
  10127e:	90                   	nop
  10127f:	90                   	nop

00101280 <term::write(char const*)>:

void write(const char *s) {
  101280:	55                   	push   ebp
  101281:	89 e5                	mov    ebp,esp
  101283:	56                   	push   esi
  101284:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
    for (int a = 0; s[a] != 0; a++) {
  101287:	8a 06                	mov    al,BYTE PTR [esi]
  101289:	84 c0                	test   al,al
  10128b:	74 17                	je     1012a4 <term::write(char const*)+0x24>
  10128d:	46                   	inc    esi
  10128e:	90                   	nop
  10128f:	90                   	nop
        write(s[a]);
  101290:	0f be c0             	movsx  eax,al
  101293:	50                   	push   eax
  101294:	e8 d7 fe ff ff       	call   101170 <term::write(char)>
  101299:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10129c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10129f:	46                   	inc    esi
  1012a0:	84 c0                	test   al,al
  1012a2:	75 ec                	jne    101290 <term::write(char const*)+0x10>
    }
}
  1012a4:	5e                   	pop    esi
  1012a5:	5d                   	pop    ebp
  1012a6:	c3                   	ret    
  1012a7:	90                   	nop
  1012a8:	90                   	nop
  1012a9:	90                   	nop
  1012aa:	90                   	nop
  1012ab:	90                   	nop
  1012ac:	90                   	nop
  1012ad:	90                   	nop
  1012ae:	90                   	nop
  1012af:	90                   	nop

001012b0 <io::send(unsigned short, unsigned char)>:
#pragma once
#include "core.hpp"

namespace io {
void send(uint16 port, uint8 byte) {
  1012b0:	55                   	push   ebp
  1012b1:	89 e5                	mov    ebp,esp
  1012b3:	0f b7 55 08          	movzx  edx,WORD PTR [ebp+0x8]
  1012b7:	8a 45 0c             	mov    al,BYTE PTR [ebp+0xc]
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1012ba:	ee                   	out    dx,al
}
  1012bb:	5d                   	pop    ebp
  1012bc:	c3                   	ret    
  1012bd:	90                   	nop
  1012be:	90                   	nop
  1012bf:	90                   	nop

001012c0 <io::receive(unsigned short)>:

uint8 receive(uint16 port) {
  1012c0:	55                   	push   ebp
  1012c1:	89 e5                	mov    ebp,esp
  1012c3:	0f b7 55 08          	movzx  edx,WORD PTR [ebp+0x8]
    uint8 r;
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1012c7:	ec                   	in     al,dx
    return r;
  1012c8:	5d                   	pop    ebp
  1012c9:	c3                   	ret    
  1012ca:	90                   	nop
  1012cb:	90                   	nop
  1012cc:	90                   	nop
  1012cd:	90                   	nop
  1012ce:	90                   	nop
  1012cf:	90                   	nop

001012d0 <ps2::read_config()>:
 * Specialized send/receive functions with timeout
 */
// void send(uint16 port, uint8 byte);
// uint8 receive(uint16 port);

uint8 read_config() {
  1012d0:	55                   	push   ebp
  1012d1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1012d3:	66 ba 64 00          	mov    dx,0x64
  1012d7:	b0 20                	mov    al,0x20
  1012d9:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1012da:	66 ba 60 00          	mov    dx,0x60
  1012de:	ec                   	in     al,dx
    /*5 	    Second PS/2 port clock (1 = disabled, 0 = enabled, only if 2
     * PS/2 ports supported)*/
    /*6 	    First PS/2 port translation (1 = enabled, 0 = disabled)*/
    /*7       Must be zero*/
    send(COMMAND, 0x20);
    return receive(DATA);
  1012df:	5d                   	pop    ebp
  1012e0:	c3                   	ret    
  1012e1:	90                   	nop
  1012e2:	90                   	nop
  1012e3:	90                   	nop
  1012e4:	90                   	nop
  1012e5:	90                   	nop
  1012e6:	90                   	nop
  1012e7:	90                   	nop
  1012e8:	90                   	nop
  1012e9:	90                   	nop
  1012ea:	90                   	nop
  1012eb:	90                   	nop
  1012ec:	90                   	nop
  1012ed:	90                   	nop
  1012ee:	90                   	nop
  1012ef:	90                   	nop

001012f0 <ps2::write_config(unsigned char)>:
}
void write_config(uint8 byte) {
  1012f0:	55                   	push   ebp
  1012f1:	89 e5                	mov    ebp,esp
  1012f3:	8a 4d 08             	mov    cl,BYTE PTR [ebp+0x8]
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1012f6:	66 ba 64 00          	mov    dx,0x64
  1012fa:	b0 60                	mov    al,0x60
  1012fc:	ee                   	out    dx,al
  1012fd:	66 ba 60 00          	mov    dx,0x60
  101301:	89 c8                	mov    eax,ecx
  101303:	ee                   	out    dx,al
    send(COMMAND, 0x60);
    send(DATA, byte);
}
  101304:	5d                   	pop    ebp
  101305:	c3                   	ret    
  101306:	90                   	nop
  101307:	90                   	nop
  101308:	90                   	nop
  101309:	90                   	nop
  10130a:	90                   	nop
  10130b:	90                   	nop
  10130c:	90                   	nop
  10130d:	90                   	nop
  10130e:	90                   	nop
  10130f:	90                   	nop

00101310 <ps2::status()>:

uint8 status() { return receive(COMMAND); }
  101310:	55                   	push   ebp
  101311:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101313:	66 ba 64 00          	mov    dx,0x64
  101317:	ec                   	in     al,dx
uint8 status() { return receive(COMMAND); }
  101318:	5d                   	pop    ebp
  101319:	c3                   	ret    
  10131a:	90                   	nop
  10131b:	90                   	nop
  10131c:	90                   	nop
  10131d:	90                   	nop
  10131e:	90                   	nop
  10131f:	90                   	nop

00101320 <ps2::has_output_data()>:
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101320:	55                   	push   ebp
  101321:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101323:	66 ba 64 00          	mov    dx,0x64
  101327:	ec                   	in     al,dx
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101328:	24 01                	and    al,0x1
  10132a:	5d                   	pop    ebp
  10132b:	c3                   	ret    
  10132c:	90                   	nop
  10132d:	90                   	nop
  10132e:	90                   	nop
  10132f:	90                   	nop

00101330 <ps2::has_input_data()>:
bool has_input_data() { return (status() & 0b00000010) != 0; }
  101330:	55                   	push   ebp
  101331:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101333:	66 ba 64 00          	mov    dx,0x64
  101337:	ec                   	in     al,dx
bool has_input_data() { return (status() & 0b00000010) != 0; }
  101338:	24 02                	and    al,0x2
  10133a:	d0 e8                	shr    al,1
  10133c:	5d                   	pop    ebp
  10133d:	c3                   	ret    
  10133e:	90                   	nop
  10133f:	90                   	nop

00101340 <ps2::writing_to_controller()>:
bool writing_to_controller() { return (status() & 0b00001000) != 0; }
  101340:	55                   	push   ebp
  101341:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101343:	66 ba 64 00          	mov    dx,0x64
  101347:	ec                   	in     al,dx
bool writing_to_controller() { return (status() & 0b00001000) != 0; }
  101348:	24 08                	and    al,0x8
  10134a:	c0 e8 03             	shr    al,0x3
  10134d:	5d                   	pop    ebp
  10134e:	c3                   	ret    
  10134f:	90                   	nop

00101350 <ps2::got_timeout_error()>:
bool got_timeout_error() { return (status() & 0b010000000) != 0; }
  101350:	55                   	push   ebp
  101351:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101353:	66 ba 64 00          	mov    dx,0x64
  101357:	ec                   	in     al,dx
bool got_timeout_error() { return (status() & 0b010000000) != 0; }
  101358:	c0 e8 07             	shr    al,0x7
  10135b:	5d                   	pop    ebp
  10135c:	c3                   	ret    
  10135d:	90                   	nop
  10135e:	90                   	nop
  10135f:	90                   	nop

00101360 <ps2::got_parity_error()>:
bool got_parity_error() { return (status() & 0b10000000) != 0; }
  101360:	55                   	push   ebp
  101361:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101363:	66 ba 64 00          	mov    dx,0x64
  101367:	ec                   	in     al,dx
bool got_parity_error() { return (status() & 0b10000000) != 0; }
  101368:	c0 e8 07             	shr    al,0x7
  10136b:	5d                   	pop    ebp
  10136c:	c3                   	ret    
  10136d:	90                   	nop
  10136e:	90                   	nop
  10136f:	90                   	nop

00101370 <ps2::read_output_port()>:

uint8 read_output_port() {
  101370:	55                   	push   ebp
  101371:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101373:	66 ba 64 00          	mov    dx,0x64
  101377:	b0 d0                	mov    al,0xd0
  101379:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10137a:	66 ba 60 00          	mov    dx,0x60
  10137e:	ec                   	in     al,dx
    send(COMMAND, 0xD0);
    return receive(DATA);
  10137f:	5d                   	pop    ebp
  101380:	c3                   	ret    
  101381:	90                   	nop
  101382:	90                   	nop
  101383:	90                   	nop
  101384:	90                   	nop
  101385:	90                   	nop
  101386:	90                   	nop
  101387:	90                   	nop
  101388:	90                   	nop
  101389:	90                   	nop
  10138a:	90                   	nop
  10138b:	90                   	nop
  10138c:	90                   	nop
  10138d:	90                   	nop
  10138e:	90                   	nop
  10138f:	90                   	nop

00101390 <ps2::test_controller()>:
}

bool test_controller() {
  101390:	55                   	push   ebp
  101391:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101393:	66 ba 64 00          	mov    dx,0x64
  101397:	b0 aa                	mov    al,0xaa
  101399:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10139a:	66 ba 60 00          	mov    dx,0x60
  10139e:	ec                   	in     al,dx
    send(COMMAND, 0xAA);
    return receive(DATA) == 0x55;
  10139f:	3c 55                	cmp    al,0x55
  1013a1:	0f 94 c0             	sete   al
  1013a4:	5d                   	pop    ebp
  1013a5:	c3                   	ret    
  1013a6:	90                   	nop
  1013a7:	90                   	nop
  1013a8:	90                   	nop
  1013a9:	90                   	nop
  1013aa:	90                   	nop
  1013ab:	90                   	nop
  1013ac:	90                   	nop
  1013ad:	90                   	nop
  1013ae:	90                   	nop
  1013af:	90                   	nop

001013b0 <ps2::test_port_1()>:
}
bool test_port_1() {
  1013b0:	55                   	push   ebp
  1013b1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1013b3:	66 ba 64 00          	mov    dx,0x64
  1013b7:	b0 ab                	mov    al,0xab
  1013b9:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1013ba:	66 ba 60 00          	mov    dx,0x60
  1013be:	ec                   	in     al,dx
    send(COMMAND, 0xAB);
    return receive(DATA) == 0x00;
  1013bf:	84 c0                	test   al,al
  1013c1:	0f 94 c0             	sete   al
  1013c4:	5d                   	pop    ebp
  1013c5:	c3                   	ret    
  1013c6:	90                   	nop
  1013c7:	90                   	nop
  1013c8:	90                   	nop
  1013c9:	90                   	nop
  1013ca:	90                   	nop
  1013cb:	90                   	nop
  1013cc:	90                   	nop
  1013cd:	90                   	nop
  1013ce:	90                   	nop
  1013cf:	90                   	nop

001013d0 <ps2::disable_1()>:
}

void disable_1() { send(COMMAND, 0xAD); }
  1013d0:	55                   	push   ebp
  1013d1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1013d3:	66 ba 64 00          	mov    dx,0x64
  1013d7:	b0 ad                	mov    al,0xad
  1013d9:	ee                   	out    dx,al
void disable_1() { send(COMMAND, 0xAD); }
  1013da:	5d                   	pop    ebp
  1013db:	c3                   	ret    
  1013dc:	90                   	nop
  1013dd:	90                   	nop
  1013de:	90                   	nop
  1013df:	90                   	nop

001013e0 <ps2::enable_1()>:
void enable_1() { send(COMMAND, 0xAE); }
  1013e0:	55                   	push   ebp
  1013e1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1013e3:	66 ba 64 00          	mov    dx,0x64
  1013e7:	b0 ae                	mov    al,0xae
  1013e9:	ee                   	out    dx,al
void enable_1() { send(COMMAND, 0xAE); }
  1013ea:	5d                   	pop    ebp
  1013eb:	c3                   	ret    
  1013ec:	90                   	nop
  1013ed:	90                   	nop
  1013ee:	90                   	nop
  1013ef:	90                   	nop

001013f0 <ps2::disable_2()>:
void disable_2() { send(COMMAND, 0xA7); }
  1013f0:	55                   	push   ebp
  1013f1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1013f3:	66 ba 64 00          	mov    dx,0x64
  1013f7:	b0 a7                	mov    al,0xa7
  1013f9:	ee                   	out    dx,al
void disable_2() { send(COMMAND, 0xA7); }
  1013fa:	5d                   	pop    ebp
  1013fb:	c3                   	ret    
  1013fc:	90                   	nop
  1013fd:	90                   	nop
  1013fe:	90                   	nop
  1013ff:	90                   	nop

00101400 <ps2::enable_2()>:
void enable_2() { send(COMMAND, 0xA8); }
  101400:	55                   	push   ebp
  101401:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101403:	66 ba 64 00          	mov    dx,0x64
  101407:	b0 a8                	mov    al,0xa8
  101409:	ee                   	out    dx,al
void enable_2() { send(COMMAND, 0xA8); }
  10140a:	5d                   	pop    ebp
  10140b:	c3                   	ret    
  10140c:	90                   	nop
  10140d:	90                   	nop
  10140e:	90                   	nop
  10140f:	90                   	nop

00101410 <ps2::reset_1()>:
bool reset_1() {
  101410:	55                   	push   ebp
  101411:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101413:	66 ba 60 00          	mov    dx,0x60
  101417:	b0 ff                	mov    al,0xff
  101419:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10141a:	66 ba 60 00          	mov    dx,0x60
  10141e:	ec                   	in     al,dx
  10141f:	66 ba 60 00          	mov    dx,0x60
  101423:	ec                   	in     al,dx
    send(DATA, 0xFF);
    receive(DATA); // this receive() should not be necessary...
    return receive(DATA) == 0xAA;
  101424:	3c aa                	cmp    al,0xaa
  101426:	0f 94 c0             	sete   al
  101429:	5d                   	pop    ebp
  10142a:	c3                   	ret    
  10142b:	90                   	nop
  10142c:	90                   	nop
  10142d:	90                   	nop
  10142e:	90                   	nop
  10142f:	90                   	nop

00101430 <ps2::reset_2()>:
}
bool reset_2() {
  101430:	55                   	push   ebp
  101431:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101433:	66 ba 64 00          	mov    dx,0x64
  101437:	b0 d4                	mov    al,0xd4
  101439:	ee                   	out    dx,al
  10143a:	66 ba 60 00          	mov    dx,0x60
  10143e:	b0 ff                	mov    al,0xff
  101440:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101441:	66 ba 60 00          	mov    dx,0x60
  101445:	ec                   	in     al,dx
  101446:	66 ba 60 00          	mov    dx,0x60
  10144a:	ec                   	in     al,dx
    send(COMMAND, 0xD4);
    send(DATA, 0xFF);
    receive(DATA); // this receive() should not be necessary...
    return receive(DATA) == 0xAA;
  10144b:	3c aa                	cmp    al,0xaa
  10144d:	0f 94 c0             	sete   al
  101450:	5d                   	pop    ebp
  101451:	c3                   	ret    
  101452:	90                   	nop
  101453:	90                   	nop
  101454:	90                   	nop
  101455:	90                   	nop
  101456:	90                   	nop
  101457:	90                   	nop
  101458:	90                   	nop
  101459:	90                   	nop
  10145a:	90                   	nop
  10145b:	90                   	nop
  10145c:	90                   	nop
  10145d:	90                   	nop
  10145e:	90                   	nop
  10145f:	90                   	nop

00101460 <ps2::hard_reset()>:
}

void hard_reset() { send(COMMAND, 0xFE); }
  101460:	55                   	push   ebp
  101461:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101463:	66 ba 64 00          	mov    dx,0x64
  101467:	b0 fe                	mov    al,0xfe
  101469:	ee                   	out    dx,al
void hard_reset() { send(COMMAND, 0xFE); }
  10146a:	5d                   	pop    ebp
  10146b:	c3                   	ret    
  10146c:	90                   	nop
  10146d:	90                   	nop
  10146e:	90                   	nop
  10146f:	90                   	nop

00101470 <ps2::get_output()>:

uint8 get_output() { return receive(DATA); }
  101470:	55                   	push   ebp
  101471:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101473:	66 ba 60 00          	mov    dx,0x60
  101477:	ec                   	in     al,dx
uint8 get_output() { return receive(DATA); }
  101478:	5d                   	pop    ebp
  101479:	c3                   	ret    
  10147a:	90                   	nop
  10147b:	90                   	nop
  10147c:	90                   	nop
  10147d:	90                   	nop
  10147e:	90                   	nop
  10147f:	90                   	nop

00101480 <ps2::flush_output()>:

void flush_output() {
  101480:	55                   	push   ebp
  101481:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101483:	66 ba 64 00          	mov    dx,0x64
  101487:	ec                   	in     al,dx
  101488:	a8 01                	test   al,0x1
    while (has_output_data())
  10148a:	74 12                	je     10149e <ps2::flush_output()+0x1e>
  10148c:	90                   	nop
  10148d:	90                   	nop
  10148e:	90                   	nop
  10148f:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101490:	66 ba 60 00          	mov    dx,0x60
  101494:	ec                   	in     al,dx
  101495:	66 ba 64 00          	mov    dx,0x64
  101499:	ec                   	in     al,dx
  10149a:	a8 01                	test   al,0x1
    while (has_output_data())
  10149c:	75 f2                	jne    101490 <ps2::flush_output()+0x10>
        receive(DATA);
}
  10149e:	5d                   	pop    ebp
  10149f:	c3                   	ret    

001014a0 <ps2::startup(int)>:
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1014a0:	66 ba 64 00          	mov    dx,0x64
  1014a4:	b0 ad                	mov    al,0xad
  1014a6:	ee                   	out    dx,al
  1014a7:	66 ba 64 00          	mov    dx,0x64
  1014ab:	b0 a7                	mov    al,0xa7
  1014ad:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014ae:	66 ba 64 00          	mov    dx,0x64
  1014b2:	ec                   	in     al,dx
  1014b3:	a8 01                	test   al,0x1
    while (has_output_data())
  1014b5:	74 17                	je     1014ce <ps2::startup(int)+0x2e>
  1014b7:	90                   	nop
  1014b8:	90                   	nop
  1014b9:	90                   	nop
  1014ba:	90                   	nop
  1014bb:	90                   	nop
  1014bc:	90                   	nop
  1014bd:	90                   	nop
  1014be:	90                   	nop
  1014bf:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014c0:	66 ba 60 00          	mov    dx,0x60
  1014c4:	ec                   	in     al,dx
  1014c5:	66 ba 64 00          	mov    dx,0x64
  1014c9:	ec                   	in     al,dx
  1014ca:	a8 01                	test   al,0x1
    while (has_output_data())
  1014cc:	75 f2                	jne    1014c0 <ps2::startup(int)+0x20>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1014ce:	66 ba 64 00          	mov    dx,0x64
  1014d2:	b0 20                	mov    al,0x20
  1014d4:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014d5:	66 ba 60 00          	mov    dx,0x60
  1014d9:	ec                   	in     al,dx
  1014da:	89 c1                	mov    ecx,eax
bool startup(int device = 1) {
    ps2::disable_1();
    ps2::disable_2();
    ps2::flush_output();
    uint8 cb = ps2::read_config();
    cb &= 0b10111100; // disable interrupts and translation
  1014dc:	80 e1 bc             	and    cl,0xbc
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1014df:	66 ba 64 00          	mov    dx,0x64
  1014e3:	b0 60                	mov    al,0x60
  1014e5:	ee                   	out    dx,al
  1014e6:	66 ba 60 00          	mov    dx,0x60
  1014ea:	89 c8                	mov    eax,ecx
  1014ec:	ee                   	out    dx,al
  1014ed:	66 ba 64 00          	mov    dx,0x64
  1014f1:	b0 aa                	mov    al,0xaa
  1014f3:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014f4:	66 ba 60 00          	mov    dx,0x60
  1014f8:	ec                   	in     al,dx
    return receive(DATA) == 0x55;
  1014f9:	3c 55                	cmp    al,0x55
    ps2::write_config(cb);
    if (!(ps2::test_controller() && ps2::test_port_1()))
  1014fb:	75 5c                	jne    101559 <ps2::startup(int)+0xb9>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1014fd:	66 ba 64 00          	mov    dx,0x64
  101501:	b0 ab                	mov    al,0xab
  101503:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101504:	66 ba 60 00          	mov    dx,0x60
  101508:	ec                   	in     al,dx
    return receive(DATA) == 0x00;
  101509:	84 c0                	test   al,al
    if (!(ps2::test_controller() && ps2::test_port_1()))
  10150b:	75 4c                	jne    101559 <ps2::startup(int)+0xb9>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10150d:	66 ba 64 00          	mov    dx,0x64
  101511:	b0 ae                	mov    al,0xae
  101513:	ee                   	out    dx,al
  101514:	66 ba 60 00          	mov    dx,0x60
  101518:	b0 ff                	mov    al,0xff
  10151a:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10151b:	66 ba 60 00          	mov    dx,0x60
  10151f:	ec                   	in     al,dx
  101520:	66 ba 60 00          	mov    dx,0x60
  101524:	ec                   	in     al,dx
    return receive(DATA) == 0xAA;
  101525:	3c aa                	cmp    al,0xaa
        return false;
    ps2::enable_1();
    if (!ps2::reset_1())
  101527:	75 30                	jne    101559 <ps2::startup(int)+0xb9>
  101529:	55                   	push   ebp
  10152a:	89 e5                	mov    ebp,esp
        return false;
    if (device == 2) {
  10152c:	83 7d 08 02          	cmp    DWORD PTR [ebp+0x8],0x2
  101530:	5d                   	pop    ebp
  101531:	75 23                	jne    101556 <ps2::startup(int)+0xb6>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101533:	66 ba 64 00          	mov    dx,0x64
  101537:	b0 a8                	mov    al,0xa8
  101539:	ee                   	out    dx,al
  10153a:	66 ba 64 00          	mov    dx,0x64
  10153e:	b0 d4                	mov    al,0xd4
  101540:	ee                   	out    dx,al
  101541:	66 ba 60 00          	mov    dx,0x60
  101545:	b0 ff                	mov    al,0xff
  101547:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101548:	66 ba 60 00          	mov    dx,0x60
  10154c:	ec                   	in     al,dx
  10154d:	66 ba 60 00          	mov    dx,0x60
  101551:	ec                   	in     al,dx
    return receive(DATA) == 0xAA;
  101552:	3c aa                	cmp    al,0xaa
        ps2::enable_2();
        if (!ps2::reset_2())
  101554:	75 03                	jne    101559 <ps2::startup(int)+0xb9>
  101556:	b0 01                	mov    al,0x1
            return false;
    }
    return true;
}
  101558:	c3                   	ret    
  101559:	31 c0                	xor    eax,eax
  10155b:	c3                   	ret    
  10155c:	90                   	nop
  10155d:	90                   	nop
  10155e:	90                   	nop
  10155f:	90                   	nop

00101560 <kbd::get_ascii()>:

string<80> LINE_BUFFER;

enum special_ascii : char { ASCII_END_OF_TEXT = 0x3, ASCII_BACKSPACE=0x8 };

optional<char> get_ascii() {
  101560:	55                   	push   ebp
  101561:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101563:	66 ba 60 00          	mov    dx,0x60
  101567:	ec                   	in     al,dx
  101568:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
    static bool ctrl_pressed = false;
    auto a = ps2::get_output();
    // scan codes (set 2)
    // http://www.techtoys.com.hk/Downloads/Download/Microchip/PS2_driver/ScanCode.pdf
    switch (a) {
  10156b:	04 10                	add    al,0x10
  10156d:	3c 76                	cmp    al,0x76
  10156f:	77 23                	ja     101594 <kbd::get_ascii()+0x34>
  101571:	0f b6 c0             	movzx  eax,al
  101574:	ff 24 85 00 50 10 00 	jmp    DWORD PTR [eax*4+0x105000]
  10157b:	66 ba 60 00          	mov    dx,0x60
  10157f:	ec                   	in     al,dx
    case 0xF0: {
        // break codes
        auto b = ps2::get_output();
        switch (b) {
  101580:	3c 14                	cmp    al,0x14
  101582:	75 10                	jne    101594 <kbd::get_ascii()+0x34>
        case 0x14:
            ctrl_pressed = false;
  101584:	c6 05 58 70 11 00 00 	mov    BYTE PTR ds:0x117058,0x0
  10158b:	eb 07                	jmp    101594 <kbd::get_ascii()+0x34>
            break;
        }
        break;
    }
    case 0x14:
        ctrl_pressed = true;
  10158d:	c6 05 58 70 11 00 01 	mov    BYTE PTR ds:0x117058,0x1
template <class T> class optional {
    bool loaded_ = false;
  101594:	66 c7 01 00 00       	mov    WORD PTR [ecx],0x0
  101599:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
    //  }
    default:
        break; // unhandled make/break code
    }
    return {};
}
  1015a0:	89 c8                	mov    eax,ecx
  1015a2:	5d                   	pop    ebp
  1015a3:	c2 04 00             	ret    0x4
  public:
    const T value;
    const char *const err = "(Unknown error)";

    constexpr optional() : value() {}
    constexpr optional(T p) : loaded_(true), value(move(p)) {}
  1015a6:	66 c7 01 01 7a       	mov    WORD PTR [ecx],0x7a01
  1015ab:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1015b2:	89 c8                	mov    eax,ecx
  1015b4:	5d                   	pop    ebp
  1015b5:	c2 04 00             	ret    0x4
        if (ctrl_pressed)
  1015b8:	a0 58 70 11 00       	mov    al,ds:0x117058
  1015bd:	c6 01 01             	mov    BYTE PTR [ecx],0x1
  1015c0:	3c 01                	cmp    al,0x1
  1015c2:	0f 85 05 03 00 00    	jne    1018cd <kbd::get_ascii()+0x36d>
  1015c8:	c6 41 01 03          	mov    BYTE PTR [ecx+0x1],0x3
  1015cc:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
}
  1015d3:	89 c8                	mov    eax,ecx
  1015d5:	5d                   	pop    ebp
  1015d6:	c2 04 00             	ret    0x4
  1015d9:	66 c7 01 01 78       	mov    WORD PTR [ecx],0x7801
  1015de:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1015e5:	89 c8                	mov    eax,ecx
  1015e7:	5d                   	pop    ebp
  1015e8:	c2 04 00             	ret    0x4
  1015eb:	66 c7 01 01 64       	mov    WORD PTR [ecx],0x6401
  1015f0:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1015f7:	89 c8                	mov    eax,ecx
  1015f9:	5d                   	pop    ebp
  1015fa:	c2 04 00             	ret    0x4
  1015fd:	66 c7 01 01 65       	mov    WORD PTR [ecx],0x6501
  101602:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101609:	89 c8                	mov    eax,ecx
  10160b:	5d                   	pop    ebp
  10160c:	c2 04 00             	ret    0x4
  10160f:	66 c7 01 01 66       	mov    WORD PTR [ecx],0x6601
  101614:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  10161b:	89 c8                	mov    eax,ecx
  10161d:	5d                   	pop    ebp
  10161e:	c2 04 00             	ret    0x4
  101621:	66 c7 01 01 74       	mov    WORD PTR [ecx],0x7401
  101626:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  10162d:	89 c8                	mov    eax,ecx
  10162f:	5d                   	pop    ebp
  101630:	c2 04 00             	ret    0x4
  101633:	66 c7 01 01 35       	mov    WORD PTR [ecx],0x3501
  101638:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  10163f:	89 c8                	mov    eax,ecx
  101641:	5d                   	pop    ebp
  101642:	c2 04 00             	ret    0x4
  101645:	66 c7 01 01 6e       	mov    WORD PTR [ecx],0x6e01
  10164a:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101651:	89 c8                	mov    eax,ecx
  101653:	5d                   	pop    ebp
  101654:	c2 04 00             	ret    0x4
  101657:	66 c7 01 01 62       	mov    WORD PTR [ecx],0x6201
  10165c:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101663:	89 c8                	mov    eax,ecx
  101665:	5d                   	pop    ebp
  101666:	c2 04 00             	ret    0x4
  101669:	66 c7 01 01 68       	mov    WORD PTR [ecx],0x6801
  10166e:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101675:	89 c8                	mov    eax,ecx
  101677:	5d                   	pop    ebp
  101678:	c2 04 00             	ret    0x4
  10167b:	66 c7 01 01 67       	mov    WORD PTR [ecx],0x6701
  101680:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101687:	89 c8                	mov    eax,ecx
  101689:	5d                   	pop    ebp
  10168a:	c2 04 00             	ret    0x4
  10168d:	66 c7 01 01 6d       	mov    WORD PTR [ecx],0x6d01
  101692:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101699:	89 c8                	mov    eax,ecx
  10169b:	5d                   	pop    ebp
  10169c:	c2 04 00             	ret    0x4
  10169f:	66 c7 01 01 6a       	mov    WORD PTR [ecx],0x6a01
  1016a4:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1016ab:	89 c8                	mov    eax,ecx
  1016ad:	5d                   	pop    ebp
  1016ae:	c2 04 00             	ret    0x4
  1016b1:	66 c7 01 01 37       	mov    WORD PTR [ecx],0x3701
  1016b6:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1016bd:	89 c8                	mov    eax,ecx
  1016bf:	5d                   	pop    ebp
  1016c0:	c2 04 00             	ret    0x4
  1016c3:	66 c7 01 01 6b       	mov    WORD PTR [ecx],0x6b01
  1016c8:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1016cf:	89 c8                	mov    eax,ecx
  1016d1:	5d                   	pop    ebp
  1016d2:	c2 04 00             	ret    0x4
  1016d5:	66 c7 01 01 30       	mov    WORD PTR [ecx],0x3001
  1016da:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1016e1:	89 c8                	mov    eax,ecx
  1016e3:	5d                   	pop    ebp
  1016e4:	c2 04 00             	ret    0x4
  1016e7:	66 c7 01 01 2e       	mov    WORD PTR [ecx],0x2e01
  1016ec:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1016f3:	89 c8                	mov    eax,ecx
  1016f5:	5d                   	pop    ebp
  1016f6:	c2 04 00             	ret    0x4
  1016f9:	66 c7 01 01 2f       	mov    WORD PTR [ecx],0x2f01
  1016fe:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101705:	89 c8                	mov    eax,ecx
  101707:	5d                   	pop    ebp
  101708:	c2 04 00             	ret    0x4
  10170b:	66 c7 01 01 6c       	mov    WORD PTR [ecx],0x6c01
  101710:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101717:	89 c8                	mov    eax,ecx
  101719:	5d                   	pop    ebp
  10171a:	c2 04 00             	ret    0x4
  10171d:	66 c7 01 01 70       	mov    WORD PTR [ecx],0x7001
  101722:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101729:	89 c8                	mov    eax,ecx
  10172b:	5d                   	pop    ebp
  10172c:	c2 04 00             	ret    0x4
  10172f:	66 c7 01 01 3d       	mov    WORD PTR [ecx],0x3d01
  101734:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  10173b:	89 c8                	mov    eax,ecx
  10173d:	5d                   	pop    ebp
  10173e:	c2 04 00             	ret    0x4
  101741:	66 c7 01 01 0a       	mov    WORD PTR [ecx],0xa01
  101746:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  10174d:	89 c8                	mov    eax,ecx
  10174f:	5d                   	pop    ebp
  101750:	c2 04 00             	ret    0x4
  101753:	66 c7 01 01 09       	mov    WORD PTR [ecx],0x901
  101758:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  10175f:	89 c8                	mov    eax,ecx
  101761:	5d                   	pop    ebp
  101762:	c2 04 00             	ret    0x4
  101765:	66 c7 01 01 71       	mov    WORD PTR [ecx],0x7101
  10176a:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101771:	89 c8                	mov    eax,ecx
  101773:	5d                   	pop    ebp
  101774:	c2 04 00             	ret    0x4
  101777:	66 c7 01 01 31       	mov    WORD PTR [ecx],0x3101
  10177c:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101783:	89 c8                	mov    eax,ecx
  101785:	5d                   	pop    ebp
  101786:	c2 04 00             	ret    0x4
  101789:	66 c7 01 01 73       	mov    WORD PTR [ecx],0x7301
  10178e:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101795:	89 c8                	mov    eax,ecx
  101797:	5d                   	pop    ebp
  101798:	c2 04 00             	ret    0x4
  10179b:	66 c7 01 01 61       	mov    WORD PTR [ecx],0x6101
  1017a0:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1017a7:	89 c8                	mov    eax,ecx
  1017a9:	5d                   	pop    ebp
  1017aa:	c2 04 00             	ret    0x4
  1017ad:	66 c7 01 01 77       	mov    WORD PTR [ecx],0x7701
  1017b2:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1017b9:	89 c8                	mov    eax,ecx
  1017bb:	5d                   	pop    ebp
  1017bc:	c2 04 00             	ret    0x4
  1017bf:	66 c7 01 01 32       	mov    WORD PTR [ecx],0x3201
  1017c4:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1017cb:	89 c8                	mov    eax,ecx
  1017cd:	5d                   	pop    ebp
  1017ce:	c2 04 00             	ret    0x4
  1017d1:	66 c7 01 01 34       	mov    WORD PTR [ecx],0x3401
  1017d6:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1017dd:	89 c8                	mov    eax,ecx
  1017df:	5d                   	pop    ebp
  1017e0:	c2 04 00             	ret    0x4
  1017e3:	66 c7 01 01 33       	mov    WORD PTR [ecx],0x3301
  1017e8:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1017ef:	89 c8                	mov    eax,ecx
  1017f1:	5d                   	pop    ebp
  1017f2:	c2 04 00             	ret    0x4
  1017f5:	66 c7 01 01 20       	mov    WORD PTR [ecx],0x2001
  1017fa:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101801:	89 c8                	mov    eax,ecx
  101803:	5d                   	pop    ebp
  101804:	c2 04 00             	ret    0x4
  101807:	66 c7 01 01 76       	mov    WORD PTR [ecx],0x7601
  10180c:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101813:	89 c8                	mov    eax,ecx
  101815:	5d                   	pop    ebp
  101816:	c2 04 00             	ret    0x4
  101819:	66 c7 01 01 72       	mov    WORD PTR [ecx],0x7201
  10181e:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101825:	89 c8                	mov    eax,ecx
  101827:	5d                   	pop    ebp
  101828:	c2 04 00             	ret    0x4
  10182b:	66 c7 01 01 79       	mov    WORD PTR [ecx],0x7901
  101830:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101837:	89 c8                	mov    eax,ecx
  101839:	5d                   	pop    ebp
  10183a:	c2 04 00             	ret    0x4
  10183d:	66 c7 01 01 36       	mov    WORD PTR [ecx],0x3601
  101842:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101849:	89 c8                	mov    eax,ecx
  10184b:	5d                   	pop    ebp
  10184c:	c2 04 00             	ret    0x4
  10184f:	66 c7 01 01 75       	mov    WORD PTR [ecx],0x7501
  101854:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  10185b:	89 c8                	mov    eax,ecx
  10185d:	5d                   	pop    ebp
  10185e:	c2 04 00             	ret    0x4
  101861:	66 c7 01 01 38       	mov    WORD PTR [ecx],0x3801
  101866:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  10186d:	89 c8                	mov    eax,ecx
  10186f:	5d                   	pop    ebp
  101870:	c2 04 00             	ret    0x4
  101873:	66 c7 01 01 69       	mov    WORD PTR [ecx],0x6901
  101878:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  10187f:	89 c8                	mov    eax,ecx
  101881:	5d                   	pop    ebp
  101882:	c2 04 00             	ret    0x4
  101885:	66 c7 01 01 6f       	mov    WORD PTR [ecx],0x6f01
  10188a:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  101891:	89 c8                	mov    eax,ecx
  101893:	5d                   	pop    ebp
  101894:	c2 04 00             	ret    0x4
  101897:	66 c7 01 01 39       	mov    WORD PTR [ecx],0x3901
  10189c:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1018a3:	89 c8                	mov    eax,ecx
  1018a5:	5d                   	pop    ebp
  1018a6:	c2 04 00             	ret    0x4
  1018a9:	66 c7 01 01 2d       	mov    WORD PTR [ecx],0x2d01
  1018ae:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1018b5:	89 c8                	mov    eax,ecx
  1018b7:	5d                   	pop    ebp
  1018b8:	c2 04 00             	ret    0x4
  1018bb:	66 c7 01 01 08       	mov    WORD PTR [ecx],0x801
  1018c0:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1018c7:	89 c8                	mov    eax,ecx
  1018c9:	5d                   	pop    ebp
  1018ca:	c2 04 00             	ret    0x4
  1018cd:	c6 41 01 63          	mov    BYTE PTR [ecx+0x1],0x63
  1018d1:	c7 41 04 44 00 10 00 	mov    DWORD PTR [ecx+0x4],0x100044
  1018d8:	89 c8                	mov    eax,ecx
  1018da:	5d                   	pop    ebp
  1018db:	c2 04 00             	ret    0x4
  1018de:	90                   	nop
  1018df:	90                   	nop

001018e0 <kbd::get_line(bool)>:

auto &get_line(bool echo = true) {
  1018e0:	55                   	push   ebp
  1018e1:	89 e5                	mov    ebp,esp
  1018e3:	53                   	push   ebx
  1018e4:	57                   	push   edi
  1018e5:	56                   	push   esi
  1018e6:	83 e4 f8             	and    esp,0xfffffff8
  1018e9:	83 ec 10             	sub    esp,0x10
  1018ec:	31 f6                	xor    esi,esi
  1018ee:	89 e7                	mov    edi,esp
    int b = 0;
    while (b < LINE_BUFFER.size() - 1) {
  1018f0:	80 7d 08 00          	cmp    BYTE PTR [ebp+0x8],0x0
  1018f4:	75 2a                	jne    101920 <kbd::get_line(bool)+0x40>
  1018f6:	e9 85 00 00 00       	jmp    101980 <kbd::get_line(bool)+0xa0>
            continue;
        char a = _a.value;

        if(a==ASCII_BACKSPACE) {
            b--;
            term::terminal.col-=1;
  1018fb:	ff 0d 04 60 10 00    	dec    DWORD PTR ds:0x106004
        write(s[a]);
  101901:	6a 20                	push   0x20
  101903:	e8 68 f8 ff ff       	call   101170 <term::write(char)>
  101908:	83 c4 04             	add    esp,0x4
            b--;
  10190b:	4e                   	dec    esi
            term::write(" ");
            term::terminal.col-=1;
  10190c:	ff 0d 04 60 10 00    	dec    DWORD PTR ds:0x106004
    while (b < LINE_BUFFER.size() - 1) {
  101912:	83 fe 4f             	cmp    esi,0x4f
  101915:	0f 8d 97 00 00 00    	jge    1019b2 <kbd::get_line(bool)+0xd2>
  10191b:	90                   	nop
  10191c:	90                   	nop
  10191d:	90                   	nop
  10191e:	90                   	nop
  10191f:	90                   	nop
  101920:	66 ba 64 00          	mov    dx,0x64
  101924:	ec                   	in     al,dx
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101925:	a8 01                	test   al,0x1
        while (!ps2::has_output_data())
  101927:	74 f7                	je     101920 <kbd::get_line(bool)+0x40>
        auto _a = get_ascii();
  101929:	57                   	push   edi
  10192a:	e8 31 fc ff ff       	call   101560 <kbd::get_ascii()>
    constexpr optional(bool, const char *p) : loaded_(false), value(), err(p) {}
    NO_COPY(optional)

    constexpr operator bool() const { return loaded_; }
  10192f:	80 3c 24 00          	cmp    BYTE PTR [esp],0x0
        if (!_a)
  101933:	74 dd                	je     101912 <kbd::get_line(bool)+0x32>
        char a = _a.value;
  101935:	0f b6 5c 24 01       	movzx  ebx,BYTE PTR [esp+0x1]
        if(a==ASCII_BACKSPACE) {
  10193a:	80 fb 08             	cmp    bl,0x8
  10193d:	74 bc                	je     1018fb <kbd::get_line(bool)+0x1b>
            continue;
        }
        if (echo) {
            term::write(a);
  10193f:	0f be c3             	movsx  eax,bl
  101942:	50                   	push   eax
  101943:	e8 28 f8 ff ff       	call   101170 <term::write(char)>
  101948:	83 c4 04             	add    esp,0x4
        }
        if (a == '\n')
  10194b:	80 fb 03             	cmp    bl,0x3
  10194e:	74 76                	je     1019c6 <kbd::get_line(bool)+0xe6>
  101950:	80 fb 0a             	cmp    bl,0xa
  101953:	74 5d                	je     1019b2 <kbd::get_line(bool)+0xd2>
            term::write('\n');
            LINE_BUFFER[0] = 0;
            return LINE_BUFFER;
        }
        
        LINE_BUFFER[b++] = a;
  101955:	88 9e 00 70 11 00    	mov    BYTE PTR [esi+0x117000],bl
  10195b:	46                   	inc    esi
    while (b < LINE_BUFFER.size() - 1) {
  10195c:	83 fe 4f             	cmp    esi,0x4f
  10195f:	7c bf                	jl     101920 <kbd::get_line(bool)+0x40>
  101961:	eb 4f                	jmp    1019b2 <kbd::get_line(bool)+0xd2>
            term::terminal.col-=1;
  101963:	ff 0d 04 60 10 00    	dec    DWORD PTR ds:0x106004
  101969:	6a 20                	push   0x20
  10196b:	e8 00 f8 ff ff       	call   101170 <term::write(char)>
  101970:	83 c4 04             	add    esp,0x4
            b--;
  101973:	4e                   	dec    esi
            term::terminal.col-=1;
  101974:	ff 0d 04 60 10 00    	dec    DWORD PTR ds:0x106004
    while (b < LINE_BUFFER.size() - 1) {
  10197a:	83 fe 4f             	cmp    esi,0x4f
  10197d:	7d 33                	jge    1019b2 <kbd::get_line(bool)+0xd2>
  10197f:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101980:	66 ba 64 00          	mov    dx,0x64
  101984:	ec                   	in     al,dx
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101985:	a8 01                	test   al,0x1
        while (!ps2::has_output_data())
  101987:	74 f7                	je     101980 <kbd::get_line(bool)+0xa0>
        auto _a = get_ascii();
  101989:	57                   	push   edi
  10198a:	e8 d1 fb ff ff       	call   101560 <kbd::get_ascii()>
  10198f:	80 3c 24 00          	cmp    BYTE PTR [esp],0x0
        if (!_a)
  101993:	74 e5                	je     10197a <kbd::get_line(bool)+0x9a>
        char a = _a.value;
  101995:	0f b6 44 24 01       	movzx  eax,BYTE PTR [esp+0x1]
        if(a==ASCII_BACKSPACE) {
  10199a:	3c 08                	cmp    al,0x8
  10199c:	74 c5                	je     101963 <kbd::get_line(bool)+0x83>
  10199e:	3c 03                	cmp    al,0x3
  1019a0:	74 24                	je     1019c6 <kbd::get_line(bool)+0xe6>
  1019a2:	3c 0a                	cmp    al,0xa
  1019a4:	74 0c                	je     1019b2 <kbd::get_line(bool)+0xd2>
        LINE_BUFFER[b++] = a;
  1019a6:	88 86 00 70 11 00    	mov    BYTE PTR [esi+0x117000],al
  1019ac:	46                   	inc    esi
    while (b < LINE_BUFFER.size() - 1) {
  1019ad:	83 fe 4f             	cmp    esi,0x4f
  1019b0:	7c ce                	jl     101980 <kbd::get_line(bool)+0xa0>
    }
    LINE_BUFFER[b] = 0;
  1019b2:	c6 86 00 70 11 00 00 	mov    BYTE PTR [esi+0x117000],0x0
    return LINE_BUFFER;
}
  1019b9:	b8 00 70 11 00       	mov    eax,0x117000
  1019be:	8d 65 f4             	lea    esp,[ebp-0xc]
  1019c1:	5e                   	pop    esi
  1019c2:	5f                   	pop    edi
  1019c3:	5b                   	pop    ebx
  1019c4:	5d                   	pop    ebp
  1019c5:	c3                   	ret    
        if (!flipped) {
  1019c6:	80 3d 0d 60 10 00 00 	cmp    BYTE PTR ds:0x10600d,0x0
  1019cd:	74 35                	je     101a04 <kbd::get_line(bool)+0x124>
            increment_cursor(row, col, max_row, max_col, max_row - (row % max_row));
  1019cf:	8b 0d 08 60 10 00    	mov    ecx,DWORD PTR ds:0x106008
  1019d5:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  1019da:	89 c8                	mov    eax,ecx
  1019dc:	f7 ea                	imul   edx
  1019de:	89 d0                	mov    eax,edx
  1019e0:	c1 e8 1f             	shr    eax,0x1f
  1019e3:	c1 fa 03             	sar    edx,0x3
  1019e6:	01 c2                	add    edx,eax
  1019e8:	8d 04 92             	lea    eax,[edx+edx*4]
  1019eb:	8d 04 80             	lea    eax,[eax+eax*4]
  1019ee:	29 c8                	sub    eax,ecx
  1019f0:	83 c0 19             	add    eax,0x19
  1019f3:	b9 08 60 10 00       	mov    ecx,0x106008
  1019f8:	ba 04 60 10 00       	mov    edx,0x106004
  1019fd:	50                   	push   eax
  1019fe:	6a 50                	push   0x50
  101a00:	6a 19                	push   0x19
  101a02:	eb 33                	jmp    101a37 <kbd::get_line(bool)+0x157>
            increment_cursor(col, row, max_col, max_row, max_col - (col % max_col));
  101a04:	8b 0d 04 60 10 00    	mov    ecx,DWORD PTR ds:0x106004
  101a0a:	ba 67 66 66 66       	mov    edx,0x66666667
  101a0f:	89 c8                	mov    eax,ecx
  101a11:	f7 ea                	imul   edx
  101a13:	89 d0                	mov    eax,edx
  101a15:	c1 e8 1f             	shr    eax,0x1f
  101a18:	c1 fa 05             	sar    edx,0x5
  101a1b:	01 c2                	add    edx,eax
  101a1d:	c1 e2 04             	shl    edx,0x4
  101a20:	8d 04 92             	lea    eax,[edx+edx*4]
  101a23:	29 c8                	sub    eax,ecx
  101a25:	83 c0 50             	add    eax,0x50
  101a28:	b9 04 60 10 00       	mov    ecx,0x106004
  101a2d:	ba 08 60 10 00       	mov    edx,0x106008
  101a32:	50                   	push   eax
  101a33:	6a 19                	push   0x19
  101a35:	6a 50                	push   0x50
  101a37:	e8 f4 1d 00 00       	call   103830 <term::$_2::increment_cursor(int&, int&, int, int, int)>
  101a3c:	83 c4 0c             	add    esp,0xc
            LINE_BUFFER[0] = 0;
  101a3f:	c6 05 00 70 11 00 00 	mov    BYTE PTR ds:0x117000,0x0
  101a46:	e9 6e ff ff ff       	jmp    1019b9 <kbd::get_line(bool)+0xd9>
  101a4b:	90                   	nop
  101a4c:	90                   	nop
  101a4d:	90                   	nop
  101a4e:	90                   	nop
  101a4f:	90                   	nop

00101a50 <time::delay(int)>:

/**
 * Spin the CPU for a given number of "moments".
 * (One "moment" is 2^16 AND operations.)
 */
void delay(int amount = 1) {
  101a50:	55                   	push   ebp
  101a51:	89 e5                	mov    ebp,esp
  101a53:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
    for (int a = 0; a < (1 << 16) * amount; a++) {
  101a56:	85 c0                	test   eax,eax
  101a58:	7e 0d                	jle    101a67 <time::delay(int)+0x17>
  101a5a:	c1 e0 10             	shl    eax,0x10
  101a5d:	31 c9                	xor    ecx,ecx
  101a5f:	90                   	nop
        asm volatile ("and %eax,%eax");
  101a60:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  101a62:	41                   	inc    ecx
  101a63:	39 c1                	cmp    ecx,eax
  101a65:	7c f9                	jl     101a60 <time::delay(int)+0x10>
    }
}
  101a67:	5d                   	pop    ebp
  101a68:	c3                   	ret    
  101a69:	90                   	nop
  101a6a:	90                   	nop
  101a6b:	90                   	nop
  101a6c:	90                   	nop
  101a6d:	90                   	nop
  101a6e:	90                   	nop
  101a6f:	90                   	nop

00101a70 <kernel_main>:
        f_();
        term::write("Runner ended\n");
    }
};

extern "C" void kernel_main(multiboot_info_t *mb, uint32 magic, uint32 seed) {
  101a70:	55                   	push   ebp
  101a71:	89 e5                	mov    ebp,esp
  101a73:	53                   	push   ebx
  101a74:	57                   	push   edi
  101a75:	56                   	push   esi
  101a76:	83 e4 f8             	and    esp,0xfffffff8
  101a79:	81 ec e0 0c 00 00    	sub    esp,0xce0
  101a7f:	8b 5d 0c             	mov    ebx,DWORD PTR [ebp+0xc]
    term::clear();
  101a82:	e8 f9 f5 ff ff       	call   101080 <term::clear()>
    static_assert(N > 0, "Please do not create an empty array");
    T data_[N + 1];
    int index_ = 0;

  public:
    constexpr array() : data_{T()} {}
  101a87:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  101a8e:	00 00 00 00 
  101a92:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  101a99:	00 00 00 00 
  101a9d:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  101aa4:	00 00 00 00 
  101aa8:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  101aaf:	00 00 00 00 
  101ab3:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  101aba:	00 00 00 00 
  101abe:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  101ac5:	00 00 00 00 
  101ac9:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  101ad0:	00 00 00 00 
  101ad4:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  101adb:	00 00 00 00 
    int index_ = 0;
  101adf:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  101ae6:	00 00 00 00 
    if (x == 0)
  101aea:	85 db                	test   ebx,ebx
  101aec:	74 76                	je     101b64 <kernel_main+0xf4>
    for (; x > 0; a++) {
  101aee:	8d 84 24 0f 03 00 00 	lea    eax,[esp+0x30f]
  101af5:	31 f6                	xor    esi,esi
  101af7:	90                   	nop
  101af8:	90                   	nop
  101af9:	90                   	nop
  101afa:	90                   	nop
  101afb:	90                   	nop
  101afc:	90                   	nop
  101afd:	90                   	nop
  101afe:	90                   	nop
  101aff:	90                   	nop
        if ((x % B) < 10)
  101b00:	89 da                	mov    edx,ebx
  101b02:	83 e2 0f             	and    edx,0xf
  101b05:	89 d1                	mov    ecx,edx
  101b07:	80 c9 30             	or     cl,0x30
  101b0a:	88 dd                	mov    ch,bl
  101b0c:	80 c5 06             	add    ch,0x6
  101b0f:	80 e5 0f             	and    ch,0xf
  101b12:	80 c5 41             	add    ch,0x41
  101b15:	83 fa 0a             	cmp    edx,0xa
  101b18:	0f b6 d1             	movzx  edx,cl
  101b1b:	0f b6 cd             	movzx  ecx,ch
  101b1e:	0f 42 ca             	cmovb  ecx,edx
        r[a] = i2c(x);
  101b21:	88 48 01             	mov    BYTE PTR [eax+0x1],cl
  101b24:	40                   	inc    eax
        x /= B;
  101b25:	c1 eb 04             	shr    ebx,0x4
    for (; x > 0; a++) {
  101b28:	46                   	inc    esi
  101b29:	85 db                	test   ebx,ebx
  101b2b:	75 d3                	jne    101b00 <kernel_main+0x90>
    r[a] = 0;
  101b2d:	c6 40 01 00          	mov    BYTE PTR [eax+0x1],0x0
    for (auto b = 0; b < a / 2; b++) {
  101b31:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  101b37:	74 35                	je     101b6e <kernel_main+0xfe>
  101b39:	d1 ee                	shr    esi,1
  101b3b:	8d 94 24 10 03 00 00 	lea    edx,[esp+0x310]
  101b42:	90                   	nop
  101b43:	90                   	nop
  101b44:	90                   	nop
  101b45:	90                   	nop
  101b46:	90                   	nop
  101b47:	90                   	nop
  101b48:	90                   	nop
  101b49:	90                   	nop
  101b4a:	90                   	nop
  101b4b:	90                   	nop
  101b4c:	90                   	nop
  101b4d:	90                   	nop
  101b4e:	90                   	nop
  101b4f:	90                   	nop
        r[b] ^= r[a - b - 1];
  101b50:	0f b6 0a             	movzx  ecx,BYTE PTR [edx]
  101b53:	32 08                	xor    cl,BYTE PTR [eax]
  101b55:	88 0a                	mov    BYTE PTR [edx],cl
        r[a - b - 1] ^= r[b];
  101b57:	32 08                	xor    cl,BYTE PTR [eax]
  101b59:	88 08                	mov    BYTE PTR [eax],cl
        r[b] ^= r[a - b - 1];
  101b5b:	30 0a                	xor    BYTE PTR [edx],cl
    for (auto b = 0; b < a / 2; b++) {
  101b5d:	42                   	inc    edx
  101b5e:	48                   	dec    eax
  101b5f:	4e                   	dec    esi
  101b60:	75 ee                	jne    101b50 <kernel_main+0xe0>
  101b62:	eb 0a                	jmp    101b6e <kernel_main+0xfe>
        r[a++] = '0';
  101b64:	66 c7 84 24 10 03 00 	mov    WORD PTR [esp+0x310],0x30
  101b6b:	00 30 00 
  101b6e:	8d bc 24 10 01 00 00 	lea    edi,[esp+0x110]
  101b75:	8d b4 24 10 03 00 00 	lea    esi,[esp+0x310]
    return r;
  101b7c:	b9 09 00 00 00       	mov    ecx,0x9
  101b81:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
        write(s[a]);
  101b83:	6a 4c                	push   0x4c
  101b85:	e8 e6 f5 ff ff       	call   101170 <term::write(char)>
  101b8a:	83 c4 04             	add    esp,0x4
  101b8d:	6a 6f                	push   0x6f
  101b8f:	e8 dc f5 ff ff       	call   101170 <term::write(char)>
  101b94:	83 c4 04             	add    esp,0x4
  101b97:	6a 61                	push   0x61
  101b99:	e8 d2 f5 ff ff       	call   101170 <term::write(char)>
  101b9e:	83 c4 04             	add    esp,0x4
  101ba1:	6a 64                	push   0x64
  101ba3:	e8 c8 f5 ff ff       	call   101170 <term::write(char)>
  101ba8:	83 c4 04             	add    esp,0x4
  101bab:	6a 65                	push   0x65
  101bad:	e8 be f5 ff ff       	call   101170 <term::write(char)>
  101bb2:	83 c4 04             	add    esp,0x4
  101bb5:	6a 64                	push   0x64
  101bb7:	e8 b4 f5 ff ff       	call   101170 <term::write(char)>
  101bbc:	83 c4 04             	add    esp,0x4
  101bbf:	6a 20                	push   0x20
  101bc1:	e8 aa f5 ff ff       	call   101170 <term::write(char)>
  101bc6:	83 c4 04             	add    esp,0x4
  101bc9:	6a 47                	push   0x47
  101bcb:	e8 a0 f5 ff ff       	call   101170 <term::write(char)>
  101bd0:	83 c4 04             	add    esp,0x4
  101bd3:	6a 52                	push   0x52
  101bd5:	e8 96 f5 ff ff       	call   101170 <term::write(char)>
  101bda:	83 c4 04             	add    esp,0x4
  101bdd:	6a 55                	push   0x55
  101bdf:	e8 8c f5 ff ff       	call   101170 <term::write(char)>
  101be4:	83 c4 04             	add    esp,0x4
  101be7:	6a 42                	push   0x42
  101be9:	e8 82 f5 ff ff       	call   101170 <term::write(char)>
  101bee:	83 c4 04             	add    esp,0x4
  101bf1:	6a 20                	push   0x20
  101bf3:	e8 78 f5 ff ff       	call   101170 <term::write(char)>
  101bf8:	83 c4 04             	add    esp,0x4
  101bfb:	6a 69                	push   0x69
  101bfd:	e8 6e f5 ff ff       	call   101170 <term::write(char)>
  101c02:	83 c4 04             	add    esp,0x4
  101c05:	6a 6e                	push   0x6e
  101c07:	e8 64 f5 ff ff       	call   101170 <term::write(char)>
  101c0c:	83 c4 04             	add    esp,0x4
  101c0f:	6a 66                	push   0x66
  101c11:	e8 5a f5 ff ff       	call   101170 <term::write(char)>
  101c16:	83 c4 04             	add    esp,0x4
  101c19:	6a 6f                	push   0x6f
  101c1b:	e8 50 f5 ff ff       	call   101170 <term::write(char)>
  101c20:	83 c4 04             	add    esp,0x4
  101c23:	6a 3a                	push   0x3a
  101c25:	e8 46 f5 ff ff       	call   101170 <term::write(char)>
  101c2a:	83 c4 04             	add    esp,0x4
  101c2d:	6a 20                	push   0x20
  101c2f:	e8 3c f5 ff ff       	call   101170 <term::write(char)>
  101c34:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  101c37:	8a 84 24 10 01 00 00 	mov    al,BYTE PTR [esp+0x110]
  101c3e:	84 c0                	test   al,al
  101c40:	74 22                	je     101c64 <kernel_main+0x1f4>
  101c42:	8d b4 24 11 01 00 00 	lea    esi,[esp+0x111]
  101c49:	90                   	nop
  101c4a:	90                   	nop
  101c4b:	90                   	nop
  101c4c:	90                   	nop
  101c4d:	90                   	nop
  101c4e:	90                   	nop
  101c4f:	90                   	nop
        write(s[a]);
  101c50:	0f be c0             	movsx  eax,al
  101c53:	50                   	push   eax
  101c54:	e8 17 f5 ff ff       	call   101170 <term::write(char)>
  101c59:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  101c5c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  101c5f:	46                   	inc    esi
  101c60:	84 c0                	test   al,al
  101c62:	75 ec                	jne    101c50 <kernel_main+0x1e0>
        write(s[a]);
  101c64:	6a 0a                	push   0xa
  101c66:	e8 05 f5 ff ff       	call   101170 <term::write(char)>
  101c6b:	83 c4 04             	add    esp,0x4
  101c6e:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
    int count_;

  public:
    module_list(multiboot_info_t const &mb)
        : addr_(reinterpret_cast<multiboot_module_t *>(mb.mods_addr)),
          count_(static_cast<int>(mb.mods_count)) {}
  101c71:	8b 48 14             	mov    ecx,DWORD PTR [eax+0x14]
        : addr_(reinterpret_cast<multiboot_module_t *>(mb.mods_addr)),
  101c74:	8b 40 18             	mov    eax,DWORD PTR [eax+0x18]
  101c77:	89 44 24 10          	mov    DWORD PTR [esp+0x10],eax
  101c7b:	89 4c 24 08          	mov    DWORD PTR [esp+0x8],ecx
    term::write("Loaded GRUB info: ", int_to_string<16>(magic).str(), "\n");

    mod::module_list mods(*mb);
    if (mods.size() > 0) {
  101c7f:	85 c9                	test   ecx,ecx
  101c81:	0f 8e d2 05 00 00    	jle    102259 <kernel_main+0x7e9>
    constexpr array() : data_{T()} {}
  101c87:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  101c8e:	00 00 00 00 
  101c92:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  101c99:	00 00 00 00 
  101c9d:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  101ca4:	00 00 00 00 
  101ca8:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  101caf:	00 00 00 00 
  101cb3:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  101cba:	00 00 00 00 
  101cbe:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  101cc5:	00 00 00 00 
  101cc9:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  101cd0:	00 00 00 00 
  101cd4:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  101cdb:	00 00 00 00 
    int index_ = 0;
  101cdf:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  101ce6:	00 00 00 00 
    for (; x > 0; a++) {
  101cea:	8d b4 24 0f 03 00 00 	lea    esi,[esp+0x30f]
  101cf1:	31 ff                	xor    edi,edi
  101cf3:	8b 5c 24 08          	mov    ebx,DWORD PTR [esp+0x8]
  101cf7:	90                   	nop
  101cf8:	90                   	nop
  101cf9:	90                   	nop
  101cfa:	90                   	nop
  101cfb:	90                   	nop
  101cfc:	90                   	nop
  101cfd:	90                   	nop
  101cfe:	90                   	nop
  101cff:	90                   	nop
        x /= B;
  101d00:	89 d8                	mov    eax,ebx
  101d02:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  101d07:	f7 e1                	mul    ecx
  101d09:	c1 ea 03             	shr    edx,0x3
  101d0c:	8d 04 12             	lea    eax,[edx+edx*1]
  101d0f:	8d 04 80             	lea    eax,[eax+eax*4]
  101d12:	89 d9                	mov    ecx,ebx
  101d14:	29 c1                	sub    ecx,eax
            return '0' + (x % B);
  101d16:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  101d19:	88 4e 01             	mov    BYTE PTR [esi+0x1],cl
  101d1c:	46                   	inc    esi
    for (; x > 0; a++) {
  101d1d:	47                   	inc    edi
  101d1e:	83 fb 09             	cmp    ebx,0x9
  101d21:	89 d3                	mov    ebx,edx
  101d23:	77 db                	ja     101d00 <kernel_main+0x290>
    r[a] = 0;
  101d25:	c6 46 01 00          	mov    BYTE PTR [esi+0x1],0x0
    for (auto b = 0; b < a / 2; b++) {
  101d29:	f7 c7 fe ff ff ff    	test   edi,0xfffffffe
  101d2f:	74 21                	je     101d52 <kernel_main+0x2e2>
  101d31:	d1 ef                	shr    edi,1
  101d33:	8d 84 24 10 03 00 00 	lea    eax,[esp+0x310]
  101d3a:	90                   	nop
  101d3b:	90                   	nop
  101d3c:	90                   	nop
  101d3d:	90                   	nop
  101d3e:	90                   	nop
  101d3f:	90                   	nop
        r[b] ^= r[a - b - 1];
  101d40:	0f b6 08             	movzx  ecx,BYTE PTR [eax]
  101d43:	32 0e                	xor    cl,BYTE PTR [esi]
  101d45:	88 08                	mov    BYTE PTR [eax],cl
        r[a - b - 1] ^= r[b];
  101d47:	32 0e                	xor    cl,BYTE PTR [esi]
  101d49:	88 0e                	mov    BYTE PTR [esi],cl
        r[b] ^= r[a - b - 1];
  101d4b:	30 08                	xor    BYTE PTR [eax],cl
    for (auto b = 0; b < a / 2; b++) {
  101d4d:	40                   	inc    eax
  101d4e:	4e                   	dec    esi
  101d4f:	4f                   	dec    edi
  101d50:	75 ee                	jne    101d40 <kernel_main+0x2d0>
  101d52:	8d bc 24 10 01 00 00 	lea    edi,[esp+0x110]
  101d59:	8d 9c 24 10 03 00 00 	lea    ebx,[esp+0x310]
    return r;
  101d60:	b9 09 00 00 00       	mov    ecx,0x9
  101d65:	89 de                	mov    esi,ebx
  101d67:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  101d69:	6a 4c                	push   0x4c
  101d6b:	e8 00 f4 ff ff       	call   101170 <term::write(char)>
  101d70:	83 c4 04             	add    esp,0x4
  101d73:	6a 6f                	push   0x6f
  101d75:	e8 f6 f3 ff ff       	call   101170 <term::write(char)>
  101d7a:	83 c4 04             	add    esp,0x4
  101d7d:	6a 61                	push   0x61
  101d7f:	e8 ec f3 ff ff       	call   101170 <term::write(char)>
  101d84:	83 c4 04             	add    esp,0x4
  101d87:	6a 64                	push   0x64
  101d89:	e8 e2 f3 ff ff       	call   101170 <term::write(char)>
  101d8e:	83 c4 04             	add    esp,0x4
  101d91:	6a 65                	push   0x65
  101d93:	e8 d8 f3 ff ff       	call   101170 <term::write(char)>
  101d98:	83 c4 04             	add    esp,0x4
  101d9b:	6a 64                	push   0x64
  101d9d:	e8 ce f3 ff ff       	call   101170 <term::write(char)>
  101da2:	83 c4 04             	add    esp,0x4
  101da5:	6a 20                	push   0x20
  101da7:	e8 c4 f3 ff ff       	call   101170 <term::write(char)>
  101dac:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  101daf:	8a 84 24 10 01 00 00 	mov    al,BYTE PTR [esp+0x110]
  101db6:	84 c0                	test   al,al
  101db8:	74 2a                	je     101de4 <kernel_main+0x374>
  101dba:	8d b4 24 11 01 00 00 	lea    esi,[esp+0x111]
  101dc1:	90                   	nop
  101dc2:	90                   	nop
  101dc3:	90                   	nop
  101dc4:	90                   	nop
  101dc5:	90                   	nop
  101dc6:	90                   	nop
  101dc7:	90                   	nop
  101dc8:	90                   	nop
  101dc9:	90                   	nop
  101dca:	90                   	nop
  101dcb:	90                   	nop
  101dcc:	90                   	nop
  101dcd:	90                   	nop
  101dce:	90                   	nop
  101dcf:	90                   	nop
        write(s[a]);
  101dd0:	0f be c0             	movsx  eax,al
  101dd3:	50                   	push   eax
  101dd4:	e8 97 f3 ff ff       	call   101170 <term::write(char)>
  101dd9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  101ddc:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  101ddf:	46                   	inc    esi
  101de0:	84 c0                	test   al,al
  101de2:	75 ec                	jne    101dd0 <kernel_main+0x360>
        write(s[a]);
  101de4:	6a 20                	push   0x20
  101de6:	e8 85 f3 ff ff       	call   101170 <term::write(char)>
  101deb:	83 c4 04             	add    esp,0x4
  101dee:	6a 6d                	push   0x6d
  101df0:	e8 7b f3 ff ff       	call   101170 <term::write(char)>
  101df5:	83 c4 04             	add    esp,0x4
  101df8:	6a 6f                	push   0x6f
  101dfa:	e8 71 f3 ff ff       	call   101170 <term::write(char)>
  101dff:	83 c4 04             	add    esp,0x4
  101e02:	6a 64                	push   0x64
  101e04:	e8 67 f3 ff ff       	call   101170 <term::write(char)>
  101e09:	83 c4 04             	add    esp,0x4
  101e0c:	6a 75                	push   0x75
  101e0e:	e8 5d f3 ff ff       	call   101170 <term::write(char)>
  101e13:	83 c4 04             	add    esp,0x4
  101e16:	6a 6c                	push   0x6c
  101e18:	e8 53 f3 ff ff       	call   101170 <term::write(char)>
  101e1d:	83 c4 04             	add    esp,0x4
  101e20:	6a 65                	push   0x65
  101e22:	e8 49 f3 ff ff       	call   101170 <term::write(char)>
  101e27:	83 c4 04             	add    esp,0x4
  101e2a:	6a 73                	push   0x73
  101e2c:	e8 3f f3 ff ff       	call   101170 <term::write(char)>
  101e31:	83 c4 04             	add    esp,0x4
  101e34:	6a 0a                	push   0xa
  101e36:	e8 35 f3 ff ff       	call   101170 <term::write(char)>
  101e3b:	83 c4 04             	add    esp,0x4
        return ptr_ != p.ptr_;
  101e3e:	83 7c 24 08 00       	cmp    DWORD PTR [esp+0x8],0x0
        term::write("Loaded ", int_to_string(mods.size()).str(), " modules\n");
        for (auto &&a : mods) {
  101e43:	0f 84 10 04 00 00    	je     102259 <kernel_main+0x7e9>
  101e49:	8b 4c 24 08          	mov    ecx,DWORD PTR [esp+0x8]
  101e4d:	c1 e1 04             	shl    ecx,0x4
  101e50:	8b 44 24 10          	mov    eax,DWORD PTR [esp+0x10]
  101e54:	01 c1                	add    ecx,eax
  101e56:	89 4c 24 14          	mov    DWORD PTR [esp+0x14],ecx
  101e5a:	31 c9                	xor    ecx,ecx
  101e5c:	eb 22                	jmp    101e80 <kernel_main+0x410>
  101e5e:	90                   	nop
  101e5f:	90                   	nop
  101e60:	6a 0a                	push   0xa
  101e62:	e8 09 f3 ff ff       	call   101170 <term::write(char)>
  101e67:	83 c4 04             	add    esp,0x4
  101e6a:	8b 4c 24 0c          	mov    ecx,DWORD PTR [esp+0xc]
        index_++;
  101e6e:	41                   	inc    ecx
  101e6f:	8b 44 24 24          	mov    eax,DWORD PTR [esp+0x24]
        ptr_++;
  101e73:	83 c0 10             	add    eax,0x10
        return ptr_ != p.ptr_;
  101e76:	39 44 24 14          	cmp    DWORD PTR [esp+0x14],eax
  101e7a:	0f 84 d9 03 00 00    	je     102259 <kernel_main+0x7e9>
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  101e80:	8b 10                	mov    edx,DWORD PTR [eax]
  101e82:	89 54 24 18          	mov    DWORD PTR [esp+0x18],edx
  101e86:	8b 50 04             	mov    edx,DWORD PTR [eax+0x4]
  101e89:	89 54 24 1c          	mov    DWORD PTR [esp+0x1c],edx
  101e8d:	89 44 24 24          	mov    DWORD PTR [esp+0x24],eax
  101e91:	8b 40 08             	mov    eax,DWORD PTR [eax+0x8]
  101e94:	89 44 24 20          	mov    DWORD PTR [esp+0x20],eax
    constexpr array() : data_{T()} {}
  101e98:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  101e9f:	00 00 00 00 
  101ea3:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  101eaa:	00 00 00 00 
  101eae:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  101eb5:	00 00 00 00 
  101eb9:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  101ec0:	00 00 00 00 
  101ec4:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  101ecb:	00 00 00 00 
  101ecf:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  101ed6:	00 00 00 00 
  101eda:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  101ee1:	00 00 00 00 
  101ee5:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  101eec:	00 00 00 00 
    int index_ = 0;
  101ef0:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  101ef7:	00 00 00 00 
    if (x == 0)
  101efb:	85 c9                	test   ecx,ecx
  101efd:	89 4c 24 0c          	mov    DWORD PTR [esp+0xc],ecx
  101f01:	0f 84 99 00 00 00    	je     101fa0 <kernel_main+0x530>
  101f07:	31 ff                	xor    edi,edi
  101f09:	c7 04 24 01 00 00 00 	mov    DWORD PTR [esp],0x1
  101f10:	89 5c 24 04          	mov    DWORD PTR [esp+0x4],ebx
  101f14:	89 cb                	mov    ebx,ecx
  101f16:	90                   	nop
  101f17:	90                   	nop
  101f18:	90                   	nop
  101f19:	90                   	nop
  101f1a:	90                   	nop
  101f1b:	90                   	nop
  101f1c:	90                   	nop
  101f1d:	90                   	nop
  101f1e:	90                   	nop
  101f1f:	90                   	nop
        x /= B;
  101f20:	89 d8                	mov    eax,ebx
  101f22:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  101f27:	f7 e1                	mul    ecx
  101f29:	c1 ea 03             	shr    edx,0x3
  101f2c:	8d 04 12             	lea    eax,[edx+edx*1]
  101f2f:	8d 04 80             	lea    eax,[eax+eax*4]
  101f32:	89 d9                	mov    ecx,ebx
  101f34:	29 c1                	sub    ecx,eax
  101f36:	8b 04 24             	mov    eax,DWORD PTR [esp]
  101f39:	8b 74 24 04          	mov    esi,DWORD PTR [esp+0x4]
            return '0' + (x % B);
  101f3d:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  101f40:	88 8c 3c 10 03 00 00 	mov    BYTE PTR [esp+edi*1+0x310],cl
    for (; x > 0; a++) {
  101f47:	47                   	inc    edi
  101f48:	8d 48 01             	lea    ecx,[eax+0x1]
  101f4b:	89 0c 24             	mov    DWORD PTR [esp],ecx
  101f4e:	83 fb 09             	cmp    ebx,0x9
  101f51:	8d 4e 01             	lea    ecx,[esi+0x1]
  101f54:	89 4c 24 04          	mov    DWORD PTR [esp+0x4],ecx
  101f58:	89 d3                	mov    ebx,edx
  101f5a:	77 c4                	ja     101f20 <kernel_main+0x4b0>
    r[a] = 0;
  101f5c:	c6 84 3c 10 03 00 00 	mov    BYTE PTR [esp+edi*1+0x310],0x0
  101f63:	00 
    for (auto b = 0; b < a / 2; b++) {
  101f64:	f7 c7 fe ff ff ff    	test   edi,0xfffffffe
  101f6a:	8d 9c 24 10 03 00 00 	lea    ebx,[esp+0x310]
  101f71:	74 37                	je     101faa <kernel_main+0x53a>
  101f73:	d1 e8                	shr    eax,1
  101f75:	89 d9                	mov    ecx,ebx
  101f77:	90                   	nop
  101f78:	90                   	nop
  101f79:	90                   	nop
  101f7a:	90                   	nop
  101f7b:	90                   	nop
  101f7c:	90                   	nop
  101f7d:	90                   	nop
  101f7e:	90                   	nop
  101f7f:	90                   	nop
        r[b] ^= r[a - b - 1];
  101f80:	0f b6 11             	movzx  edx,BYTE PTR [ecx]
  101f83:	32 16                	xor    dl,BYTE PTR [esi]
  101f85:	88 11                	mov    BYTE PTR [ecx],dl
        r[a - b - 1] ^= r[b];
  101f87:	32 16                	xor    dl,BYTE PTR [esi]
  101f89:	88 16                	mov    BYTE PTR [esi],dl
        r[b] ^= r[a - b - 1];
  101f8b:	30 11                	xor    BYTE PTR [ecx],dl
    for (auto b = 0; b < a / 2; b++) {
  101f8d:	41                   	inc    ecx
  101f8e:	4e                   	dec    esi
  101f8f:	48                   	dec    eax
  101f90:	75 ee                	jne    101f80 <kernel_main+0x510>
  101f92:	eb 16                	jmp    101faa <kernel_main+0x53a>
  101f94:	90                   	nop
  101f95:	90                   	nop
  101f96:	90                   	nop
  101f97:	90                   	nop
  101f98:	90                   	nop
  101f99:	90                   	nop
  101f9a:	90                   	nop
  101f9b:	90                   	nop
  101f9c:	90                   	nop
  101f9d:	90                   	nop
  101f9e:	90                   	nop
  101f9f:	90                   	nop
        r[a++] = '0';
  101fa0:	66 c7 84 24 10 03 00 	mov    WORD PTR [esp+0x310],0x30
  101fa7:	00 30 00 
    return r;
  101faa:	b9 09 00 00 00       	mov    ecx,0x9
  101faf:	8d bc 24 10 01 00 00 	lea    edi,[esp+0x110]
  101fb6:	89 de                	mov    esi,ebx
  101fb8:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
    constexpr array() : data_{T()} {}
  101fba:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  101fc1:	00 00 00 00 
  101fc5:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  101fcc:	00 00 00 00 
  101fd0:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  101fd7:	00 00 00 00 
  101fdb:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  101fe2:	00 00 00 00 
  101fe6:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  101fed:	00 00 00 00 
  101ff1:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  101ff8:	00 00 00 00 
  101ffc:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  102003:	00 00 00 00 
  102007:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  10200e:	00 00 00 00 
    int index_ = 0;
  102012:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  102019:	00 00 00 00 
  10201d:	8b 4c 24 18          	mov    ecx,DWORD PTR [esp+0x18]
    if (x == 0)
  102021:	85 c9                	test   ecx,ecx
  102023:	0f 84 97 00 00 00    	je     1020c0 <kernel_main+0x650>
  102029:	31 f6                	xor    esi,esi
  10202b:	b8 01 00 00 00       	mov    eax,0x1
  102030:	89 df                	mov    edi,ebx
  102032:	89 cb                	mov    ebx,ecx
  102034:	90                   	nop
  102035:	90                   	nop
  102036:	90                   	nop
  102037:	90                   	nop
  102038:	90                   	nop
  102039:	90                   	nop
  10203a:	90                   	nop
  10203b:	90                   	nop
  10203c:	90                   	nop
  10203d:	90                   	nop
  10203e:	90                   	nop
  10203f:	90                   	nop
  102040:	89 04 24             	mov    DWORD PTR [esp],eax
  102043:	89 f9                	mov    ecx,edi
        if ((x % B) < 10)
  102045:	89 da                	mov    edx,ebx
  102047:	83 e2 0f             	and    edx,0xf
  10204a:	89 d0                	mov    eax,edx
  10204c:	0c 30                	or     al,0x30
  10204e:	88 dc                	mov    ah,bl
  102050:	80 c4 06             	add    ah,0x6
  102053:	80 e4 0f             	and    ah,0xf
  102056:	80 c4 41             	add    ah,0x41
  102059:	83 fa 0a             	cmp    edx,0xa
  10205c:	0f b6 d0             	movzx  edx,al
  10205f:	0f b6 c4             	movzx  eax,ah
  102062:	0f 42 c2             	cmovb  eax,edx
  102065:	8b 14 24             	mov    edx,DWORD PTR [esp]
        r[a] = i2c(x);
  102068:	88 84 34 10 03 00 00 	mov    BYTE PTR [esp+esi*1+0x310],al
        x /= B;
  10206f:	c1 eb 04             	shr    ebx,0x4
    for (; x > 0; a++) {
  102072:	46                   	inc    esi
  102073:	8d 42 01             	lea    eax,[edx+0x1]
  102076:	47                   	inc    edi
  102077:	85 db                	test   ebx,ebx
  102079:	75 c5                	jne    102040 <kernel_main+0x5d0>
    r[a] = 0;
  10207b:	c6 84 34 10 03 00 00 	mov    BYTE PTR [esp+esi*1+0x310],0x0
  102082:	00 
    for (auto b = 0; b < a / 2; b++) {
  102083:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  102089:	8d 9c 24 10 03 00 00 	lea    ebx,[esp+0x310]
  102090:	74 38                	je     1020ca <kernel_main+0x65a>
  102092:	89 d6                	mov    esi,edx
  102094:	d1 ee                	shr    esi,1
  102096:	89 da                	mov    edx,ebx
  102098:	90                   	nop
  102099:	90                   	nop
  10209a:	90                   	nop
  10209b:	90                   	nop
  10209c:	90                   	nop
  10209d:	90                   	nop
  10209e:	90                   	nop
  10209f:	90                   	nop
        r[b] ^= r[a - b - 1];
  1020a0:	0f b6 02             	movzx  eax,BYTE PTR [edx]
  1020a3:	32 01                	xor    al,BYTE PTR [ecx]
  1020a5:	88 02                	mov    BYTE PTR [edx],al
        r[a - b - 1] ^= r[b];
  1020a7:	32 01                	xor    al,BYTE PTR [ecx]
  1020a9:	88 01                	mov    BYTE PTR [ecx],al
        r[b] ^= r[a - b - 1];
  1020ab:	30 02                	xor    BYTE PTR [edx],al
    for (auto b = 0; b < a / 2; b++) {
  1020ad:	42                   	inc    edx
  1020ae:	49                   	dec    ecx
  1020af:	4e                   	dec    esi
  1020b0:	75 ee                	jne    1020a0 <kernel_main+0x630>
  1020b2:	eb 16                	jmp    1020ca <kernel_main+0x65a>
  1020b4:	90                   	nop
  1020b5:	90                   	nop
  1020b6:	90                   	nop
  1020b7:	90                   	nop
  1020b8:	90                   	nop
  1020b9:	90                   	nop
  1020ba:	90                   	nop
  1020bb:	90                   	nop
  1020bc:	90                   	nop
  1020bd:	90                   	nop
  1020be:	90                   	nop
  1020bf:	90                   	nop
        r[a++] = '0';
  1020c0:	66 c7 84 24 10 03 00 	mov    WORD PTR [esp+0x310],0x30
  1020c7:	00 30 00 
    return r;
  1020ca:	b9 09 00 00 00       	mov    ecx,0x9
  1020cf:	8d 7c 24 28          	lea    edi,[esp+0x28]
  1020d3:	89 de                	mov    esi,ebx
  1020d5:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
    constexpr array() : data_{T()} {}
  1020d7:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  1020de:	00 00 00 00 
  1020e2:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  1020e9:	00 00 00 00 
  1020ed:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  1020f4:	00 00 00 00 
  1020f8:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  1020ff:	00 00 00 00 
  102103:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  10210a:	00 00 00 00 
  10210e:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  102115:	00 00 00 00 
  102119:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  102120:	00 00 00 00 
  102124:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  10212b:	00 00 00 00 
    int index_ = 0;
  10212f:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  102136:	00 00 00 00 
  10213a:	8b 4c 24 1c          	mov    ecx,DWORD PTR [esp+0x1c]
    if (x == 0)
  10213e:	85 c9                	test   ecx,ecx
  102140:	0f 84 9a 00 00 00    	je     1021e0 <kernel_main+0x770>
  102146:	31 f6                	xor    esi,esi
  102148:	b8 01 00 00 00       	mov    eax,0x1
  10214d:	89 df                	mov    edi,ebx
  10214f:	89 cb                	mov    ebx,ecx
  102151:	90                   	nop
  102152:	90                   	nop
  102153:	90                   	nop
  102154:	90                   	nop
  102155:	90                   	nop
  102156:	90                   	nop
  102157:	90                   	nop
  102158:	90                   	nop
  102159:	90                   	nop
  10215a:	90                   	nop
  10215b:	90                   	nop
  10215c:	90                   	nop
  10215d:	90                   	nop
  10215e:	90                   	nop
  10215f:	90                   	nop
  102160:	89 04 24             	mov    DWORD PTR [esp],eax
  102163:	89 f9                	mov    ecx,edi
        if ((x % B) < 10)
  102165:	89 da                	mov    edx,ebx
  102167:	83 e2 0f             	and    edx,0xf
  10216a:	89 d0                	mov    eax,edx
  10216c:	0c 30                	or     al,0x30
  10216e:	88 dc                	mov    ah,bl
  102170:	80 c4 06             	add    ah,0x6
  102173:	80 e4 0f             	and    ah,0xf
  102176:	80 c4 41             	add    ah,0x41
  102179:	83 fa 0a             	cmp    edx,0xa
  10217c:	0f b6 d0             	movzx  edx,al
  10217f:	0f b6 c4             	movzx  eax,ah
  102182:	0f 42 c2             	cmovb  eax,edx
  102185:	8b 14 24             	mov    edx,DWORD PTR [esp]
        r[a] = i2c(x);
  102188:	88 84 34 10 03 00 00 	mov    BYTE PTR [esp+esi*1+0x310],al
        x /= B;
  10218f:	c1 eb 04             	shr    ebx,0x4
    for (; x > 0; a++) {
  102192:	46                   	inc    esi
  102193:	8d 42 01             	lea    eax,[edx+0x1]
  102196:	47                   	inc    edi
  102197:	85 db                	test   ebx,ebx
  102199:	75 c5                	jne    102160 <kernel_main+0x6f0>
    r[a] = 0;
  10219b:	c6 84 34 10 03 00 00 	mov    BYTE PTR [esp+esi*1+0x310],0x0
  1021a2:	00 
    for (auto b = 0; b < a / 2; b++) {
  1021a3:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  1021a9:	8d 9c 24 10 03 00 00 	lea    ebx,[esp+0x310]
  1021b0:	74 38                	je     1021ea <kernel_main+0x77a>
  1021b2:	89 d6                	mov    esi,edx
  1021b4:	d1 ee                	shr    esi,1
  1021b6:	89 da                	mov    edx,ebx
  1021b8:	90                   	nop
  1021b9:	90                   	nop
  1021ba:	90                   	nop
  1021bb:	90                   	nop
  1021bc:	90                   	nop
  1021bd:	90                   	nop
  1021be:	90                   	nop
  1021bf:	90                   	nop
        r[b] ^= r[a - b - 1];
  1021c0:	0f b6 02             	movzx  eax,BYTE PTR [edx]
  1021c3:	32 01                	xor    al,BYTE PTR [ecx]
  1021c5:	88 02                	mov    BYTE PTR [edx],al
        r[a - b - 1] ^= r[b];
  1021c7:	32 01                	xor    al,BYTE PTR [ecx]
  1021c9:	88 01                	mov    BYTE PTR [ecx],al
        r[b] ^= r[a - b - 1];
  1021cb:	30 02                	xor    BYTE PTR [edx],al
    for (auto b = 0; b < a / 2; b++) {
  1021cd:	42                   	inc    edx
  1021ce:	49                   	dec    ecx
  1021cf:	4e                   	dec    esi
  1021d0:	75 ee                	jne    1021c0 <kernel_main+0x750>
  1021d2:	eb 16                	jmp    1021ea <kernel_main+0x77a>
  1021d4:	90                   	nop
  1021d5:	90                   	nop
  1021d6:	90                   	nop
  1021d7:	90                   	nop
  1021d8:	90                   	nop
  1021d9:	90                   	nop
  1021da:	90                   	nop
  1021db:	90                   	nop
  1021dc:	90                   	nop
  1021dd:	90                   	nop
  1021de:	90                   	nop
  1021df:	90                   	nop
        r[a++] = '0';
  1021e0:	66 c7 84 24 10 03 00 	mov    WORD PTR [esp+0x310],0x30
  1021e7:	00 30 00 
    return r;
  1021ea:	b9 09 00 00 00       	mov    ecx,0x9
  1021ef:	8d 84 24 b0 00 00 00 	lea    eax,[esp+0xb0]
  1021f6:	89 c7                	mov    edi,eax
  1021f8:	89 de                	mov    esi,ebx
  1021fa:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
            term::write("Module ", int_to_string(a.index).str(), ": from ",
  1021fc:	68 6d 00 10 00       	push   0x10006d
  102201:	50                   	push   eax
  102202:	68 68 00 10 00       	push   0x100068
  102207:	8d 44 24 34          	lea    eax,[esp+0x34]
  10220b:	50                   	push   eax
  10220c:	68 6f 00 10 00       	push   0x10006f
  102211:	8d 84 24 24 01 00 00 	lea    eax,[esp+0x124]
  102218:	50                   	push   eax
  102219:	68 2e 00 10 00       	push   0x10002e
  10221e:	e8 4d 19 00 00       	call   103b70 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)>
  102223:	83 c4 1c             	add    esp,0x1c
  102226:	6a 20                	push   0x20
  102228:	e8 43 ef ff ff       	call   101170 <term::write(char)>
  10222d:	83 c4 04             	add    esp,0x4
  102230:	8b 74 24 20          	mov    esi,DWORD PTR [esp+0x20]
    for (int a = 0; s[a] != 0; a++) {
  102234:	8a 06                	mov    al,BYTE PTR [esi]
  102236:	84 c0                	test   al,al
  102238:	0f 84 22 fc ff ff    	je     101e60 <kernel_main+0x3f0>
  10223e:	46                   	inc    esi
  10223f:	90                   	nop
        write(s[a]);
  102240:	0f be c0             	movsx  eax,al
  102243:	50                   	push   eax
  102244:	e8 27 ef ff ff       	call   101170 <term::write(char)>
  102249:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10224c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10224f:	46                   	inc    esi
  102250:	84 c0                	test   al,al
  102252:	75 ec                	jne    102240 <kernel_main+0x7d0>
  102254:	e9 07 fc ff ff       	jmp    101e60 <kernel_main+0x3f0>
                        int_to_string<16>(a().mod_end).str(), "\n");
            term::write(" ", reinterpret_cast<const char *>(a().cmdline), "\n");
        }
    }

    if ((mb->flags & 1) == 1) {
  102259:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  10225c:	f6 00 01             	test   BYTE PTR [eax],0x1
  10225f:	0f 84 b7 01 00 00    	je     10241c <kernel_main+0x9ac>
        term::write("Mem size: ",
                    int_to_string(mb->mem_upper * KB / MB).str(),
  102265:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  102268:	8b 58 08             	mov    ebx,DWORD PTR [eax+0x8]
  10226b:	c1 eb 0a             	shr    ebx,0xa
    if (x == 0)
  10226e:	81 e3 ff 0f 00 00    	and    ebx,0xfff
    constexpr array() : data_{T()} {}
  102274:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  10227b:	00 00 00 00 
  10227f:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  102286:	00 00 00 00 
  10228a:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  102291:	00 00 00 00 
  102295:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  10229c:	00 00 00 00 
  1022a0:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  1022a7:	00 00 00 00 
  1022ab:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  1022b2:	00 00 00 00 
  1022b6:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  1022bd:	00 00 00 00 
  1022c1:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  1022c8:	00 00 00 00 
    int index_ = 0;
  1022cc:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  1022d3:	00 00 00 00 
  1022d7:	74 6b                	je     102344 <kernel_main+0x8d4>
    for (; x > 0; a++) {
  1022d9:	8d b4 24 0f 03 00 00 	lea    esi,[esp+0x30f]
  1022e0:	31 ff                	xor    edi,edi
  1022e2:	90                   	nop
  1022e3:	90                   	nop
  1022e4:	90                   	nop
  1022e5:	90                   	nop
  1022e6:	90                   	nop
  1022e7:	90                   	nop
  1022e8:	90                   	nop
  1022e9:	90                   	nop
  1022ea:	90                   	nop
  1022eb:	90                   	nop
  1022ec:	90                   	nop
  1022ed:	90                   	nop
  1022ee:	90                   	nop
  1022ef:	90                   	nop
        x /= B;
  1022f0:	89 d8                	mov    eax,ebx
  1022f2:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  1022f7:	f7 e1                	mul    ecx
  1022f9:	c1 ea 03             	shr    edx,0x3
  1022fc:	8d 04 12             	lea    eax,[edx+edx*1]
  1022ff:	8d 04 80             	lea    eax,[eax+eax*4]
  102302:	89 d9                	mov    ecx,ebx
  102304:	29 c1                	sub    ecx,eax
            return '0' + (x % B);
  102306:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  102309:	88 4e 01             	mov    BYTE PTR [esi+0x1],cl
  10230c:	46                   	inc    esi
    for (; x > 0; a++) {
  10230d:	47                   	inc    edi
  10230e:	83 fb 09             	cmp    ebx,0x9
  102311:	89 d3                	mov    ebx,edx
  102313:	77 db                	ja     1022f0 <kernel_main+0x880>
    r[a] = 0;
  102315:	c6 46 01 00          	mov    BYTE PTR [esi+0x1],0x0
    for (auto b = 0; b < a / 2; b++) {
  102319:	f7 c7 fe ff ff ff    	test   edi,0xfffffffe
  10231f:	8d 8c 24 10 03 00 00 	lea    ecx,[esp+0x310]
  102326:	74 26                	je     10234e <kernel_main+0x8de>
  102328:	d1 ef                	shr    edi,1
  10232a:	90                   	nop
  10232b:	90                   	nop
  10232c:	90                   	nop
  10232d:	90                   	nop
  10232e:	90                   	nop
  10232f:	90                   	nop
        r[b] ^= r[a - b - 1];
  102330:	0f b6 01             	movzx  eax,BYTE PTR [ecx]
  102333:	32 06                	xor    al,BYTE PTR [esi]
  102335:	88 01                	mov    BYTE PTR [ecx],al
        r[a - b - 1] ^= r[b];
  102337:	32 06                	xor    al,BYTE PTR [esi]
  102339:	88 06                	mov    BYTE PTR [esi],al
        r[b] ^= r[a - b - 1];
  10233b:	30 01                	xor    BYTE PTR [ecx],al
    for (auto b = 0; b < a / 2; b++) {
  10233d:	41                   	inc    ecx
  10233e:	4e                   	dec    esi
  10233f:	4f                   	dec    edi
  102340:	75 ee                	jne    102330 <kernel_main+0x8c0>
  102342:	eb 0a                	jmp    10234e <kernel_main+0x8de>
        r[a++] = '0';
  102344:	66 c7 84 24 10 03 00 	mov    WORD PTR [esp+0x310],0x30
  10234b:	00 30 00 
  10234e:	8d bc 24 10 01 00 00 	lea    edi,[esp+0x110]
  102355:	8d b4 24 10 03 00 00 	lea    esi,[esp+0x310]
    return r;
  10235c:	b9 09 00 00 00       	mov    ecx,0x9
  102361:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
        write(s[a]);
  102363:	6a 4d                	push   0x4d
  102365:	e8 06 ee ff ff       	call   101170 <term::write(char)>
  10236a:	83 c4 04             	add    esp,0x4
  10236d:	6a 65                	push   0x65
  10236f:	e8 fc ed ff ff       	call   101170 <term::write(char)>
  102374:	83 c4 04             	add    esp,0x4
  102377:	6a 6d                	push   0x6d
  102379:	e8 f2 ed ff ff       	call   101170 <term::write(char)>
  10237e:	83 c4 04             	add    esp,0x4
  102381:	6a 20                	push   0x20
  102383:	e8 e8 ed ff ff       	call   101170 <term::write(char)>
  102388:	83 c4 04             	add    esp,0x4
  10238b:	6a 73                	push   0x73
  10238d:	e8 de ed ff ff       	call   101170 <term::write(char)>
  102392:	83 c4 04             	add    esp,0x4
  102395:	6a 69                	push   0x69
  102397:	e8 d4 ed ff ff       	call   101170 <term::write(char)>
  10239c:	83 c4 04             	add    esp,0x4
  10239f:	6a 7a                	push   0x7a
  1023a1:	e8 ca ed ff ff       	call   101170 <term::write(char)>
  1023a6:	83 c4 04             	add    esp,0x4
  1023a9:	6a 65                	push   0x65
  1023ab:	e8 c0 ed ff ff       	call   101170 <term::write(char)>
  1023b0:	83 c4 04             	add    esp,0x4
  1023b3:	6a 3a                	push   0x3a
  1023b5:	e8 b6 ed ff ff       	call   101170 <term::write(char)>
  1023ba:	83 c4 04             	add    esp,0x4
  1023bd:	6a 20                	push   0x20
  1023bf:	e8 ac ed ff ff       	call   101170 <term::write(char)>
  1023c4:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  1023c7:	8a 84 24 10 01 00 00 	mov    al,BYTE PTR [esp+0x110]
  1023ce:	84 c0                	test   al,al
  1023d0:	74 22                	je     1023f4 <kernel_main+0x984>
  1023d2:	8d b4 24 11 01 00 00 	lea    esi,[esp+0x111]
  1023d9:	90                   	nop
  1023da:	90                   	nop
  1023db:	90                   	nop
  1023dc:	90                   	nop
  1023dd:	90                   	nop
  1023de:	90                   	nop
  1023df:	90                   	nop
        write(s[a]);
  1023e0:	0f be c0             	movsx  eax,al
  1023e3:	50                   	push   eax
  1023e4:	e8 87 ed ff ff       	call   101170 <term::write(char)>
  1023e9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  1023ec:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  1023ef:	46                   	inc    esi
  1023f0:	84 c0                	test   al,al
  1023f2:	75 ec                	jne    1023e0 <kernel_main+0x970>
        write(s[a]);
  1023f4:	6a 20                	push   0x20
  1023f6:	e8 75 ed ff ff       	call   101170 <term::write(char)>
  1023fb:	83 c4 04             	add    esp,0x4
  1023fe:	6a 4d                	push   0x4d
  102400:	e8 6b ed ff ff       	call   101170 <term::write(char)>
  102405:	83 c4 04             	add    esp,0x4
  102408:	6a 42                	push   0x42
  10240a:	e8 61 ed ff ff       	call   101170 <term::write(char)>
  10240f:	83 c4 04             	add    esp,0x4
  102412:	6a 0a                	push   0xa
  102414:	e8 57 ed ff ff       	call   101170 <term::write(char)>
  102419:	83 c4 04             	add    esp,0x4
  10241c:	6a 50                	push   0x50
  10241e:	e8 4d ed ff ff       	call   101170 <term::write(char)>
  102423:	83 c4 04             	add    esp,0x4
  102426:	6a 53                	push   0x53
  102428:	e8 43 ed ff ff       	call   101170 <term::write(char)>
  10242d:	83 c4 04             	add    esp,0x4
  102430:	6a 2f                	push   0x2f
  102432:	e8 39 ed ff ff       	call   101170 <term::write(char)>
  102437:	83 c4 04             	add    esp,0x4
  10243a:	6a 32                	push   0x32
  10243c:	e8 2f ed ff ff       	call   101170 <term::write(char)>
  102441:	83 c4 04             	add    esp,0x4
  102444:	6a 3a                	push   0x3a
  102446:	e8 25 ed ff ff       	call   101170 <term::write(char)>
  10244b:	83 c4 04             	add    esp,0x4
  10244e:	6a 20                	push   0x20
  102450:	e8 1b ed ff ff       	call   101170 <term::write(char)>
  102455:	83 c4 04             	add    esp,0x4
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  102458:	66 ba 64 00          	mov    dx,0x64
  10245c:	b0 ad                	mov    al,0xad
  10245e:	ee                   	out    dx,al
  10245f:	66 ba 64 00          	mov    dx,0x64
  102463:	b0 a7                	mov    al,0xa7
  102465:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  102466:	66 ba 64 00          	mov    dx,0x64
  10246a:	ec                   	in     al,dx
  10246b:	a8 01                	test   al,0x1
    while (has_output_data())
  10246d:	74 0f                	je     10247e <kernel_main+0xa0e>
  10246f:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  102470:	66 ba 60 00          	mov    dx,0x60
  102474:	ec                   	in     al,dx
  102475:	66 ba 64 00          	mov    dx,0x64
  102479:	ec                   	in     al,dx
  10247a:	a8 01                	test   al,0x1
    while (has_output_data())
  10247c:	75 f2                	jne    102470 <kernel_main+0xa00>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10247e:	66 ba 64 00          	mov    dx,0x64
  102482:	b0 20                	mov    al,0x20
  102484:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  102485:	66 ba 60 00          	mov    dx,0x60
  102489:	ec                   	in     al,dx
  10248a:	89 c1                	mov    ecx,eax
    cb &= 0b10111100; // disable interrupts and translation
  10248c:	80 e1 bc             	and    cl,0xbc
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10248f:	66 ba 64 00          	mov    dx,0x64
  102493:	b0 60                	mov    al,0x60
  102495:	ee                   	out    dx,al
  102496:	66 ba 60 00          	mov    dx,0x60
  10249a:	89 c8                	mov    eax,ecx
  10249c:	ee                   	out    dx,al
  10249d:	66 ba 64 00          	mov    dx,0x64
  1024a1:	b0 aa                	mov    al,0xaa
  1024a3:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1024a4:	66 ba 60 00          	mov    dx,0x60
  1024a8:	ec                   	in     al,dx
    return receive(DATA) == 0x55;
  1024a9:	3c 55                	cmp    al,0x55
    if (!(ps2::test_controller() && ps2::test_port_1()))
  1024ab:	0f 85 71 13 00 00    	jne    103822 <kernel_main+0x1db2>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1024b1:	66 ba 64 00          	mov    dx,0x64
  1024b5:	b0 ab                	mov    al,0xab
  1024b7:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1024b8:	66 ba 60 00          	mov    dx,0x60
  1024bc:	ec                   	in     al,dx
    return receive(DATA) == 0x00;
  1024bd:	84 c0                	test   al,al
    if (!(ps2::test_controller() && ps2::test_port_1()))
  1024bf:	0f 85 5d 13 00 00    	jne    103822 <kernel_main+0x1db2>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1024c5:	66 ba 64 00          	mov    dx,0x64
  1024c9:	b0 ae                	mov    al,0xae
  1024cb:	ee                   	out    dx,al
  1024cc:	66 ba 60 00          	mov    dx,0x60
  1024d0:	b0 ff                	mov    al,0xff
  1024d2:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1024d3:	66 ba 60 00          	mov    dx,0x60
  1024d7:	ec                   	in     al,dx
  1024d8:	66 ba 60 00          	mov    dx,0x60
  1024dc:	ec                   	in     al,dx
    return receive(DATA) == 0xAA;
  1024dd:	3c aa                	cmp    al,0xaa
    if (!ps2::reset_1())
  1024df:	0f 85 3d 13 00 00    	jne    103822 <kernel_main+0x1db2>
  1024e5:	8b 75 10             	mov    esi,DWORD PTR [ebp+0x10]
  1024e8:	6a 4f                	push   0x4f
  1024ea:	e8 81 ec ff ff       	call   101170 <term::write(char)>
  1024ef:	83 c4 04             	add    esp,0x4
  1024f2:	6a 4b                	push   0x4b
  1024f4:	e8 77 ec ff ff       	call   101170 <term::write(char)>
  1024f9:	83 c4 04             	add    esp,0x4
  1024fc:	6a 0a                	push   0xa
  1024fe:	e8 6d ec ff ff       	call   101170 <term::write(char)>
  102503:	83 c4 04             	add    esp,0x4
  102506:	8d 84 24 18 03 00 00 	lea    eax,[esp+0x318]
  10250d:	68 c0 09 00 00       	push   0x9c0
  102512:	6a 00                	push   0x0
  102514:	50                   	push   eax
  102515:	e8 f6 ea ff ff       	call   101010 <memset>
  10251a:	83 c4 0c             	add    esp,0xc
    array<uint32, N> mt; /* the array for the state vector  */
    uint32 mti = N + 1;  /* mti==N+1 means mt[N] is not initialized */

  public:
    random_gen(uint32 seed = 5489) {
        mt[0] = seed & static_cast<uint32>(~0);
  10251d:	89 b4 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],esi
        for (mti = 1; mti < N; mti++) {
            mt[mti] =
                (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
  102524:	89 f0                	mov    eax,esi
  102526:	c1 e8 1e             	shr    eax,0x1e
  102529:	31 f0                	xor    eax,esi
  10252b:	69 c0 65 89 07 6c    	imul   eax,eax,0x6c078965
  102531:	40                   	inc    eax
            mt[mti] =
  102532:	89 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],eax
                (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
  102539:	89 c1                	mov    ecx,eax
  10253b:	c1 e9 1e             	shr    ecx,0x1e
  10253e:	31 c1                	xor    ecx,eax
  102540:	69 c1 65 89 07 6c    	imul   eax,ecx,0x6c078965
  102546:	83 c0 02             	add    eax,0x2
            mt[mti] =
  102549:	89 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],eax
  102550:	c7 84 24 d8 0c 00 00 	mov    DWORD PTR [esp+0xcd8],0x3
  102557:	03 00 00 00 
  10255b:	31 c0                	xor    eax,eax
        for (mti = 1; mti < N; mti++) {
  10255d:	84 c0                	test   al,al
  10255f:	75 44                	jne    1025a5 <kernel_main+0xb35>
  102561:	b9 02 00 00 00       	mov    ecx,0x2
  102566:	b8 03 00 00 00       	mov    eax,0x3
  10256b:	90                   	nop
  10256c:	90                   	nop
  10256d:	90                   	nop
  10256e:	90                   	nop
  10256f:	90                   	nop
                (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
  102570:	8b 8c 8c 10 03 00 00 	mov    ecx,DWORD PTR [esp+ecx*4+0x310]
  102577:	89 ca                	mov    edx,ecx
  102579:	c1 ea 1e             	shr    edx,0x1e
  10257c:	31 ca                	xor    edx,ecx
  10257e:	69 ca 65 89 07 6c    	imul   ecx,edx,0x6c078965
  102584:	01 c1                	add    ecx,eax
            mt[mti] =
  102586:	89 8c 84 10 03 00 00 	mov    DWORD PTR [esp+eax*4+0x310],ecx
            mt[mti] &= static_cast<uint32>(~0);
  10258d:	8b 8c 24 d8 0c 00 00 	mov    ecx,DWORD PTR [esp+0xcd8]
        for (mti = 1; mti < N; mti++) {
  102594:	8d 41 01             	lea    eax,[ecx+0x1]
  102597:	89 84 24 d8 0c 00 00 	mov    DWORD PTR [esp+0xcd8],eax
  10259e:	3d 70 02 00 00       	cmp    eax,0x270
  1025a3:	72 cb                	jb     102570 <kernel_main+0xb00>
  1025a5:	8d 9c 24 10 03 00 00 	lea    ebx,[esp+0x310]
  1025ac:	eb 12                	jmp    1025c0 <kernel_main+0xb50>
    constexpr bool operator==(const char *p) const {
        for (int a = 0; a < length(); a++) {
            if (p[a] == 0 || p[a] != this->operator[](a))
                return false;
        }
        return p[length()] == 0;
  1025ae:	85 c0                	test   eax,eax
            }
            term::terminal.flipped = false;
            term::terminal.wrap = false;
            term::terminal.set_colour(term::WHITE);
        }
        if (command == "coredump") {
  1025b0:	0f 84 1a 04 00 00    	je     1029d0 <kernel_main+0xf60>
  1025b6:	90                   	nop
  1025b7:	90                   	nop
  1025b8:	90                   	nop
  1025b9:	90                   	nop
  1025ba:	90                   	nop
  1025bb:	90                   	nop
  1025bc:	90                   	nop
  1025bd:	90                   	nop
  1025be:	90                   	nop
  1025bf:	90                   	nop
  1025c0:	6a 3e                	push   0x3e
  1025c2:	e8 a9 eb ff ff       	call   101170 <term::write(char)>
  1025c7:	83 c4 04             	add    esp,0x4
  1025ca:	6a 20                	push   0x20
  1025cc:	e8 9f eb ff ff       	call   101170 <term::write(char)>
  1025d1:	83 c4 04             	add    esp,0x4
  1025d4:	6a 20                	push   0x20
  1025d6:	e8 95 eb ff ff       	call   101170 <term::write(char)>
  1025db:	83 c4 04             	add    esp,0x4
        auto &&line = kbd::get_line();
  1025de:	6a 01                	push   0x1
  1025e0:	e8 fb f2 ff ff       	call   1018e0 <kbd::get_line(bool)>
  1025e5:	83 c4 04             	add    esp,0x4
  1025e8:	31 d2                	xor    edx,edx
    constexpr array() : data_{T()} {}
  1025ea:	31 c0                	xor    eax,eax
  1025ec:	b9 14 00 00 00       	mov    ecx,0x14
  1025f1:	8d bc 24 10 01 00 00 	lea    edi,[esp+0x110]
  1025f8:	f3 ab                	rep stos DWORD PTR es:[edi],eax
  1025fa:	c6 84 24 60 01 00 00 	mov    BYTE PTR [esp+0x160],0x0
  102601:	00 
    int index_ = 0;
  102602:	c7 84 24 64 01 00 00 	mov    DWORD PTR [esp+0x164],0x0
  102609:	00 00 00 00 
  10260d:	90                   	nop
  10260e:	90                   	nop
  10260f:	90                   	nop
     */
    const char *str() const { return this->data_; }

    constexpr auto length() const {
        for (int a = 0; a < N; a++) {
            if (this->operator[](a) == 0)
  102610:	80 ba 00 70 11 00 00 	cmp    BYTE PTR [edx+0x117000],0x0
  102617:	74 0b                	je     102624 <kernel_main+0xbb4>
        for (int a = 0; a < N; a++) {
  102619:	42                   	inc    edx
  10261a:	83 fa 50             	cmp    edx,0x50
  10261d:	75 f1                	jne    102610 <kernel_main+0xba0>
  10261f:	ba 50 00 00 00       	mov    edx,0x50
        return ptr_ != p.ptr_;
  102624:	85 d2                	test   edx,edx

    constexpr optional<string<N>> extract_word(int num,
                                               char separator = ' ') const {
        string<N> r;
        int seps = 0, i = 0;
        for (auto a : *this) {
  102626:	74 4c                	je     102674 <kernel_main+0xc04>
  102628:	31 c0                	xor    eax,eax
  10262a:	31 f6                	xor    esi,esi
  10262c:	31 ff                	xor    edi,edi
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  10262e:	8a 88 00 70 11 00    	mov    cl,BYTE PTR [eax+0x117000]
            if (a == separator) {
  102634:	80 f9 20             	cmp    cl,0x20
  102637:	75 18                	jne    102651 <kernel_main+0xbe1>
  102639:	90                   	nop
  10263a:	90                   	nop
  10263b:	90                   	nop
  10263c:	90                   	nop
  10263d:	90                   	nop
  10263e:	90                   	nop
  10263f:	90                   	nop
                seps++;
  102640:	46                   	inc    esi
        return ptr_ != p.ptr_;
  102641:	40                   	inc    eax
  102642:	39 c2                	cmp    edx,eax
        for (auto a : *this) {
  102644:	74 2a                	je     102670 <kernel_main+0xc00>
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  102646:	8a 88 00 70 11 00    	mov    cl,BYTE PTR [eax+0x117000]
            if (a == separator) {
  10264c:	80 f9 20             	cmp    cl,0x20
  10264f:	74 ef                	je     102640 <kernel_main+0xbd0>
            } else if (seps == num) {
  102651:	85 f6                	test   esi,esi
  102653:	75 ec                	jne    102641 <kernel_main+0xbd1>
                r[i++] = a();
  102655:	88 8c 3c 10 01 00 00 	mov    BYTE PTR [esp+edi*1+0x110],cl
  10265c:	47                   	inc    edi
  10265d:	31 f6                	xor    esi,esi
        return ptr_ != p.ptr_;
  10265f:	40                   	inc    eax
  102660:	39 c2                	cmp    edx,eax
        for (auto a : *this) {
  102662:	75 e2                	jne    102646 <kernel_main+0xbd6>
  102664:	90                   	nop
  102665:	90                   	nop
  102666:	90                   	nop
  102667:	90                   	nop
  102668:	90                   	nop
  102669:	90                   	nop
  10266a:	90                   	nop
  10266b:	90                   	nop
  10266c:	90                   	nop
  10266d:	90                   	nop
  10266e:	90                   	nop
  10266f:	90                   	nop
                // r[a.index] = a(); // TODO fix
            }
        }
        if (seps < num)
  102670:	85 f6                	test   esi,esi
  102672:	78 1c                	js     102690 <kernel_main+0xc20>
    return static_cast<remove_ref<T> &&>(t);
  102674:	b9 16 00 00 00       	mov    ecx,0x16
  102679:	8d 7c 24 2c          	lea    edi,[esp+0x2c]
  10267d:	8d 84 24 10 01 00 00 	lea    eax,[esp+0x110]
  102684:	89 c6                	mov    esi,eax
  102686:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  102688:	89 c7                	mov    edi,eax
  10268a:	b2 01                	mov    dl,0x1
  10268c:	eb 1a                	jmp    1026a8 <kernel_main+0xc38>
  10268e:	90                   	nop
  10268f:	90                   	nop
  102690:	31 d2                	xor    edx,edx
    constexpr optional() : value() {}
  102692:	31 c0                	xor    eax,eax
  102694:	b9 16 00 00 00       	mov    ecx,0x16
  102699:	8d 7c 24 2c          	lea    edi,[esp+0x2c]
  10269d:	f3 ab                	rep stos DWORD PTR es:[edi],eax
  10269f:	8d 84 24 10 01 00 00 	lea    eax,[esp+0x110]
  1026a6:	89 c7                	mov    edi,eax
    bool loaded_ = false;
  1026a8:	88 54 24 28          	mov    BYTE PTR [esp+0x28],dl
    const char *const err = "(Unknown error)";
  1026ac:	c7 84 24 84 00 00 00 	mov    DWORD PTR [esp+0x84],0x100044
  1026b3:	44 00 10 00 
  1026b7:	31 d2                	xor    edx,edx
    constexpr array() : data_{T()} {}
  1026b9:	31 c0                	xor    eax,eax
  1026bb:	b9 14 00 00 00       	mov    ecx,0x14
  1026c0:	f3 ab                	rep stos DWORD PTR es:[edi],eax
  1026c2:	c6 84 24 60 01 00 00 	mov    BYTE PTR [esp+0x160],0x0
  1026c9:	00 
    int index_ = 0;
  1026ca:	c7 84 24 64 01 00 00 	mov    DWORD PTR [esp+0x164],0x0
  1026d1:	00 00 00 00 
  1026d5:	90                   	nop
  1026d6:	90                   	nop
  1026d7:	90                   	nop
  1026d8:	90                   	nop
  1026d9:	90                   	nop
  1026da:	90                   	nop
  1026db:	90                   	nop
  1026dc:	90                   	nop
  1026dd:	90                   	nop
  1026de:	90                   	nop
  1026df:	90                   	nop
            if (this->operator[](a) == 0)
  1026e0:	80 ba 00 70 11 00 00 	cmp    BYTE PTR [edx+0x117000],0x0
  1026e7:	74 0b                	je     1026f4 <kernel_main+0xc84>
        for (int a = 0; a < N; a++) {
  1026e9:	42                   	inc    edx
  1026ea:	83 fa 50             	cmp    edx,0x50
  1026ed:	75 f1                	jne    1026e0 <kernel_main+0xc70>
  1026ef:	ba 50 00 00 00       	mov    edx,0x50
        return ptr_ != p.ptr_;
  1026f4:	85 d2                	test   edx,edx
        for (auto a : *this) {
  1026f6:	74 68                	je     102760 <kernel_main+0xcf0>
  1026f8:	31 c0                	xor    eax,eax
  1026fa:	31 f6                	xor    esi,esi
  1026fc:	31 ff                	xor    edi,edi
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  1026fe:	8a 88 00 70 11 00    	mov    cl,BYTE PTR [eax+0x117000]
            if (a == separator) {
  102704:	80 f9 20             	cmp    cl,0x20
  102707:	75 18                	jne    102721 <kernel_main+0xcb1>
  102709:	90                   	nop
  10270a:	90                   	nop
  10270b:	90                   	nop
  10270c:	90                   	nop
  10270d:	90                   	nop
  10270e:	90                   	nop
  10270f:	90                   	nop
                seps++;
  102710:	46                   	inc    esi
        return ptr_ != p.ptr_;
  102711:	40                   	inc    eax
  102712:	39 c2                	cmp    edx,eax
        for (auto a : *this) {
  102714:	74 22                	je     102738 <kernel_main+0xcc8>
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  102716:	8a 88 00 70 11 00    	mov    cl,BYTE PTR [eax+0x117000]
            if (a == separator) {
  10271c:	80 f9 20             	cmp    cl,0x20
  10271f:	74 ef                	je     102710 <kernel_main+0xca0>
            } else if (seps == num) {
  102721:	83 fe 01             	cmp    esi,0x1
  102724:	75 eb                	jne    102711 <kernel_main+0xca1>
                r[i++] = a();
  102726:	88 8c 3c 10 01 00 00 	mov    BYTE PTR [esp+edi*1+0x110],cl
  10272d:	47                   	inc    edi
  10272e:	be 01 00 00 00       	mov    esi,0x1
        return ptr_ != p.ptr_;
  102733:	40                   	inc    eax
  102734:	39 c2                	cmp    edx,eax
        for (auto a : *this) {
  102736:	75 de                	jne    102716 <kernel_main+0xca6>
        if (seps < num)
  102738:	85 f6                	test   esi,esi
  10273a:	7e 24                	jle    102760 <kernel_main+0xcf0>
  10273c:	b9 16 00 00 00       	mov    ecx,0x16
  102741:	8d bc 24 b4 00 00 00 	lea    edi,[esp+0xb4]
  102748:	8d b4 24 10 01 00 00 	lea    esi,[esp+0x110]
  10274f:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  102751:	b2 01                	mov    dl,0x1
  102753:	eb 1d                	jmp    102772 <kernel_main+0xd02>
  102755:	90                   	nop
  102756:	90                   	nop
  102757:	90                   	nop
  102758:	90                   	nop
  102759:	90                   	nop
  10275a:	90                   	nop
  10275b:	90                   	nop
  10275c:	90                   	nop
  10275d:	90                   	nop
  10275e:	90                   	nop
  10275f:	90                   	nop
  102760:	31 d2                	xor    edx,edx
    constexpr optional() : value() {}
  102762:	31 c0                	xor    eax,eax
  102764:	b9 16 00 00 00       	mov    ecx,0x16
  102769:	8d bc 24 b4 00 00 00 	lea    edi,[esp+0xb4]
  102770:	f3 ab                	rep stos DWORD PTR es:[edi],eax
    bool loaded_ = false;
  102772:	88 94 24 b0 00 00 00 	mov    BYTE PTR [esp+0xb0],dl
    const char *const err = "(Unknown error)";
  102779:	c7 84 24 0c 01 00 00 	mov    DWORD PTR [esp+0x10c],0x100044
  102780:	44 00 10 00 
  102784:	31 c0                	xor    eax,eax
  102786:	90                   	nop
  102787:	90                   	nop
  102788:	90                   	nop
  102789:	90                   	nop
  10278a:	90                   	nop
  10278b:	90                   	nop
  10278c:	90                   	nop
  10278d:	90                   	nop
  10278e:	90                   	nop
  10278f:	90                   	nop
  102790:	31 c9                	xor    ecx,ecx
  102792:	90                   	nop
  102793:	90                   	nop
  102794:	90                   	nop
  102795:	90                   	nop
  102796:	90                   	nop
  102797:	90                   	nop
  102798:	90                   	nop
  102799:	90                   	nop
  10279a:	90                   	nop
  10279b:	90                   	nop
  10279c:	90                   	nop
  10279d:	90                   	nop
  10279e:	90                   	nop
  10279f:	90                   	nop
            if (this->operator[](a) == 0)
  1027a0:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  1027a5:	74 0b                	je     1027b2 <kernel_main+0xd42>
        for (int a = 0; a < N; a++) {
  1027a7:	41                   	inc    ecx
  1027a8:	83 f9 50             	cmp    ecx,0x50
  1027ab:	75 f3                	jne    1027a0 <kernel_main+0xd30>
  1027ad:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  1027b2:	39 c8                	cmp    eax,ecx
  1027b4:	73 1a                	jae    1027d0 <kernel_main+0xd60>
            if (p[a] == 0 || p[a] != this->operator[](a))
  1027b6:	83 f8 04             	cmp    eax,0x4
  1027b9:	74 45                	je     102800 <kernel_main+0xd90>
  1027bb:	8a 88 36 00 10 00    	mov    cl,BYTE PTR [eax+0x100036]
  1027c1:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  1027c5:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  1027c8:	74 c6                	je     102790 <kernel_main+0xd20>
  1027ca:	eb 34                	jmp    102800 <kernel_main+0xd90>
  1027cc:	90                   	nop
  1027cd:	90                   	nop
  1027ce:	90                   	nop
  1027cf:	90                   	nop
  1027d0:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  1027d5:	90                   	nop
  1027d6:	90                   	nop
  1027d7:	90                   	nop
  1027d8:	90                   	nop
  1027d9:	90                   	nop
  1027da:	90                   	nop
  1027db:	90                   	nop
  1027dc:	90                   	nop
  1027dd:	90                   	nop
  1027de:	90                   	nop
  1027df:	90                   	nop
            if (this->operator[](a) == 0)
  1027e0:	80 7c 04 30 00       	cmp    BYTE PTR [esp+eax*1+0x30],0x0
  1027e5:	74 08                	je     1027ef <kernel_main+0xd7f>
        for (int a = 0; a < N; a++) {
  1027e7:	40                   	inc    eax
  1027e8:	83 f8 4c             	cmp    eax,0x4c
  1027eb:	75 f3                	jne    1027e0 <kernel_main+0xd70>
  1027ed:	eb 11                	jmp    102800 <kernel_main+0xd90>
        return p[length()] == 0;
  1027ef:	85 c0                	test   eax,eax
        if (command == "exit") {
  1027f1:	0f 84 8f 0f 00 00    	je     103786 <kernel_main+0x1d16>
  1027f7:	90                   	nop
  1027f8:	90                   	nop
  1027f9:	90                   	nop
  1027fa:	90                   	nop
  1027fb:	90                   	nop
  1027fc:	90                   	nop
  1027fd:	90                   	nop
  1027fe:	90                   	nop
  1027ff:	90                   	nop
  102800:	31 c0                	xor    eax,eax
  102802:	90                   	nop
  102803:	90                   	nop
  102804:	90                   	nop
  102805:	90                   	nop
  102806:	90                   	nop
  102807:	90                   	nop
  102808:	90                   	nop
  102809:	90                   	nop
  10280a:	90                   	nop
  10280b:	90                   	nop
  10280c:	90                   	nop
  10280d:	90                   	nop
  10280e:	90                   	nop
  10280f:	90                   	nop
  102810:	31 c9                	xor    ecx,ecx
  102812:	90                   	nop
  102813:	90                   	nop
  102814:	90                   	nop
  102815:	90                   	nop
  102816:	90                   	nop
  102817:	90                   	nop
  102818:	90                   	nop
  102819:	90                   	nop
  10281a:	90                   	nop
  10281b:	90                   	nop
  10281c:	90                   	nop
  10281d:	90                   	nop
  10281e:	90                   	nop
  10281f:	90                   	nop
            if (this->operator[](a) == 0)
  102820:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102825:	74 0b                	je     102832 <kernel_main+0xdc2>
        for (int a = 0; a < N; a++) {
  102827:	41                   	inc    ecx
  102828:	83 f9 50             	cmp    ecx,0x50
  10282b:	75 f3                	jne    102820 <kernel_main+0xdb0>
  10282d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  102832:	39 c8                	cmp    eax,ecx
  102834:	73 1a                	jae    102850 <kernel_main+0xde0>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102836:	83 f8 05             	cmp    eax,0x5
  102839:	74 45                	je     102880 <kernel_main+0xe10>
  10283b:	8a 88 7c 00 10 00    	mov    cl,BYTE PTR [eax+0x10007c]
  102841:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  102845:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102848:	74 c6                	je     102810 <kernel_main+0xda0>
  10284a:	eb 34                	jmp    102880 <kernel_main+0xe10>
  10284c:	90                   	nop
  10284d:	90                   	nop
  10284e:	90                   	nop
  10284f:	90                   	nop
  102850:	b8 fb ff ff ff       	mov    eax,0xfffffffb
  102855:	90                   	nop
  102856:	90                   	nop
  102857:	90                   	nop
  102858:	90                   	nop
  102859:	90                   	nop
  10285a:	90                   	nop
  10285b:	90                   	nop
  10285c:	90                   	nop
  10285d:	90                   	nop
  10285e:	90                   	nop
  10285f:	90                   	nop
            if (this->operator[](a) == 0)
  102860:	80 7c 04 31 00       	cmp    BYTE PTR [esp+eax*1+0x31],0x0
  102865:	74 08                	je     10286f <kernel_main+0xdff>
        for (int a = 0; a < N; a++) {
  102867:	40                   	inc    eax
  102868:	83 f8 4b             	cmp    eax,0x4b
  10286b:	75 f3                	jne    102860 <kernel_main+0xdf0>
  10286d:	eb 11                	jmp    102880 <kernel_main+0xe10>
        return p[length()] == 0;
  10286f:	85 c0                	test   eax,eax
        if (command == "reset") {
  102871:	75 0d                	jne    102880 <kernel_main+0xe10>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  102873:	66 ba 64 00          	mov    dx,0x64
  102877:	b0 fe                	mov    al,0xfe
  102879:	ee                   	out    dx,al
  10287a:	90                   	nop
  10287b:	90                   	nop
  10287c:	90                   	nop
  10287d:	90                   	nop
  10287e:	90                   	nop
  10287f:	90                   	nop
  102880:	31 c0                	xor    eax,eax
  102882:	90                   	nop
  102883:	90                   	nop
  102884:	90                   	nop
  102885:	90                   	nop
  102886:	90                   	nop
  102887:	90                   	nop
  102888:	90                   	nop
  102889:	90                   	nop
  10288a:	90                   	nop
  10288b:	90                   	nop
  10288c:	90                   	nop
  10288d:	90                   	nop
  10288e:	90                   	nop
  10288f:	90                   	nop
  102890:	31 c9                	xor    ecx,ecx
  102892:	90                   	nop
  102893:	90                   	nop
  102894:	90                   	nop
  102895:	90                   	nop
  102896:	90                   	nop
  102897:	90                   	nop
  102898:	90                   	nop
  102899:	90                   	nop
  10289a:	90                   	nop
  10289b:	90                   	nop
  10289c:	90                   	nop
  10289d:	90                   	nop
  10289e:	90                   	nop
  10289f:	90                   	nop
            if (this->operator[](a) == 0)
  1028a0:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  1028a5:	74 0b                	je     1028b2 <kernel_main+0xe42>
        for (int a = 0; a < N; a++) {
  1028a7:	41                   	inc    ecx
  1028a8:	83 f9 50             	cmp    ecx,0x50
  1028ab:	75 f3                	jne    1028a0 <kernel_main+0xe30>
  1028ad:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  1028b2:	39 c8                	cmp    eax,ecx
  1028b4:	73 1a                	jae    1028d0 <kernel_main+0xe60>
            if (p[a] == 0 || p[a] != this->operator[](a))
  1028b6:	83 f8 05             	cmp    eax,0x5
  1028b9:	74 45                	je     102900 <kernel_main+0xe90>
  1028bb:	8a 88 54 00 10 00    	mov    cl,BYTE PTR [eax+0x100054]
  1028c1:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  1028c5:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  1028c8:	74 c6                	je     102890 <kernel_main+0xe20>
  1028ca:	eb 34                	jmp    102900 <kernel_main+0xe90>
  1028cc:	90                   	nop
  1028cd:	90                   	nop
  1028ce:	90                   	nop
  1028cf:	90                   	nop
  1028d0:	b8 fb ff ff ff       	mov    eax,0xfffffffb
  1028d5:	90                   	nop
  1028d6:	90                   	nop
  1028d7:	90                   	nop
  1028d8:	90                   	nop
  1028d9:	90                   	nop
  1028da:	90                   	nop
  1028db:	90                   	nop
  1028dc:	90                   	nop
  1028dd:	90                   	nop
  1028de:	90                   	nop
  1028df:	90                   	nop
            if (this->operator[](a) == 0)
  1028e0:	80 7c 04 31 00       	cmp    BYTE PTR [esp+eax*1+0x31],0x0
  1028e5:	74 08                	je     1028ef <kernel_main+0xe7f>
        for (int a = 0; a < N; a++) {
  1028e7:	40                   	inc    eax
  1028e8:	83 f8 4b             	cmp    eax,0x4b
  1028eb:	75 f3                	jne    1028e0 <kernel_main+0xe70>
  1028ed:	eb 11                	jmp    102900 <kernel_main+0xe90>
        return p[length()] == 0;
  1028ef:	85 c0                	test   eax,eax
        if (command == "clear") {
  1028f1:	75 0d                	jne    102900 <kernel_main+0xe90>
            term::clear();
  1028f3:	e8 88 e7 ff ff       	call   101080 <term::clear()>
  1028f8:	90                   	nop
  1028f9:	90                   	nop
  1028fa:	90                   	nop
  1028fb:	90                   	nop
  1028fc:	90                   	nop
  1028fd:	90                   	nop
  1028fe:	90                   	nop
  1028ff:	90                   	nop
  102900:	31 c0                	xor    eax,eax
  102902:	90                   	nop
  102903:	90                   	nop
  102904:	90                   	nop
  102905:	90                   	nop
  102906:	90                   	nop
  102907:	90                   	nop
  102908:	90                   	nop
  102909:	90                   	nop
  10290a:	90                   	nop
  10290b:	90                   	nop
  10290c:	90                   	nop
  10290d:	90                   	nop
  10290e:	90                   	nop
  10290f:	90                   	nop
  102910:	31 c9                	xor    ecx,ecx
  102912:	90                   	nop
  102913:	90                   	nop
  102914:	90                   	nop
  102915:	90                   	nop
  102916:	90                   	nop
  102917:	90                   	nop
  102918:	90                   	nop
  102919:	90                   	nop
  10291a:	90                   	nop
  10291b:	90                   	nop
  10291c:	90                   	nop
  10291d:	90                   	nop
  10291e:	90                   	nop
  10291f:	90                   	nop
            if (this->operator[](a) == 0)
  102920:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102925:	74 0b                	je     102932 <kernel_main+0xec2>
        for (int a = 0; a < N; a++) {
  102927:	41                   	inc    ecx
  102928:	83 f9 50             	cmp    ecx,0x50
  10292b:	75 f3                	jne    102920 <kernel_main+0xeb0>
  10292d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  102932:	39 c8                	cmp    eax,ecx
  102934:	73 2a                	jae    102960 <kernel_main+0xef0>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102936:	83 f8 04             	cmp    eax,0x4
  102939:	0f 84 51 02 00 00    	je     102b90 <kernel_main+0x1120>
  10293f:	8a 88 0c 00 10 00    	mov    cl,BYTE PTR [eax+0x10000c]
  102945:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  102949:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  10294c:	74 c2                	je     102910 <kernel_main+0xea0>
  10294e:	e9 3d 02 00 00       	jmp    102b90 <kernel_main+0x1120>
  102953:	90                   	nop
  102954:	90                   	nop
  102955:	90                   	nop
  102956:	90                   	nop
  102957:	90                   	nop
  102958:	90                   	nop
  102959:	90                   	nop
  10295a:	90                   	nop
  10295b:	90                   	nop
  10295c:	90                   	nop
  10295d:	90                   	nop
  10295e:	90                   	nop
  10295f:	90                   	nop
  102960:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  102965:	90                   	nop
  102966:	90                   	nop
  102967:	90                   	nop
  102968:	90                   	nop
  102969:	90                   	nop
  10296a:	90                   	nop
  10296b:	90                   	nop
  10296c:	90                   	nop
  10296d:	90                   	nop
  10296e:	90                   	nop
  10296f:	90                   	nop
            if (this->operator[](a) == 0)
  102970:	80 7c 04 30 00       	cmp    BYTE PTR [esp+eax*1+0x30],0x0
  102975:	74 0b                	je     102982 <kernel_main+0xf12>
        for (int a = 0; a < N; a++) {
  102977:	40                   	inc    eax
  102978:	83 f8 4c             	cmp    eax,0x4c
  10297b:	75 f3                	jne    102970 <kernel_main+0xf00>
  10297d:	e9 0e 02 00 00       	jmp    102b90 <kernel_main+0x1120>
        return p[length()] == 0;
  102982:	85 c0                	test   eax,eax
        if (command == "read") {
  102984:	0f 85 06 02 00 00    	jne    102b90 <kernel_main+0x1120>
  10298a:	31 c0                	xor    eax,eax
  10298c:	90                   	nop
  10298d:	90                   	nop
  10298e:	90                   	nop
  10298f:	90                   	nop
            if (this->operator[](a) == 0)
  102990:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  102997:	00 
  102998:	74 0b                	je     1029a5 <kernel_main+0xf35>
        for (int a = 0; a < N; a++) {
  10299a:	40                   	inc    eax
  10299b:	83 f8 50             	cmp    eax,0x50
  10299e:	75 f0                	jne    102990 <kernel_main+0xf20>
  1029a0:	b8 50 00 00 00       	mov    eax,0x50
        return dual_iterator<const char>(this->data_ + length());
  1029a5:	8d 8c 04 b4 00 00 00 	lea    ecx,[esp+eax*1+0xb4]
  1029ac:	8d 94 24 b4 00 00 00 	lea    edx,[esp+0xb4]
  1029b3:	39 ca                	cmp    edx,ecx
    for (auto c : p) {
  1029b5:	74 5c                	je     102a13 <kernel_main+0xfa3>
  1029b7:	31 c9                	xor    ecx,ecx
  1029b9:	90                   	nop
  1029ba:	90                   	nop
  1029bb:	90                   	nop
  1029bc:	90                   	nop
  1029bd:	90                   	nop
  1029be:	90                   	nop
  1029bf:	90                   	nop
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  1029c0:	0f be 32             	movsx  esi,BYTE PTR [edx]
        r *= B;
  1029c3:	c1 e1 04             	shl    ecx,0x4
        r += static_cast<int>(c.value - '0');
  1029c6:	8d 4c 31 d0          	lea    ecx,[ecx+esi*1-0x30]
        ptr_++;
  1029ca:	42                   	inc    edx
        return ptr_ != p.ptr_;
  1029cb:	48                   	dec    eax
    for (auto c : p) {
  1029cc:	75 f2                	jne    1029c0 <kernel_main+0xf50>
  1029ce:	eb 45                	jmp    102a15 <kernel_main+0xfa5>
  1029d0:	31 f6                	xor    esi,esi
  1029d2:	90                   	nop
  1029d3:	90                   	nop
  1029d4:	90                   	nop
  1029d5:	90                   	nop
  1029d6:	90                   	nop
  1029d7:	90                   	nop
  1029d8:	90                   	nop
  1029d9:	90                   	nop
  1029da:	90                   	nop
  1029db:	90                   	nop
  1029dc:	90                   	nop
  1029dd:	90                   	nop
  1029de:	90                   	nop
  1029df:	90                   	nop
            for (auto a : range<0, (term::max_row + 2) * term::max_col>) {
                (void)a;
                term::write(char('$' + (rnd.next(40))));
  1029e0:	6a 28                	push   0x28
  1029e2:	53                   	push   ebx
  1029e3:	e8 28 14 00 00       	call   103e10 <rand::random_gen::next(unsigned int)>
  1029e8:	83 c4 08             	add    esp,0x8
  1029eb:	04 24                	add    al,0x24
  1029ed:	0f be c0             	movsx  eax,al
  1029f0:	50                   	push   eax
  1029f1:	e8 7a e7 ff ff       	call   101170 <term::write(char)>
  1029f6:	83 c4 04             	add    esp,0x4
  1029f9:	b8 00 00 14 00       	mov    eax,0x140000
  1029fe:	90                   	nop
  1029ff:	90                   	nop
        asm volatile ("and %eax,%eax");
  102a00:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  102a02:	48                   	dec    eax
  102a03:	75 fb                	jne    102a00 <kernel_main+0xf90>

      public:
        range_iterator(int p) : value(p) {}
        constexpr auto operator*() const { return value; }
        constexpr auto operator++() {
            value++;
  102a05:	46                   	inc    esi
            return *this;
        }
        constexpr auto operator!=(const range_iterator &p) {
            return value != p.value;
  102a06:	81 fe 70 08 00 00    	cmp    esi,0x870
  102a0c:	75 d2                	jne    1029e0 <kernel_main+0xf70>
  102a0e:	e9 ad fb ff ff       	jmp    1025c0 <kernel_main+0xb50>
  102a13:	31 c9                	xor    ecx,ecx
            term::write("-> 0x", int_to_string<16>(*address).str(), "\n");
  102a15:	8b 11                	mov    edx,DWORD PTR [ecx]
    constexpr array() : data_{T()} {}
  102a17:	c7 84 24 2b 01 00 00 	mov    DWORD PTR [esp+0x12b],0x0
  102a1e:	00 00 00 00 
  102a22:	c7 84 24 28 01 00 00 	mov    DWORD PTR [esp+0x128],0x0
  102a29:	00 00 00 00 
  102a2d:	c7 84 24 24 01 00 00 	mov    DWORD PTR [esp+0x124],0x0
  102a34:	00 00 00 00 
  102a38:	c7 84 24 20 01 00 00 	mov    DWORD PTR [esp+0x120],0x0
  102a3f:	00 00 00 00 
  102a43:	c7 84 24 1c 01 00 00 	mov    DWORD PTR [esp+0x11c],0x0
  102a4a:	00 00 00 00 
  102a4e:	c7 84 24 18 01 00 00 	mov    DWORD PTR [esp+0x118],0x0
  102a55:	00 00 00 00 
  102a59:	c7 84 24 14 01 00 00 	mov    DWORD PTR [esp+0x114],0x0
  102a60:	00 00 00 00 
  102a64:	c7 84 24 10 01 00 00 	mov    DWORD PTR [esp+0x110],0x0
  102a6b:	00 00 00 00 
    int index_ = 0;
  102a6f:	c7 84 24 30 01 00 00 	mov    DWORD PTR [esp+0x130],0x0
  102a76:	00 00 00 00 
    if (x == 0)
  102a7a:	85 d2                	test   edx,edx
  102a7c:	0f 84 82 00 00 00    	je     102b04 <kernel_main+0x1094>
  102a82:	31 f6                	xor    esi,esi
  102a84:	b9 01 00 00 00       	mov    ecx,0x1
  102a89:	8d 84 24 10 01 00 00 	lea    eax,[esp+0x110]
  102a90:	89 0c 24             	mov    DWORD PTR [esp],ecx
  102a93:	89 c7                	mov    edi,eax
        if ((x % B) < 10)
  102a95:	89 d0                	mov    eax,edx
  102a97:	83 e0 0f             	and    eax,0xf
  102a9a:	89 c1                	mov    ecx,eax
  102a9c:	80 c9 30             	or     cl,0x30
  102a9f:	88 d5                	mov    ch,dl
  102aa1:	80 c5 06             	add    ch,0x6
  102aa4:	80 e5 0f             	and    ch,0xf
  102aa7:	80 c5 41             	add    ch,0x41
  102aaa:	83 f8 0a             	cmp    eax,0xa
  102aad:	0f b6 c1             	movzx  eax,cl
  102ab0:	0f b6 cd             	movzx  ecx,ch
  102ab3:	0f 42 c8             	cmovb  ecx,eax
        r[a] = i2c(x);
  102ab6:	88 8c 34 10 01 00 00 	mov    BYTE PTR [esp+esi*1+0x110],cl
        x /= B;
  102abd:	c1 ea 04             	shr    edx,0x4
    for (; x > 0; a++) {
  102ac0:	46                   	inc    esi
  102ac1:	8b 04 24             	mov    eax,DWORD PTR [esp]
  102ac4:	8d 48 01             	lea    ecx,[eax+0x1]
  102ac7:	8d 47 01             	lea    eax,[edi+0x1]
  102aca:	85 d2                	test   edx,edx
  102acc:	75 c2                	jne    102a90 <kernel_main+0x1020>
    r[a] = 0;
  102ace:	c6 84 34 10 01 00 00 	mov    BYTE PTR [esp+esi*1+0x110],0x0
  102ad5:	00 
    for (auto b = 0; b < a / 2; b++) {
  102ad6:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  102adc:	8b 0c 24             	mov    ecx,DWORD PTR [esp]
  102adf:	74 2d                	je     102b0e <kernel_main+0x109e>
  102ae1:	d1 e9                	shr    ecx,1
  102ae3:	8d 94 24 10 01 00 00 	lea    edx,[esp+0x110]
  102aea:	90                   	nop
  102aeb:	90                   	nop
  102aec:	90                   	nop
  102aed:	90                   	nop
  102aee:	90                   	nop
  102aef:	90                   	nop
        r[b] ^= r[a - b - 1];
  102af0:	0f b6 02             	movzx  eax,BYTE PTR [edx]
  102af3:	32 07                	xor    al,BYTE PTR [edi]
  102af5:	88 02                	mov    BYTE PTR [edx],al
        r[a - b - 1] ^= r[b];
  102af7:	32 07                	xor    al,BYTE PTR [edi]
  102af9:	88 07                	mov    BYTE PTR [edi],al
        r[b] ^= r[a - b - 1];
  102afb:	30 02                	xor    BYTE PTR [edx],al
    for (auto b = 0; b < a / 2; b++) {
  102afd:	42                   	inc    edx
  102afe:	4f                   	dec    edi
  102aff:	49                   	dec    ecx
  102b00:	75 ee                	jne    102af0 <kernel_main+0x1080>
  102b02:	eb 0a                	jmp    102b0e <kernel_main+0x109e>
        r[a++] = '0';
  102b04:	66 c7 84 24 10 01 00 	mov    WORD PTR [esp+0x110],0x30
  102b0b:	00 30 00 
    return r;
  102b0e:	b9 09 00 00 00       	mov    ecx,0x9
  102b13:	8d bc 24 88 00 00 00 	lea    edi,[esp+0x88]
  102b1a:	8d b4 24 10 01 00 00 	lea    esi,[esp+0x110]
  102b21:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  102b23:	6a 2d                	push   0x2d
  102b25:	e8 46 e6 ff ff       	call   101170 <term::write(char)>
  102b2a:	83 c4 04             	add    esp,0x4
  102b2d:	6a 3e                	push   0x3e
  102b2f:	e8 3c e6 ff ff       	call   101170 <term::write(char)>
  102b34:	83 c4 04             	add    esp,0x4
  102b37:	6a 20                	push   0x20
  102b39:	e8 32 e6 ff ff       	call   101170 <term::write(char)>
  102b3e:	83 c4 04             	add    esp,0x4
  102b41:	6a 30                	push   0x30
  102b43:	e8 28 e6 ff ff       	call   101170 <term::write(char)>
  102b48:	83 c4 04             	add    esp,0x4
  102b4b:	6a 78                	push   0x78
  102b4d:	e8 1e e6 ff ff       	call   101170 <term::write(char)>
  102b52:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102b55:	8a 84 24 88 00 00 00 	mov    al,BYTE PTR [esp+0x88]
  102b5c:	84 c0                	test   al,al
  102b5e:	74 24                	je     102b84 <kernel_main+0x1114>
  102b60:	8d b4 24 89 00 00 00 	lea    esi,[esp+0x89]
  102b67:	90                   	nop
  102b68:	90                   	nop
  102b69:	90                   	nop
  102b6a:	90                   	nop
  102b6b:	90                   	nop
  102b6c:	90                   	nop
  102b6d:	90                   	nop
  102b6e:	90                   	nop
  102b6f:	90                   	nop
        write(s[a]);
  102b70:	0f be c0             	movsx  eax,al
  102b73:	50                   	push   eax
  102b74:	e8 f7 e5 ff ff       	call   101170 <term::write(char)>
  102b79:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102b7c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  102b7f:	46                   	inc    esi
  102b80:	84 c0                	test   al,al
  102b82:	75 ec                	jne    102b70 <kernel_main+0x1100>
        write(s[a]);
  102b84:	6a 0a                	push   0xa
  102b86:	e8 e5 e5 ff ff       	call   101170 <term::write(char)>
  102b8b:	83 c4 04             	add    esp,0x4
  102b8e:	90                   	nop
  102b8f:	90                   	nop
  102b90:	31 c0                	xor    eax,eax
  102b92:	90                   	nop
  102b93:	90                   	nop
  102b94:	90                   	nop
  102b95:	90                   	nop
  102b96:	90                   	nop
  102b97:	90                   	nop
  102b98:	90                   	nop
  102b99:	90                   	nop
  102b9a:	90                   	nop
  102b9b:	90                   	nop
  102b9c:	90                   	nop
  102b9d:	90                   	nop
  102b9e:	90                   	nop
  102b9f:	90                   	nop
  102ba0:	31 c9                	xor    ecx,ecx
  102ba2:	90                   	nop
  102ba3:	90                   	nop
  102ba4:	90                   	nop
  102ba5:	90                   	nop
  102ba6:	90                   	nop
  102ba7:	90                   	nop
  102ba8:	90                   	nop
  102ba9:	90                   	nop
  102baa:	90                   	nop
  102bab:	90                   	nop
  102bac:	90                   	nop
  102bad:	90                   	nop
  102bae:	90                   	nop
  102baf:	90                   	nop
            if (this->operator[](a) == 0)
  102bb0:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102bb5:	74 0b                	je     102bc2 <kernel_main+0x1152>
        for (int a = 0; a < N; a++) {
  102bb7:	41                   	inc    ecx
  102bb8:	83 f9 50             	cmp    ecx,0x50
  102bbb:	75 f3                	jne    102bb0 <kernel_main+0x1140>
  102bbd:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  102bc2:	39 c8                	cmp    eax,ecx
  102bc4:	73 1a                	jae    102be0 <kernel_main+0x1170>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102bc6:	83 f8 04             	cmp    eax,0x4
  102bc9:	74 45                	je     102c10 <kernel_main+0x11a0>
  102bcb:	8a 88 5a 00 10 00    	mov    cl,BYTE PTR [eax+0x10005a]
  102bd1:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  102bd5:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102bd8:	74 c6                	je     102ba0 <kernel_main+0x1130>
  102bda:	eb 34                	jmp    102c10 <kernel_main+0x11a0>
  102bdc:	90                   	nop
  102bdd:	90                   	nop
  102bde:	90                   	nop
  102bdf:	90                   	nop
  102be0:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  102be5:	90                   	nop
  102be6:	90                   	nop
  102be7:	90                   	nop
  102be8:	90                   	nop
  102be9:	90                   	nop
  102bea:	90                   	nop
  102beb:	90                   	nop
  102bec:	90                   	nop
  102bed:	90                   	nop
  102bee:	90                   	nop
  102bef:	90                   	nop
            if (this->operator[](a) == 0)
  102bf0:	80 7c 04 30 00       	cmp    BYTE PTR [esp+eax*1+0x30],0x0
  102bf5:	74 08                	je     102bff <kernel_main+0x118f>
        for (int a = 0; a < N; a++) {
  102bf7:	40                   	inc    eax
  102bf8:	83 f8 4c             	cmp    eax,0x4c
  102bfb:	75 f3                	jne    102bf0 <kernel_main+0x1180>
  102bfd:	eb 11                	jmp    102c10 <kernel_main+0x11a0>
        return p[length()] == 0;
  102bff:	85 c0                	test   eax,eax
        if (command == "flip") {
  102c01:	75 0d                	jne    102c10 <kernel_main+0x11a0>
            term::terminal.flipped = !term::terminal.flipped;
  102c03:	80 35 0d 60 10 00 01 	xor    BYTE PTR ds:0x10600d,0x1
  102c0a:	90                   	nop
  102c0b:	90                   	nop
  102c0c:	90                   	nop
  102c0d:	90                   	nop
  102c0e:	90                   	nop
  102c0f:	90                   	nop
  102c10:	31 c0                	xor    eax,eax
  102c12:	90                   	nop
  102c13:	90                   	nop
  102c14:	90                   	nop
  102c15:	90                   	nop
  102c16:	90                   	nop
  102c17:	90                   	nop
  102c18:	90                   	nop
  102c19:	90                   	nop
  102c1a:	90                   	nop
  102c1b:	90                   	nop
  102c1c:	90                   	nop
  102c1d:	90                   	nop
  102c1e:	90                   	nop
  102c1f:	90                   	nop
  102c20:	31 c9                	xor    ecx,ecx
  102c22:	90                   	nop
  102c23:	90                   	nop
  102c24:	90                   	nop
  102c25:	90                   	nop
  102c26:	90                   	nop
  102c27:	90                   	nop
  102c28:	90                   	nop
  102c29:	90                   	nop
  102c2a:	90                   	nop
  102c2b:	90                   	nop
  102c2c:	90                   	nop
  102c2d:	90                   	nop
  102c2e:	90                   	nop
  102c2f:	90                   	nop
            if (this->operator[](a) == 0)
  102c30:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102c35:	74 0b                	je     102c42 <kernel_main+0x11d2>
        for (int a = 0; a < N; a++) {
  102c37:	41                   	inc    ecx
  102c38:	83 f9 50             	cmp    ecx,0x50
  102c3b:	75 f3                	jne    102c30 <kernel_main+0x11c0>
  102c3d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  102c42:	39 c8                	cmp    eax,ecx
  102c44:	73 2a                	jae    102c70 <kernel_main+0x1200>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102c46:	83 f8 04             	cmp    eax,0x4
  102c49:	0f 84 41 01 00 00    	je     102d90 <kernel_main+0x1320>
  102c4f:	8a 88 77 00 10 00    	mov    cl,BYTE PTR [eax+0x100077]
  102c55:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  102c59:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102c5c:	74 c2                	je     102c20 <kernel_main+0x11b0>
  102c5e:	e9 2d 01 00 00       	jmp    102d90 <kernel_main+0x1320>
  102c63:	90                   	nop
  102c64:	90                   	nop
  102c65:	90                   	nop
  102c66:	90                   	nop
  102c67:	90                   	nop
  102c68:	90                   	nop
  102c69:	90                   	nop
  102c6a:	90                   	nop
  102c6b:	90                   	nop
  102c6c:	90                   	nop
  102c6d:	90                   	nop
  102c6e:	90                   	nop
  102c6f:	90                   	nop
  102c70:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  102c75:	90                   	nop
  102c76:	90                   	nop
  102c77:	90                   	nop
  102c78:	90                   	nop
  102c79:	90                   	nop
  102c7a:	90                   	nop
  102c7b:	90                   	nop
  102c7c:	90                   	nop
  102c7d:	90                   	nop
  102c7e:	90                   	nop
  102c7f:	90                   	nop
            if (this->operator[](a) == 0)
  102c80:	80 7c 04 30 00       	cmp    BYTE PTR [esp+eax*1+0x30],0x0
  102c85:	74 0b                	je     102c92 <kernel_main+0x1222>
        for (int a = 0; a < N; a++) {
  102c87:	40                   	inc    eax
  102c88:	83 f8 4c             	cmp    eax,0x4c
  102c8b:	75 f3                	jne    102c80 <kernel_main+0x1210>
  102c8d:	e9 fe 00 00 00       	jmp    102d90 <kernel_main+0x1320>
        return p[length()] == 0;
  102c92:	85 c0                	test   eax,eax
        if (command == "stoi") {
  102c94:	0f 85 f6 00 00 00    	jne    102d90 <kernel_main+0x1320>
  102c9a:	31 c0                	xor    eax,eax
  102c9c:	90                   	nop
  102c9d:	90                   	nop
  102c9e:	90                   	nop
  102c9f:	90                   	nop
            if (this->operator[](a) == 0)
  102ca0:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  102ca7:	00 
  102ca8:	74 08                	je     102cb2 <kernel_main+0x1242>
        for (int a = 0; a < N; a++) {
  102caa:	40                   	inc    eax
  102cab:	83 f8 50             	cmp    eax,0x50
  102cae:	75 f0                	jne    102ca0 <kernel_main+0x1230>
  102cb0:	eb 04                	jmp    102cb6 <kernel_main+0x1246>
        for (int a = 0; a < length(); a++) {
  102cb2:	85 c0                	test   eax,eax
  102cb4:	74 64                	je     102d1a <kernel_main+0x12aa>
  102cb6:	6a 6e                	push   0x6e
  102cb8:	e8 b3 e4 ff ff       	call   101170 <term::write(char)>
  102cbd:	83 c4 04             	add    esp,0x4
  102cc0:	6a 6f                	push   0x6f
  102cc2:	e8 a9 e4 ff ff       	call   101170 <term::write(char)>
  102cc7:	83 c4 04             	add    esp,0x4
  102cca:	6a 6e                	push   0x6e
  102ccc:	e8 9f e4 ff ff       	call   101170 <term::write(char)>
  102cd1:	83 c4 04             	add    esp,0x4
  102cd4:	6a 2d                	push   0x2d
  102cd6:	e8 95 e4 ff ff       	call   101170 <term::write(char)>
  102cdb:	83 c4 04             	add    esp,0x4
  102cde:	6a 65                	push   0x65
  102ce0:	e8 8b e4 ff ff       	call   101170 <term::write(char)>
  102ce5:	83 c4 04             	add    esp,0x4
  102ce8:	6a 6d                	push   0x6d
  102cea:	e8 81 e4 ff ff       	call   101170 <term::write(char)>
  102cef:	83 c4 04             	add    esp,0x4
  102cf2:	6a 70                	push   0x70
  102cf4:	e8 77 e4 ff ff       	call   101170 <term::write(char)>
  102cf9:	83 c4 04             	add    esp,0x4
  102cfc:	6a 74                	push   0x74
  102cfe:	e8 6d e4 ff ff       	call   101170 <term::write(char)>
  102d03:	83 c4 04             	add    esp,0x4
  102d06:	6a 79                	push   0x79
  102d08:	e8 63 e4 ff ff       	call   101170 <term::write(char)>
  102d0d:	83 c4 04             	add    esp,0x4
  102d10:	6a 20                	push   0x20
  102d12:	e8 59 e4 ff ff       	call   101170 <term::write(char)>
  102d17:	83 c4 04             	add    esp,0x4
  102d1a:	6a 4f                	push   0x4f
  102d1c:	e8 4f e4 ff ff       	call   101170 <term::write(char)>
  102d21:	83 c4 04             	add    esp,0x4
  102d24:	6a 4b                	push   0x4b
  102d26:	e8 45 e4 ff ff       	call   101170 <term::write(char)>
  102d2b:	83 c4 04             	add    esp,0x4
  102d2e:	6a 3a                	push   0x3a
  102d30:	e8 3b e4 ff ff       	call   101170 <term::write(char)>
  102d35:	83 c4 04             	add    esp,0x4
  102d38:	6a 20                	push   0x20
  102d3a:	e8 31 e4 ff ff       	call   101170 <term::write(char)>
  102d3f:	83 c4 04             	add    esp,0x4
  102d42:	6a 27                	push   0x27
  102d44:	e8 27 e4 ff ff       	call   101170 <term::write(char)>
  102d49:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102d4c:	8a 84 24 b4 00 00 00 	mov    al,BYTE PTR [esp+0xb4]
  102d53:	84 c0                	test   al,al
  102d55:	74 1d                	je     102d74 <kernel_main+0x1304>
  102d57:	8d b4 24 b5 00 00 00 	lea    esi,[esp+0xb5]
  102d5e:	90                   	nop
  102d5f:	90                   	nop
        write(s[a]);
  102d60:	0f be c0             	movsx  eax,al
  102d63:	50                   	push   eax
  102d64:	e8 07 e4 ff ff       	call   101170 <term::write(char)>
  102d69:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102d6c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  102d6f:	46                   	inc    esi
  102d70:	84 c0                	test   al,al
  102d72:	75 ec                	jne    102d60 <kernel_main+0x12f0>
        write(s[a]);
  102d74:	6a 27                	push   0x27
  102d76:	e8 f5 e3 ff ff       	call   101170 <term::write(char)>
  102d7b:	83 c4 04             	add    esp,0x4
  102d7e:	6a 0a                	push   0xa
  102d80:	e8 eb e3 ff ff       	call   101170 <term::write(char)>
  102d85:	83 c4 04             	add    esp,0x4
  102d88:	90                   	nop
  102d89:	90                   	nop
  102d8a:	90                   	nop
  102d8b:	90                   	nop
  102d8c:	90                   	nop
  102d8d:	90                   	nop
  102d8e:	90                   	nop
  102d8f:	90                   	nop
  102d90:	31 c0                	xor    eax,eax
  102d92:	90                   	nop
  102d93:	90                   	nop
  102d94:	90                   	nop
  102d95:	90                   	nop
  102d96:	90                   	nop
  102d97:	90                   	nop
  102d98:	90                   	nop
  102d99:	90                   	nop
  102d9a:	90                   	nop
  102d9b:	90                   	nop
  102d9c:	90                   	nop
  102d9d:	90                   	nop
  102d9e:	90                   	nop
  102d9f:	90                   	nop
  102da0:	31 c9                	xor    ecx,ecx
  102da2:	90                   	nop
  102da3:	90                   	nop
  102da4:	90                   	nop
  102da5:	90                   	nop
  102da6:	90                   	nop
  102da7:	90                   	nop
  102da8:	90                   	nop
  102da9:	90                   	nop
  102daa:	90                   	nop
  102dab:	90                   	nop
  102dac:	90                   	nop
  102dad:	90                   	nop
  102dae:	90                   	nop
  102daf:	90                   	nop
            if (this->operator[](a) == 0)
  102db0:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102db5:	74 0b                	je     102dc2 <kernel_main+0x1352>
        for (int a = 0; a < N; a++) {
  102db7:	41                   	inc    ecx
  102db8:	83 f9 50             	cmp    ecx,0x50
  102dbb:	75 f3                	jne    102db0 <kernel_main+0x1340>
  102dbd:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  102dc2:	39 c8                	cmp    eax,ecx
  102dc4:	73 2a                	jae    102df0 <kernel_main+0x1380>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102dc6:	83 f8 03             	cmp    eax,0x3
  102dc9:	0f 84 71 06 00 00    	je     103440 <kernel_main+0x19d0>
  102dcf:	8a 88 40 00 10 00    	mov    cl,BYTE PTR [eax+0x100040]
  102dd5:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  102dd9:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102ddc:	74 c2                	je     102da0 <kernel_main+0x1330>
  102dde:	e9 5d 06 00 00       	jmp    103440 <kernel_main+0x19d0>
  102de3:	90                   	nop
  102de4:	90                   	nop
  102de5:	90                   	nop
  102de6:	90                   	nop
  102de7:	90                   	nop
  102de8:	90                   	nop
  102de9:	90                   	nop
  102dea:	90                   	nop
  102deb:	90                   	nop
  102dec:	90                   	nop
  102ded:	90                   	nop
  102dee:	90                   	nop
  102def:	90                   	nop
  102df0:	b8 fd ff ff ff       	mov    eax,0xfffffffd
  102df5:	90                   	nop
  102df6:	90                   	nop
  102df7:	90                   	nop
  102df8:	90                   	nop
  102df9:	90                   	nop
  102dfa:	90                   	nop
  102dfb:	90                   	nop
  102dfc:	90                   	nop
  102dfd:	90                   	nop
  102dfe:	90                   	nop
  102dff:	90                   	nop
            if (this->operator[](a) == 0)
  102e00:	80 7c 04 2f 00       	cmp    BYTE PTR [esp+eax*1+0x2f],0x0
  102e05:	74 0b                	je     102e12 <kernel_main+0x13a2>
        for (int a = 0; a < N; a++) {
  102e07:	40                   	inc    eax
  102e08:	83 f8 4d             	cmp    eax,0x4d
  102e0b:	75 f3                	jne    102e00 <kernel_main+0x1390>
  102e0d:	e9 2e 06 00 00       	jmp    103440 <kernel_main+0x19d0>
        return p[length()] == 0;
  102e12:	85 c0                	test   eax,eax
        if (command == "mod") {
  102e14:	0f 85 26 06 00 00    	jne    103440 <kernel_main+0x19d0>
  102e1a:	31 c0                	xor    eax,eax
  102e1c:	90                   	nop
  102e1d:	90                   	nop
  102e1e:	90                   	nop
  102e1f:	90                   	nop
            if (this->operator[](a) == 0)
  102e20:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  102e27:	00 
  102e28:	74 08                	je     102e32 <kernel_main+0x13c2>
        for (int a = 0; a < N; a++) {
  102e2a:	40                   	inc    eax
  102e2b:	83 f8 50             	cmp    eax,0x50
  102e2e:	75 f0                	jne    102e20 <kernel_main+0x13b0>
  102e30:	eb 08                	jmp    102e3a <kernel_main+0x13ca>
        for (int a = 0; a < length(); a++) {
  102e32:	85 c0                	test   eax,eax
  102e34:	0f 84 c8 01 00 00    	je     103002 <kernel_main+0x1592>
  102e3a:	31 c0                	xor    eax,eax
  102e3c:	90                   	nop
  102e3d:	90                   	nop
  102e3e:	90                   	nop
  102e3f:	90                   	nop
            if (this->operator[](a) == 0)
  102e40:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  102e47:	00 
  102e48:	74 0b                	je     102e55 <kernel_main+0x13e5>
        for (int a = 0; a < N; a++) {
  102e4a:	40                   	inc    eax
  102e4b:	83 f8 50             	cmp    eax,0x50
  102e4e:	75 f0                	jne    102e40 <kernel_main+0x13d0>
  102e50:	b8 50 00 00 00       	mov    eax,0x50
        return dual_iterator<const char>(this->data_ + length());
  102e55:	8d 8c 04 b4 00 00 00 	lea    ecx,[esp+eax*1+0xb4]
  102e5c:	8d 94 24 b4 00 00 00 	lea    edx,[esp+0xb4]
        return ptr_ != p.ptr_;
  102e63:	39 ca                	cmp    edx,ecx
    for (auto c : p) {
  102e65:	0f 84 8b 01 00 00    	je     102ff6 <kernel_main+0x1586>
  102e6b:	31 c9                	xor    ecx,ecx
  102e6d:	90                   	nop
  102e6e:	90                   	nop
  102e6f:	90                   	nop
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  102e70:	0f be 32             	movsx  esi,BYTE PTR [edx]
        r *= B;
  102e73:	8d 0c 89             	lea    ecx,[ecx+ecx*4]
        r += static_cast<int>(c.value - '0');
  102e76:	8d 4c 4e d0          	lea    ecx,[esi+ecx*2-0x30]
        ptr_++;
  102e7a:	42                   	inc    edx
        return ptr_ != p.ptr_;
  102e7b:	48                   	dec    eax
    for (auto c : p) {
  102e7c:	75 f2                	jne    102e70 <kernel_main+0x1400>

    optional<module_proc> entry_point(int mod) {
        if (mod < count_)
  102e7e:	39 4c 24 08          	cmp    DWORD PTR [esp+0x8],ecx
  102e82:	0f 8e 7a 01 00 00    	jle    103002 <kernel_main+0x1592>
  102e88:	31 c0                	xor    eax,eax
  102e8a:	90                   	nop
  102e8b:	90                   	nop
  102e8c:	90                   	nop
  102e8d:	90                   	nop
  102e8e:	90                   	nop
  102e8f:	90                   	nop
            if (this->operator[](a) == 0)
  102e90:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  102e97:	00 
  102e98:	74 0b                	je     102ea5 <kernel_main+0x1435>
        for (int a = 0; a < N; a++) {
  102e9a:	40                   	inc    eax
  102e9b:	83 f8 50             	cmp    eax,0x50
  102e9e:	75 f0                	jne    102e90 <kernel_main+0x1420>
  102ea0:	b8 50 00 00 00       	mov    eax,0x50
        return dual_iterator<const char>(this->data_ + length());
  102ea5:	8d 94 04 b4 00 00 00 	lea    edx,[esp+eax*1+0xb4]
  102eac:	31 c9                	xor    ecx,ecx
  102eae:	8d b4 24 b4 00 00 00 	lea    esi,[esp+0xb4]
  102eb5:	39 d6                	cmp    esi,edx
  102eb7:	ba 00 00 00 00       	mov    edx,0x0
  102ebc:	74 20                	je     102ede <kernel_main+0x146e>
  102ebe:	31 d2                	xor    edx,edx
  102ec0:	8d b4 24 b4 00 00 00 	lea    esi,[esp+0xb4]
  102ec7:	90                   	nop
  102ec8:	90                   	nop
  102ec9:	90                   	nop
  102eca:	90                   	nop
  102ecb:	90                   	nop
  102ecc:	90                   	nop
  102ecd:	90                   	nop
  102ece:	90                   	nop
  102ecf:	90                   	nop
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  102ed0:	0f be 3e             	movsx  edi,BYTE PTR [esi]
        r *= B;
  102ed3:	8d 14 92             	lea    edx,[edx+edx*4]
        r += static_cast<int>(c.value - '0');
  102ed6:	8d 54 57 d0          	lea    edx,[edi+edx*2-0x30]
        ptr_++;
  102eda:	46                   	inc    esi
        return ptr_ != p.ptr_;
  102edb:	48                   	dec    eax
    for (auto c : p) {
  102edc:	75 f2                	jne    102ed0 <kernel_main+0x1460>
  102ede:	39 54 24 08          	cmp    DWORD PTR [esp+0x8],edx
  102ee2:	7e 11                	jle    102ef5 <kernel_main+0x1485>
            return reinterpret_cast<module_proc>(addr_[mod].mod_start +
  102ee4:	c1 e2 04             	shl    edx,0x4
  102ee7:	8b 44 24 10          	mov    eax,DWORD PTR [esp+0x10]
  102eeb:	8b 0c 10             	mov    ecx,DWORD PTR [eax+edx*1]
  102eee:	b8 00 10 00 00       	mov    eax,0x1000
  102ef3:	01 c1                	add    ecx,eax
  102ef5:	b8 00 00 64 00       	mov    eax,0x640000
  102efa:	90                   	nop
  102efb:	90                   	nop
  102efc:	90                   	nop
  102efd:	90                   	nop
  102efe:	90                   	nop
  102eff:	90                   	nop
        asm volatile ("and %eax,%eax");
  102f00:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  102f02:	48                   	dec    eax
  102f03:	75 fb                	jne    102f00 <kernel_main+0x1490>
                term::write(">>> ", int_to_string<16>(proc()).str(), "\n");
  102f05:	ff d1                	call   ecx
    constexpr array() : data_{T()} {}
  102f07:	c7 84 24 2b 01 00 00 	mov    DWORD PTR [esp+0x12b],0x0
  102f0e:	00 00 00 00 
  102f12:	c7 84 24 28 01 00 00 	mov    DWORD PTR [esp+0x128],0x0
  102f19:	00 00 00 00 
  102f1d:	c7 84 24 24 01 00 00 	mov    DWORD PTR [esp+0x124],0x0
  102f24:	00 00 00 00 
  102f28:	c7 84 24 20 01 00 00 	mov    DWORD PTR [esp+0x120],0x0
  102f2f:	00 00 00 00 
  102f33:	c7 84 24 1c 01 00 00 	mov    DWORD PTR [esp+0x11c],0x0
  102f3a:	00 00 00 00 
  102f3e:	c7 84 24 18 01 00 00 	mov    DWORD PTR [esp+0x118],0x0
  102f45:	00 00 00 00 
  102f49:	c7 84 24 14 01 00 00 	mov    DWORD PTR [esp+0x114],0x0
  102f50:	00 00 00 00 
  102f54:	c7 84 24 10 01 00 00 	mov    DWORD PTR [esp+0x110],0x0
  102f5b:	00 00 00 00 
    int index_ = 0;
  102f5f:	c7 84 24 30 01 00 00 	mov    DWORD PTR [esp+0x130],0x0
  102f66:	00 00 00 00 
    if (x == 0)
  102f6a:	85 c0                	test   eax,eax
  102f6c:	0f 84 42 04 00 00    	je     1033b4 <kernel_main+0x1944>
  102f72:	89 c7                	mov    edi,eax
    for (; x > 0; a++) {
  102f74:	85 c0                	test   eax,eax
  102f76:	0f 8e 47 04 00 00    	jle    1033c3 <kernel_main+0x1953>
  102f7c:	c7 04 24 00 00 00 00 	mov    DWORD PTR [esp],0x0
  102f83:	b8 01 00 00 00       	mov    eax,0x1
  102f88:	8d 94 24 10 01 00 00 	lea    edx,[esp+0x110]
  102f8f:	eb 4f                	jmp    102fe0 <kernel_main+0x1570>
  102f91:	90                   	nop
  102f92:	90                   	nop
  102f93:	90                   	nop
  102f94:	90                   	nop
  102f95:	90                   	nop
  102f96:	90                   	nop
  102f97:	90                   	nop
  102f98:	90                   	nop
  102f99:	90                   	nop
  102f9a:	90                   	nop
  102f9b:	90                   	nop
  102f9c:	90                   	nop
  102f9d:	90                   	nop
  102f9e:	90                   	nop
  102f9f:	90                   	nop
            return 'A' + ((x - 10) % B);
  102fa0:	8d 47 f6             	lea    eax,[edi-0xa]
  102fa3:	8d 57 05             	lea    edx,[edi+0x5]
  102fa6:	85 c0                	test   eax,eax
  102fa8:	0f 49 d0             	cmovns edx,eax
  102fab:	81 e2 f0 00 00 00    	and    edx,0xf0
  102fb1:	f7 da                	neg    edx
  102fb3:	8d 44 17 f6          	lea    eax,[edi+edx*1-0xa]
  102fb7:	04 41                	add    al,0x41
  102fb9:	8b 0c 24             	mov    ecx,DWORD PTR [esp]
        r[a] = i2c(x);
  102fbc:	88 84 0c 10 01 00 00 	mov    BYTE PTR [esp+ecx*1+0x110],al
        x /= B;
  102fc3:	c1 ef 04             	shr    edi,0x4
    for (; x > 0; a++) {
  102fc6:	41                   	inc    ecx
  102fc7:	89 0c 24             	mov    DWORD PTR [esp],ecx
  102fca:	8b 74 24 04          	mov    esi,DWORD PTR [esp+0x4]
  102fce:	8d 46 01             	lea    eax,[esi+0x1]
  102fd1:	8b 4c 24 0c          	mov    ecx,DWORD PTR [esp+0xc]
  102fd5:	8d 51 01             	lea    edx,[ecx+0x1]
  102fd8:	85 ff                	test   edi,edi
  102fda:	0f 84 9d 03 00 00    	je     10337d <kernel_main+0x190d>
  102fe0:	89 44 24 04          	mov    DWORD PTR [esp+0x4],eax
  102fe4:	89 54 24 0c          	mov    DWORD PTR [esp+0xc],edx
        if ((x % B) < 10)
  102fe8:	89 f8                	mov    eax,edi
  102fea:	83 e0 0f             	and    eax,0xf
  102fed:	83 f8 09             	cmp    eax,0x9
  102ff0:	77 ae                	ja     102fa0 <kernel_main+0x1530>
            return '0' + (x % B);
  102ff2:	0c 30                	or     al,0x30
  102ff4:	eb c3                	jmp    102fb9 <kernel_main+0x1549>
  102ff6:	31 c9                	xor    ecx,ecx
        if (mod < count_)
  102ff8:	39 4c 24 08          	cmp    DWORD PTR [esp+0x8],ecx
  102ffc:	0f 8f 86 fe ff ff    	jg     102e88 <kernel_main+0x1418>
  103002:	6a 55                	push   0x55
  103004:	e8 67 e1 ff ff       	call   101170 <term::write(char)>
  103009:	83 c4 04             	add    esp,0x4
  10300c:	6a 73                	push   0x73
  10300e:	e8 5d e1 ff ff       	call   101170 <term::write(char)>
  103013:	83 c4 04             	add    esp,0x4
  103016:	6a 61                	push   0x61
  103018:	e8 53 e1 ff ff       	call   101170 <term::write(char)>
  10301d:	83 c4 04             	add    esp,0x4
  103020:	6a 67                	push   0x67
  103022:	e8 49 e1 ff ff       	call   101170 <term::write(char)>
  103027:	83 c4 04             	add    esp,0x4
  10302a:	6a 65                	push   0x65
  10302c:	e8 3f e1 ff ff       	call   101170 <term::write(char)>
  103031:	83 c4 04             	add    esp,0x4
  103034:	6a 3a                	push   0x3a
  103036:	e8 35 e1 ff ff       	call   101170 <term::write(char)>
  10303b:	83 c4 04             	add    esp,0x4
  10303e:	6a 20                	push   0x20
  103040:	e8 2b e1 ff ff       	call   101170 <term::write(char)>
  103045:	83 c4 04             	add    esp,0x4
  103048:	6a 6d                	push   0x6d
  10304a:	e8 21 e1 ff ff       	call   101170 <term::write(char)>
  10304f:	83 c4 04             	add    esp,0x4
  103052:	6a 6f                	push   0x6f
  103054:	e8 17 e1 ff ff       	call   101170 <term::write(char)>
  103059:	83 c4 04             	add    esp,0x4
  10305c:	6a 64                	push   0x64
  10305e:	e8 0d e1 ff ff       	call   101170 <term::write(char)>
  103063:	83 c4 04             	add    esp,0x4
  103066:	6a 20                	push   0x20
  103068:	e8 03 e1 ff ff       	call   101170 <term::write(char)>
  10306d:	83 c4 04             	add    esp,0x4
  103070:	6a 3c                	push   0x3c
  103072:	e8 f9 e0 ff ff       	call   101170 <term::write(char)>
  103077:	83 c4 04             	add    esp,0x4
  10307a:	6a 6e                	push   0x6e
  10307c:	e8 ef e0 ff ff       	call   101170 <term::write(char)>
  103081:	83 c4 04             	add    esp,0x4
  103084:	6a 75                	push   0x75
  103086:	e8 e5 e0 ff ff       	call   101170 <term::write(char)>
  10308b:	83 c4 04             	add    esp,0x4
  10308e:	6a 6d                	push   0x6d
  103090:	e8 db e0 ff ff       	call   101170 <term::write(char)>
  103095:	83 c4 04             	add    esp,0x4
  103098:	6a 3e                	push   0x3e
  10309a:	e8 d1 e0 ff ff       	call   101170 <term::write(char)>
  10309f:	83 c4 04             	add    esp,0x4
  1030a2:	6a 0a                	push   0xa
  1030a4:	e8 c7 e0 ff ff       	call   101170 <term::write(char)>
  1030a9:	83 c4 04             	add    esp,0x4
  1030ac:	6a 09                	push   0x9
  1030ae:	e8 bd e0 ff ff       	call   101170 <term::write(char)>
  1030b3:	83 c4 04             	add    esp,0x4
  1030b6:	6a 6e                	push   0x6e
  1030b8:	e8 b3 e0 ff ff       	call   101170 <term::write(char)>
  1030bd:	83 c4 04             	add    esp,0x4
  1030c0:	6a 75                	push   0x75
  1030c2:	e8 a9 e0 ff ff       	call   101170 <term::write(char)>
  1030c7:	83 c4 04             	add    esp,0x4
  1030ca:	6a 6d                	push   0x6d
  1030cc:	e8 9f e0 ff ff       	call   101170 <term::write(char)>
  1030d1:	83 c4 04             	add    esp,0x4
  1030d4:	6a 3a                	push   0x3a
  1030d6:	e8 95 e0 ff ff       	call   101170 <term::write(char)>
  1030db:	83 c4 04             	add    esp,0x4
  1030de:	6a 20                	push   0x20
  1030e0:	e8 8b e0 ff ff       	call   101170 <term::write(char)>
  1030e5:	83 c4 04             	add    esp,0x4
  1030e8:	6a 6d                	push   0x6d
  1030ea:	e8 81 e0 ff ff       	call   101170 <term::write(char)>
  1030ef:	83 c4 04             	add    esp,0x4
  1030f2:	6a 6f                	push   0x6f
  1030f4:	e8 77 e0 ff ff       	call   101170 <term::write(char)>
  1030f9:	83 c4 04             	add    esp,0x4
  1030fc:	6a 64                	push   0x64
  1030fe:	e8 6d e0 ff ff       	call   101170 <term::write(char)>
  103103:	83 c4 04             	add    esp,0x4
  103106:	6a 75                	push   0x75
  103108:	e8 63 e0 ff ff       	call   101170 <term::write(char)>
  10310d:	83 c4 04             	add    esp,0x4
  103110:	6a 6c                	push   0x6c
  103112:	e8 59 e0 ff ff       	call   101170 <term::write(char)>
  103117:	83 c4 04             	add    esp,0x4
  10311a:	6a 65                	push   0x65
  10311c:	e8 4f e0 ff ff       	call   101170 <term::write(char)>
  103121:	83 c4 04             	add    esp,0x4
  103124:	6a 20                	push   0x20
  103126:	e8 45 e0 ff ff       	call   101170 <term::write(char)>
  10312b:	83 c4 04             	add    esp,0x4
  10312e:	6a 6e                	push   0x6e
  103130:	e8 3b e0 ff ff       	call   101170 <term::write(char)>
  103135:	83 c4 04             	add    esp,0x4
  103138:	6a 75                	push   0x75
  10313a:	e8 31 e0 ff ff       	call   101170 <term::write(char)>
  10313f:	83 c4 04             	add    esp,0x4
  103142:	6a 6d                	push   0x6d
  103144:	e8 27 e0 ff ff       	call   101170 <term::write(char)>
  103149:	83 c4 04             	add    esp,0x4
  10314c:	6a 62                	push   0x62
  10314e:	e8 1d e0 ff ff       	call   101170 <term::write(char)>
  103153:	83 c4 04             	add    esp,0x4
  103156:	6a 65                	push   0x65
  103158:	e8 13 e0 ff ff       	call   101170 <term::write(char)>
  10315d:	83 c4 04             	add    esp,0x4
  103160:	6a 72                	push   0x72
  103162:	e8 09 e0 ff ff       	call   101170 <term::write(char)>
  103167:	83 c4 04             	add    esp,0x4
  10316a:	6a 20                	push   0x20
  10316c:	e8 ff df ff ff       	call   101170 <term::write(char)>
  103171:	83 c4 04             	add    esp,0x4
                if (mb->mods_count > 0)
  103174:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  103177:	8b 50 14             	mov    edx,DWORD PTR [eax+0x14]
  10317a:	85 d2                	test   edx,edx
  10317c:	0f 84 74 01 00 00    	je     1032f6 <kernel_main+0x1886>
    constexpr array() : data_{T()} {}
  103182:	c7 84 24 2b 01 00 00 	mov    DWORD PTR [esp+0x12b],0x0
  103189:	00 00 00 00 
  10318d:	c7 84 24 28 01 00 00 	mov    DWORD PTR [esp+0x128],0x0
  103194:	00 00 00 00 
  103198:	c7 84 24 24 01 00 00 	mov    DWORD PTR [esp+0x124],0x0
  10319f:	00 00 00 00 
  1031a3:	c7 84 24 20 01 00 00 	mov    DWORD PTR [esp+0x120],0x0
  1031aa:	00 00 00 00 
  1031ae:	c7 84 24 1c 01 00 00 	mov    DWORD PTR [esp+0x11c],0x0
  1031b5:	00 00 00 00 
  1031b9:	c7 84 24 18 01 00 00 	mov    DWORD PTR [esp+0x118],0x0
  1031c0:	00 00 00 00 
  1031c4:	c7 84 24 14 01 00 00 	mov    DWORD PTR [esp+0x114],0x0
  1031cb:	00 00 00 00 
  1031cf:	c7 84 24 10 01 00 00 	mov    DWORD PTR [esp+0x110],0x0
  1031d6:	00 00 00 00 
    int index_ = 0;
  1031da:	c7 84 24 30 01 00 00 	mov    DWORD PTR [esp+0x130],0x0
  1031e1:	00 00 00 00 
  1031e5:	31 ff                	xor    edi,edi
  1031e7:	c7 44 24 04 01 00 00 	mov    DWORD PTR [esp+0x4],0x1
  1031ee:	00 
  1031ef:	8d 84 24 10 01 00 00 	lea    eax,[esp+0x110]
  1031f6:	89 04 24             	mov    DWORD PTR [esp],eax
  1031f9:	90                   	nop
  1031fa:	90                   	nop
  1031fb:	90                   	nop
  1031fc:	90                   	nop
  1031fd:	90                   	nop
  1031fe:	90                   	nop
  1031ff:	90                   	nop
        x /= B;
  103200:	89 d0                	mov    eax,edx
  103202:	89 d6                	mov    esi,edx
  103204:	89 54 24 0c          	mov    DWORD PTR [esp+0xc],edx
  103208:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  10320d:	f7 e1                	mul    ecx
  10320f:	c1 ea 03             	shr    edx,0x3
  103212:	8d 04 12             	lea    eax,[edx+edx*1]
  103215:	8d 04 80             	lea    eax,[eax+eax*4]
  103218:	89 f1                	mov    ecx,esi
  10321a:	29 c1                	sub    ecx,eax
  10321c:	8b 44 24 04          	mov    eax,DWORD PTR [esp+0x4]
  103220:	8b 34 24             	mov    esi,DWORD PTR [esp]
            return '0' + (x % B);
  103223:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  103226:	88 8c 3c 10 01 00 00 	mov    BYTE PTR [esp+edi*1+0x110],cl
    for (; x > 0; a++) {
  10322d:	47                   	inc    edi
  10322e:	8d 48 01             	lea    ecx,[eax+0x1]
  103231:	89 4c 24 04          	mov    DWORD PTR [esp+0x4],ecx
  103235:	83 7c 24 0c 09       	cmp    DWORD PTR [esp+0xc],0x9
  10323a:	8d 4e 01             	lea    ecx,[esi+0x1]
  10323d:	89 0c 24             	mov    DWORD PTR [esp],ecx
  103240:	77 be                	ja     103200 <kernel_main+0x1790>
    r[a] = 0;
  103242:	c6 84 3c 10 01 00 00 	mov    BYTE PTR [esp+edi*1+0x110],0x0
  103249:	00 
    for (auto b = 0; b < a / 2; b++) {
  10324a:	f7 c7 fe ff ff ff    	test   edi,0xfffffffe
  103250:	74 20                	je     103272 <kernel_main+0x1802>
  103252:	d1 e8                	shr    eax,1
  103254:	8d 8c 24 10 01 00 00 	lea    ecx,[esp+0x110]
  10325b:	90                   	nop
  10325c:	90                   	nop
  10325d:	90                   	nop
  10325e:	90                   	nop
  10325f:	90                   	nop
        r[b] ^= r[a - b - 1];
  103260:	0f b6 11             	movzx  edx,BYTE PTR [ecx]
  103263:	32 16                	xor    dl,BYTE PTR [esi]
  103265:	88 11                	mov    BYTE PTR [ecx],dl
        r[a - b - 1] ^= r[b];
  103267:	32 16                	xor    dl,BYTE PTR [esi]
  103269:	88 16                	mov    BYTE PTR [esi],dl
        r[b] ^= r[a - b - 1];
  10326b:	30 11                	xor    BYTE PTR [ecx],dl
    for (auto b = 0; b < a / 2; b++) {
  10326d:	41                   	inc    ecx
  10326e:	4e                   	dec    esi
  10326f:	48                   	dec    eax
  103270:	75 ee                	jne    103260 <kernel_main+0x17f0>
    return r;
  103272:	b9 09 00 00 00       	mov    ecx,0x9
  103277:	8d bc 24 88 00 00 00 	lea    edi,[esp+0x88]
  10327e:	8d b4 24 10 01 00 00 	lea    esi,[esp+0x110]
  103285:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  103287:	6a 28                	push   0x28
  103289:	e8 e2 de ff ff       	call   101170 <term::write(char)>
  10328e:	83 c4 04             	add    esp,0x4
  103291:	6a 6d                	push   0x6d
  103293:	e8 d8 de ff ff       	call   101170 <term::write(char)>
  103298:	83 c4 04             	add    esp,0x4
  10329b:	6a 61                	push   0x61
  10329d:	e8 ce de ff ff       	call   101170 <term::write(char)>
  1032a2:	83 c4 04             	add    esp,0x4
  1032a5:	6a 78                	push   0x78
  1032a7:	e8 c4 de ff ff       	call   101170 <term::write(char)>
  1032ac:	83 c4 04             	add    esp,0x4
  1032af:	6a 3a                	push   0x3a
  1032b1:	e8 ba de ff ff       	call   101170 <term::write(char)>
  1032b6:	83 c4 04             	add    esp,0x4
  1032b9:	6a 20                	push   0x20
  1032bb:	e8 b0 de ff ff       	call   101170 <term::write(char)>
  1032c0:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  1032c3:	8a 84 24 88 00 00 00 	mov    al,BYTE PTR [esp+0x88]
  1032ca:	84 c0                	test   al,al
  1032cc:	0f 84 9c 00 00 00    	je     10336e <kernel_main+0x18fe>
  1032d2:	8d b4 24 89 00 00 00 	lea    esi,[esp+0x89]
  1032d9:	90                   	nop
  1032da:	90                   	nop
  1032db:	90                   	nop
  1032dc:	90                   	nop
  1032dd:	90                   	nop
  1032de:	90                   	nop
  1032df:	90                   	nop
        write(s[a]);
  1032e0:	0f be c0             	movsx  eax,al
  1032e3:	50                   	push   eax
  1032e4:	e8 87 de ff ff       	call   101170 <term::write(char)>
  1032e9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  1032ec:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  1032ef:	46                   	inc    esi
  1032f0:	84 c0                	test   al,al
  1032f2:	75 ec                	jne    1032e0 <kernel_main+0x1870>
  1032f4:	eb 78                	jmp    10336e <kernel_main+0x18fe>
        write(s[a]);
  1032f6:	6a 28                	push   0x28
  1032f8:	e8 73 de ff ff       	call   101170 <term::write(char)>
  1032fd:	83 c4 04             	add    esp,0x4
  103300:	6a 6e                	push   0x6e
  103302:	e8 69 de ff ff       	call   101170 <term::write(char)>
  103307:	83 c4 04             	add    esp,0x4
  10330a:	6a 6f                	push   0x6f
  10330c:	e8 5f de ff ff       	call   101170 <term::write(char)>
  103311:	83 c4 04             	add    esp,0x4
  103314:	6a 6e                	push   0x6e
  103316:	e8 55 de ff ff       	call   101170 <term::write(char)>
  10331b:	83 c4 04             	add    esp,0x4
  10331e:	6a 65                	push   0x65
  103320:	e8 4b de ff ff       	call   101170 <term::write(char)>
  103325:	83 c4 04             	add    esp,0x4
  103328:	6a 20                	push   0x20
  10332a:	e8 41 de ff ff       	call   101170 <term::write(char)>
  10332f:	83 c4 04             	add    esp,0x4
  103332:	6a 6c                	push   0x6c
  103334:	e8 37 de ff ff       	call   101170 <term::write(char)>
  103339:	83 c4 04             	add    esp,0x4
  10333c:	6a 6f                	push   0x6f
  10333e:	e8 2d de ff ff       	call   101170 <term::write(char)>
  103343:	83 c4 04             	add    esp,0x4
  103346:	6a 61                	push   0x61
  103348:	e8 23 de ff ff       	call   101170 <term::write(char)>
  10334d:	83 c4 04             	add    esp,0x4
  103350:	6a 64                	push   0x64
  103352:	e8 19 de ff ff       	call   101170 <term::write(char)>
  103357:	83 c4 04             	add    esp,0x4
  10335a:	6a 65                	push   0x65
  10335c:	e8 0f de ff ff       	call   101170 <term::write(char)>
  103361:	83 c4 04             	add    esp,0x4
  103364:	6a 64                	push   0x64
  103366:	e8 05 de ff ff       	call   101170 <term::write(char)>
  10336b:	83 c4 04             	add    esp,0x4
  10336e:	6a 29                	push   0x29
  103370:	e8 fb dd ff ff       	call   101170 <term::write(char)>
  103375:	83 c4 04             	add    esp,0x4
  103378:	e9 b7 00 00 00       	jmp    103434 <kernel_main+0x19c4>
  10337d:	8b 04 24             	mov    eax,DWORD PTR [esp]
    r[a] = 0;
  103380:	c6 84 04 10 01 00 00 	mov    BYTE PTR [esp+eax*1+0x110],0x0
  103387:	00 
    for (auto b = 0; b < a / 2; b++) {
  103388:	a9 fe ff ff ff       	test   eax,0xfffffffe
  10338d:	8d bc 24 88 00 00 00 	lea    edi,[esp+0x88]
  103394:	74 3e                	je     1033d4 <kernel_main+0x1964>
  103396:	d1 ee                	shr    esi,1
  103398:	8d 84 24 10 01 00 00 	lea    eax,[esp+0x110]
  10339f:	90                   	nop
        r[b] ^= r[a - b - 1];
  1033a0:	0f b6 10             	movzx  edx,BYTE PTR [eax]
  1033a3:	32 11                	xor    dl,BYTE PTR [ecx]
  1033a5:	88 10                	mov    BYTE PTR [eax],dl
        r[a - b - 1] ^= r[b];
  1033a7:	32 11                	xor    dl,BYTE PTR [ecx]
  1033a9:	88 11                	mov    BYTE PTR [ecx],dl
        r[b] ^= r[a - b - 1];
  1033ab:	30 10                	xor    BYTE PTR [eax],dl
    for (auto b = 0; b < a / 2; b++) {
  1033ad:	40                   	inc    eax
  1033ae:	49                   	dec    ecx
  1033af:	4e                   	dec    esi
  1033b0:	75 ee                	jne    1033a0 <kernel_main+0x1930>
  1033b2:	eb 20                	jmp    1033d4 <kernel_main+0x1964>
        r[a++] = '0';
  1033b4:	c6 84 24 10 01 00 00 	mov    BYTE PTR [esp+0x110],0x30
  1033bb:	30 
  1033bc:	b8 01 00 00 00       	mov    eax,0x1
  1033c1:	eb 02                	jmp    1033c5 <kernel_main+0x1955>
  1033c3:	31 c0                	xor    eax,eax
    r[a] = 0;
  1033c5:	c6 84 04 10 01 00 00 	mov    BYTE PTR [esp+eax*1+0x110],0x0
  1033cc:	00 
  1033cd:	8d bc 24 88 00 00 00 	lea    edi,[esp+0x88]
    return r;
  1033d4:	b9 09 00 00 00       	mov    ecx,0x9
  1033d9:	8d b4 24 10 01 00 00 	lea    esi,[esp+0x110]
  1033e0:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  1033e2:	6a 3e                	push   0x3e
  1033e4:	e8 87 dd ff ff       	call   101170 <term::write(char)>
  1033e9:	83 c4 04             	add    esp,0x4
  1033ec:	6a 3e                	push   0x3e
  1033ee:	e8 7d dd ff ff       	call   101170 <term::write(char)>
  1033f3:	83 c4 04             	add    esp,0x4
  1033f6:	6a 3e                	push   0x3e
  1033f8:	e8 73 dd ff ff       	call   101170 <term::write(char)>
  1033fd:	83 c4 04             	add    esp,0x4
  103400:	6a 20                	push   0x20
  103402:	e8 69 dd ff ff       	call   101170 <term::write(char)>
  103407:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10340a:	8a 84 24 88 00 00 00 	mov    al,BYTE PTR [esp+0x88]
  103411:	84 c0                	test   al,al
  103413:	74 1f                	je     103434 <kernel_main+0x19c4>
  103415:	8d b4 24 89 00 00 00 	lea    esi,[esp+0x89]
  10341c:	90                   	nop
  10341d:	90                   	nop
  10341e:	90                   	nop
  10341f:	90                   	nop
        write(s[a]);
  103420:	0f be c0             	movsx  eax,al
  103423:	50                   	push   eax
  103424:	e8 47 dd ff ff       	call   101170 <term::write(char)>
  103429:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10342c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10342f:	46                   	inc    esi
  103430:	84 c0                	test   al,al
  103432:	75 ec                	jne    103420 <kernel_main+0x19b0>
  103434:	6a 0a                	push   0xa
  103436:	e8 35 dd ff ff       	call   101170 <term::write(char)>
  10343b:	83 c4 04             	add    esp,0x4
  10343e:	90                   	nop
  10343f:	90                   	nop
  103440:	31 c0                	xor    eax,eax
  103442:	90                   	nop
  103443:	90                   	nop
  103444:	90                   	nop
  103445:	90                   	nop
  103446:	90                   	nop
  103447:	90                   	nop
  103448:	90                   	nop
  103449:	90                   	nop
  10344a:	90                   	nop
  10344b:	90                   	nop
  10344c:	90                   	nop
  10344d:	90                   	nop
  10344e:	90                   	nop
  10344f:	90                   	nop
  103450:	31 c9                	xor    ecx,ecx
  103452:	90                   	nop
  103453:	90                   	nop
  103454:	90                   	nop
  103455:	90                   	nop
  103456:	90                   	nop
  103457:	90                   	nop
  103458:	90                   	nop
  103459:	90                   	nop
  10345a:	90                   	nop
  10345b:	90                   	nop
  10345c:	90                   	nop
  10345d:	90                   	nop
  10345e:	90                   	nop
  10345f:	90                   	nop
            if (this->operator[](a) == 0)
  103460:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  103465:	74 0b                	je     103472 <kernel_main+0x1a02>
        for (int a = 0; a < N; a++) {
  103467:	41                   	inc    ecx
  103468:	83 f9 50             	cmp    ecx,0x50
  10346b:	75 f3                	jne    103460 <kernel_main+0x19f0>
  10346d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  103472:	39 c8                	cmp    eax,ecx
  103474:	73 1a                	jae    103490 <kernel_main+0x1a20>
            if (p[a] == 0 || p[a] != this->operator[](a))
  103476:	83 f8 04             	cmp    eax,0x4
  103479:	74 45                	je     1034c0 <kernel_main+0x1a50>
  10347b:	8a 88 3b 00 10 00    	mov    cl,BYTE PTR [eax+0x10003b]
  103481:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  103485:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  103488:	74 c6                	je     103450 <kernel_main+0x19e0>
  10348a:	eb 34                	jmp    1034c0 <kernel_main+0x1a50>
  10348c:	90                   	nop
  10348d:	90                   	nop
  10348e:	90                   	nop
  10348f:	90                   	nop
  103490:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  103495:	90                   	nop
  103496:	90                   	nop
  103497:	90                   	nop
  103498:	90                   	nop
  103499:	90                   	nop
  10349a:	90                   	nop
  10349b:	90                   	nop
  10349c:	90                   	nop
  10349d:	90                   	nop
  10349e:	90                   	nop
  10349f:	90                   	nop
            if (this->operator[](a) == 0)
  1034a0:	80 7c 04 30 00       	cmp    BYTE PTR [esp+eax*1+0x30],0x0
  1034a5:	74 08                	je     1034af <kernel_main+0x1a3f>
        for (int a = 0; a < N; a++) {
  1034a7:	40                   	inc    eax
  1034a8:	83 f8 4c             	cmp    eax,0x4c
  1034ab:	75 f3                	jne    1034a0 <kernel_main+0x1a30>
  1034ad:	eb 11                	jmp    1034c0 <kernel_main+0x1a50>
        return p[length()] == 0;
  1034af:	85 c0                	test   eax,eax
        if (command == "game") {
  1034b1:	0f 84 db 02 00 00    	je     103792 <kernel_main+0x1d22>
  1034b7:	90                   	nop
  1034b8:	90                   	nop
  1034b9:	90                   	nop
  1034ba:	90                   	nop
  1034bb:	90                   	nop
  1034bc:	90                   	nop
  1034bd:	90                   	nop
  1034be:	90                   	nop
  1034bf:	90                   	nop
  1034c0:	31 c0                	xor    eax,eax
  1034c2:	90                   	nop
  1034c3:	90                   	nop
  1034c4:	90                   	nop
  1034c5:	90                   	nop
  1034c6:	90                   	nop
  1034c7:	90                   	nop
  1034c8:	90                   	nop
  1034c9:	90                   	nop
  1034ca:	90                   	nop
  1034cb:	90                   	nop
  1034cc:	90                   	nop
  1034cd:	90                   	nop
  1034ce:	90                   	nop
  1034cf:	90                   	nop
  1034d0:	31 c9                	xor    ecx,ecx
  1034d2:	90                   	nop
  1034d3:	90                   	nop
  1034d4:	90                   	nop
  1034d5:	90                   	nop
  1034d6:	90                   	nop
  1034d7:	90                   	nop
  1034d8:	90                   	nop
  1034d9:	90                   	nop
  1034da:	90                   	nop
  1034db:	90                   	nop
  1034dc:	90                   	nop
  1034dd:	90                   	nop
  1034de:	90                   	nop
  1034df:	90                   	nop
            if (this->operator[](a) == 0)
  1034e0:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  1034e5:	74 0b                	je     1034f2 <kernel_main+0x1a82>
        for (int a = 0; a < N; a++) {
  1034e7:	41                   	inc    ecx
  1034e8:	83 f9 50             	cmp    ecx,0x50
  1034eb:	75 f3                	jne    1034e0 <kernel_main+0x1a70>
  1034ed:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  1034f2:	39 c8                	cmp    eax,ecx
  1034f4:	73 2a                	jae    103520 <kernel_main+0x1ab0>
            if (p[a] == 0 || p[a] != this->operator[](a))
  1034f6:	83 f8 06             	cmp    eax,0x6
  1034f9:	0f 84 01 02 00 00    	je     103700 <kernel_main+0x1c90>
  1034ff:	8a 88 27 00 10 00    	mov    cl,BYTE PTR [eax+0x100027]
  103505:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  103509:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  10350c:	74 c2                	je     1034d0 <kernel_main+0x1a60>
  10350e:	e9 ed 01 00 00       	jmp    103700 <kernel_main+0x1c90>
  103513:	90                   	nop
  103514:	90                   	nop
  103515:	90                   	nop
  103516:	90                   	nop
  103517:	90                   	nop
  103518:	90                   	nop
  103519:	90                   	nop
  10351a:	90                   	nop
  10351b:	90                   	nop
  10351c:	90                   	nop
  10351d:	90                   	nop
  10351e:	90                   	nop
  10351f:	90                   	nop
  103520:	b8 fa ff ff ff       	mov    eax,0xfffffffa
  103525:	90                   	nop
  103526:	90                   	nop
  103527:	90                   	nop
  103528:	90                   	nop
  103529:	90                   	nop
  10352a:	90                   	nop
  10352b:	90                   	nop
  10352c:	90                   	nop
  10352d:	90                   	nop
  10352e:	90                   	nop
  10352f:	90                   	nop
            if (this->operator[](a) == 0)
  103530:	80 7c 04 32 00       	cmp    BYTE PTR [esp+eax*1+0x32],0x0
  103535:	74 0b                	je     103542 <kernel_main+0x1ad2>
        for (int a = 0; a < N; a++) {
  103537:	40                   	inc    eax
  103538:	83 f8 4a             	cmp    eax,0x4a
  10353b:	75 f3                	jne    103530 <kernel_main+0x1ac0>
  10353d:	e9 be 01 00 00       	jmp    103700 <kernel_main+0x1c90>
        return p[length()] == 0;
  103542:	85 c0                	test   eax,eax
        if (command == "matrix") {
  103544:	0f 85 b6 01 00 00    	jne    103700 <kernel_main+0x1c90>
  10354a:	31 c0                	xor    eax,eax
  10354c:	90                   	nop
  10354d:	90                   	nop
  10354e:	90                   	nop
  10354f:	90                   	nop
            if (this->operator[](a) == 0)
  103550:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  103557:	00 
  103558:	74 08                	je     103562 <kernel_main+0x1af2>
        for (int a = 0; a < N; a++) {
  10355a:	40                   	inc    eax
  10355b:	83 f8 50             	cmp    eax,0x50
  10355e:	75 f0                	jne    103550 <kernel_main+0x1ae0>
  103560:	eb 04                	jmp    103566 <kernel_main+0x1af6>
        for (int a = 0; a < length(); a++) {
  103562:	85 c0                	test   eax,eax
  103564:	74 76                	je     1035dc <kernel_main+0x1b6c>
  103566:	31 c0                	xor    eax,eax
  103568:	90                   	nop
  103569:	90                   	nop
  10356a:	90                   	nop
  10356b:	90                   	nop
  10356c:	90                   	nop
  10356d:	90                   	nop
  10356e:	90                   	nop
  10356f:	90                   	nop
            if (this->operator[](a) == 0)
  103570:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  103577:	00 
  103578:	74 0b                	je     103585 <kernel_main+0x1b15>
        for (int a = 0; a < N; a++) {
  10357a:	40                   	inc    eax
  10357b:	83 f8 50             	cmp    eax,0x50
  10357e:	75 f0                	jne    103570 <kernel_main+0x1b00>
  103580:	b8 50 00 00 00       	mov    eax,0x50
        return dual_iterator<const char>(this->data_ + length());
  103585:	8d 8c 04 b4 00 00 00 	lea    ecx,[esp+eax*1+0xb4]
  10358c:	8d 94 24 b4 00 00 00 	lea    edx,[esp+0xb4]
        return ptr_ != p.ptr_;
  103593:	39 ca                	cmp    edx,ecx
    for (auto c : p) {
  103595:	74 30                	je     1035c7 <kernel_main+0x1b57>
  103597:	89 d1                	mov    ecx,edx
  103599:	31 f6                	xor    esi,esi
  10359b:	90                   	nop
  10359c:	90                   	nop
  10359d:	90                   	nop
  10359e:	90                   	nop
  10359f:	90                   	nop
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  1035a0:	0f be 11             	movsx  edx,BYTE PTR [ecx]
        r *= B;
  1035a3:	8d 34 b6             	lea    esi,[esi+esi*4]
        r += static_cast<int>(c.value - '0');
  1035a6:	8d 74 72 d0          	lea    esi,[edx+esi*2-0x30]
        ptr_++;
  1035aa:	41                   	inc    ecx
        return ptr_ != p.ptr_;
  1035ab:	48                   	dec    eax
    for (auto c : p) {
  1035ac:	75 f2                	jne    1035a0 <kernel_main+0x1b30>
        colour = static_cast<uint8>(fg | (bg << 4));
  1035ae:	66 c7 05 0c 60 10 00 	mov    WORD PTR ds:0x10600c,0x102
  1035b5:	02 01 
            term::terminal.wrap = true;
  1035b7:	c6 05 0e 60 10 00 01 	mov    BYTE PTR ds:0x10600e,0x1
            for (int a = 0; a < n; a++) {
  1035be:	85 f6                	test   esi,esi
  1035c0:	7f 2f                	jg     1035f1 <kernel_main+0x1b81>
  1035c2:	e9 1e 01 00 00       	jmp    1036e5 <kernel_main+0x1c75>
  1035c7:	66 c7 05 0c 60 10 00 	mov    WORD PTR ds:0x10600c,0x102
  1035ce:	02 01 
            term::terminal.wrap = true;
  1035d0:	c6 05 0e 60 10 00 01 	mov    BYTE PTR ds:0x10600e,0x1
  1035d7:	e9 09 01 00 00       	jmp    1036e5 <kernel_main+0x1c75>
  1035dc:	66 c7 05 0c 60 10 00 	mov    WORD PTR ds:0x10600c,0x102
  1035e3:	02 01 
  1035e5:	c6 05 0e 60 10 00 01 	mov    BYTE PTR ds:0x10600e,0x1
  1035ec:	be 01 00 00 00       	mov    esi,0x1
  1035f1:	31 c0                	xor    eax,eax
  1035f3:	89 74 24 04          	mov    DWORD PTR [esp+0x4],esi
  1035f7:	eb 17                	jmp    103610 <kernel_main+0x1ba0>
  1035f9:	90                   	nop
  1035fa:	90                   	nop
  1035fb:	90                   	nop
  1035fc:	90                   	nop
  1035fd:	90                   	nop
  1035fe:	90                   	nop
  1035ff:	90                   	nop
  103600:	8b 04 24             	mov    eax,DWORD PTR [esp]
            for (int a = 0; a < n; a++) {
  103603:	40                   	inc    eax
  103604:	8b 74 24 04          	mov    esi,DWORD PTR [esp+0x4]
  103608:	39 f0                	cmp    eax,esi
  10360a:	0f 84 d5 00 00 00    	je     1036e5 <kernel_main+0x1c75>
  103610:	89 04 24             	mov    DWORD PTR [esp],eax
                term::clear();
  103613:	e8 68 da ff ff       	call   101080 <term::clear()>
  103618:	31 f6                	xor    esi,esi
  10361a:	eb 52                	jmp    10366e <kernel_main+0x1bfe>
  10361c:	90                   	nop
  10361d:	90                   	nop
  10361e:	90                   	nop
  10361f:	90                   	nop
        if (!flipped) {
  103620:	80 3d 0d 60 10 00 00 	cmp    BYTE PTR ds:0x10600d,0x0
  103627:	0f 84 80 00 00 00    	je     1036ad <kernel_main+0x1c3d>
            increment_cursor(row, col, max_row, max_col, max_row - (row % max_row));
  10362d:	8b 0d 08 60 10 00    	mov    ecx,DWORD PTR ds:0x106008
  103633:	89 c8                	mov    eax,ecx
  103635:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  10363a:	f7 ea                	imul   edx
  10363c:	89 d0                	mov    eax,edx
  10363e:	c1 e8 1f             	shr    eax,0x1f
  103641:	c1 fa 03             	sar    edx,0x3
  103644:	01 c2                	add    edx,eax
  103646:	8d 04 92             	lea    eax,[edx+edx*4]
  103649:	8d 04 80             	lea    eax,[eax+eax*4]
  10364c:	29 c8                	sub    eax,ecx
  10364e:	83 c0 19             	add    eax,0x19
  103651:	b9 08 60 10 00       	mov    ecx,0x106008
  103656:	ba 04 60 10 00       	mov    edx,0x106004
  10365b:	50                   	push   eax
  10365c:	6a 50                	push   0x50
  10365e:	6a 19                	push   0x19
  103660:	e8 cb 01 00 00       	call   103830 <term::$_2::increment_cursor(int&, int&, int, int, int)>
  103665:	83 c4 0c             	add    esp,0xc
            value++;
  103668:	46                   	inc    esi
            return value != p.value;
  103669:	83 fe 50             	cmp    esi,0x50
                for (auto _ : range<0, term::max_col>) {
  10366c:	74 92                	je     103600 <kernel_main+0x1b90>
  10366e:	31 ff                	xor    edi,edi
                        if (rnd.next(10) == 1) {
  103670:	6a 0a                	push   0xa
  103672:	53                   	push   ebx
  103673:	e8 98 07 00 00       	call   103e10 <rand::random_gen::next(unsigned int)>
  103678:	83 c4 08             	add    esp,0x8
  10367b:	83 f8 01             	cmp    eax,0x1
  10367e:	74 a0                	je     103620 <kernel_main+0x1bb0>
                        term::write(char(' ' + (rnd.next(64))));
  103680:	6a 40                	push   0x40
  103682:	53                   	push   ebx
  103683:	e8 88 07 00 00       	call   103e10 <rand::random_gen::next(unsigned int)>
  103688:	83 c4 08             	add    esp,0x8
  10368b:	04 20                	add    al,0x20
  10368d:	0f be c0             	movsx  eax,al
  103690:	50                   	push   eax
  103691:	e8 da da ff ff       	call   101170 <term::write(char)>
  103696:	83 c4 04             	add    esp,0x4
  103699:	b8 00 00 1e 00       	mov    eax,0x1e0000
  10369e:	90                   	nop
  10369f:	90                   	nop
        asm volatile ("and %eax,%eax");
  1036a0:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  1036a2:	48                   	dec    eax
  1036a3:	75 fb                	jne    1036a0 <kernel_main+0x1c30>
            value++;
  1036a5:	47                   	inc    edi
            return value != p.value;
  1036a6:	83 ff 19             	cmp    edi,0x19
                    for (auto _ : range<0, term::max_row>) {
  1036a9:	75 c5                	jne    103670 <kernel_main+0x1c00>
  1036ab:	eb bb                	jmp    103668 <kernel_main+0x1bf8>
            increment_cursor(col, row, max_col, max_row, max_col - (col % max_col));
  1036ad:	8b 0d 04 60 10 00    	mov    ecx,DWORD PTR ds:0x106004
  1036b3:	89 c8                	mov    eax,ecx
  1036b5:	ba 67 66 66 66       	mov    edx,0x66666667
  1036ba:	f7 ea                	imul   edx
  1036bc:	89 d0                	mov    eax,edx
  1036be:	c1 e8 1f             	shr    eax,0x1f
  1036c1:	c1 fa 05             	sar    edx,0x5
  1036c4:	01 c2                	add    edx,eax
  1036c6:	c1 e2 04             	shl    edx,0x4
  1036c9:	8d 04 92             	lea    eax,[edx+edx*4]
  1036cc:	29 c8                	sub    eax,ecx
  1036ce:	83 c0 50             	add    eax,0x50
  1036d1:	b9 04 60 10 00       	mov    ecx,0x106004
  1036d6:	ba 08 60 10 00       	mov    edx,0x106008
  1036db:	50                   	push   eax
  1036dc:	6a 19                	push   0x19
  1036de:	6a 50                	push   0x50
  1036e0:	e9 7b ff ff ff       	jmp    103660 <kernel_main+0x1bf0>
            term::terminal.wrap = false;
  1036e5:	c6 05 0e 60 10 00 00 	mov    BYTE PTR ds:0x10600e,0x0
        colour = static_cast<uint8>(fg | (bg << 4));
  1036ec:	66 c7 05 0c 60 10 00 	mov    WORD PTR ds:0x10600c,0xf
  1036f3:	0f 00 
  1036f5:	90                   	nop
  1036f6:	90                   	nop
  1036f7:	90                   	nop
  1036f8:	90                   	nop
  1036f9:	90                   	nop
  1036fa:	90                   	nop
  1036fb:	90                   	nop
  1036fc:	90                   	nop
  1036fd:	90                   	nop
  1036fe:	90                   	nop
  1036ff:	90                   	nop
  103700:	31 c0                	xor    eax,eax
  103702:	90                   	nop
  103703:	90                   	nop
  103704:	90                   	nop
  103705:	90                   	nop
  103706:	90                   	nop
  103707:	90                   	nop
  103708:	90                   	nop
  103709:	90                   	nop
  10370a:	90                   	nop
  10370b:	90                   	nop
  10370c:	90                   	nop
  10370d:	90                   	nop
  10370e:	90                   	nop
  10370f:	90                   	nop
  103710:	31 c9                	xor    ecx,ecx
  103712:	90                   	nop
  103713:	90                   	nop
  103714:	90                   	nop
  103715:	90                   	nop
  103716:	90                   	nop
  103717:	90                   	nop
  103718:	90                   	nop
  103719:	90                   	nop
  10371a:	90                   	nop
  10371b:	90                   	nop
  10371c:	90                   	nop
  10371d:	90                   	nop
  10371e:	90                   	nop
  10371f:	90                   	nop
            if (this->operator[](a) == 0)
  103720:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  103725:	74 0b                	je     103732 <kernel_main+0x1cc2>
        for (int a = 0; a < N; a++) {
  103727:	41                   	inc    ecx
  103728:	83 f9 50             	cmp    ecx,0x50
  10372b:	75 f3                	jne    103720 <kernel_main+0x1cb0>
  10372d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  103732:	39 c8                	cmp    eax,ecx
  103734:	73 2a                	jae    103760 <kernel_main+0x1cf0>
            if (p[a] == 0 || p[a] != this->operator[](a))
  103736:	83 f8 08             	cmp    eax,0x8
  103739:	0f 84 81 ee ff ff    	je     1025c0 <kernel_main+0xb50>
  10373f:	8a 88 5f 00 10 00    	mov    cl,BYTE PTR [eax+0x10005f]
  103745:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  103749:	8d 40 01             	lea    eax,[eax+0x1]
  10374c:	74 c2                	je     103710 <kernel_main+0x1ca0>
  10374e:	e9 6d ee ff ff       	jmp    1025c0 <kernel_main+0xb50>
  103753:	90                   	nop
  103754:	90                   	nop
  103755:	90                   	nop
  103756:	90                   	nop
  103757:	90                   	nop
  103758:	90                   	nop
  103759:	90                   	nop
  10375a:	90                   	nop
  10375b:	90                   	nop
  10375c:	90                   	nop
  10375d:	90                   	nop
  10375e:	90                   	nop
  10375f:	90                   	nop
  103760:	b8 f8 ff ff ff       	mov    eax,0xfffffff8
  103765:	90                   	nop
  103766:	90                   	nop
  103767:	90                   	nop
  103768:	90                   	nop
  103769:	90                   	nop
  10376a:	90                   	nop
  10376b:	90                   	nop
  10376c:	90                   	nop
  10376d:	90                   	nop
  10376e:	90                   	nop
  10376f:	90                   	nop
            if (this->operator[](a) == 0)
  103770:	80 7c 04 34 00       	cmp    BYTE PTR [esp+eax*1+0x34],0x0
  103775:	0f 84 33 ee ff ff    	je     1025ae <kernel_main+0xb3e>
        for (int a = 0; a < N; a++) {
  10377b:	40                   	inc    eax
  10377c:	83 f8 48             	cmp    eax,0x48
  10377f:	75 ef                	jne    103770 <kernel_main+0x1d00>
  103781:	e9 3a ee ff ff       	jmp    1025c0 <kernel_main+0xb50>
    asm("hlt");
  103786:	f4                   	hlt    
  103787:	90                   	nop
  103788:	90                   	nop
  103789:	90                   	nop
  10378a:	90                   	nop
  10378b:	90                   	nop
  10378c:	90                   	nop
  10378d:	90                   	nop
  10378e:	90                   	nop
  10378f:	90                   	nop
    while (true)
  103790:	eb fe                	jmp    103790 <kernel_main+0x1d20>
  103792:	8d b4 24 10 01 00 00 	lea    esi,[esp+0x110]
            game_of_life g;
  103799:	56                   	push   esi
  10379a:	e8 31 05 00 00       	call   103cd0 <game_of_life::game_of_life()>
  10379f:	83 c4 04             	add    esp,0x4
            }
    }

    void run(int gens = 10) {
        for (int a = 0; a < gens; a++) {
            step();
  1037a2:	56                   	push   esi
  1037a3:	e8 e8 07 00 00       	call   103f90 <game_of_life::step()>
  1037a8:	83 c4 04             	add    esp,0x4
  1037ab:	31 f6                	xor    esi,esi
  1037ad:	bb 2d 00 00 00       	mov    ebx,0x2d
  1037b2:	90                   	nop
  1037b3:	90                   	nop
  1037b4:	90                   	nop
  1037b5:	90                   	nop
  1037b6:	90                   	nop
  1037b7:	90                   	nop
  1037b8:	90                   	nop
  1037b9:	90                   	nop
  1037ba:	90                   	nop
  1037bb:	90                   	nop
  1037bc:	90                   	nop
  1037bd:	90                   	nop
  1037be:	90                   	nop
  1037bf:	90                   	nop
  1037c0:	bf 19 00 00 00       	mov    edi,0x19
  1037c5:	89 34 24             	mov    DWORD PTR [esp],esi
  1037c8:	90                   	nop
  1037c9:	90                   	nop
  1037ca:	90                   	nop
  1037cb:	90                   	nop
  1037cc:	90                   	nop
  1037cd:	90                   	nop
  1037ce:	90                   	nop
  1037cf:	90                   	nop
    template <class I> constexpr bool operator[](I i) const {
        auto b = bytes_[i / 8];
        return (b & (1 << (i % 8))) != 0;
    }
    template <class I> constexpr bit_member operator[](I i) {
        return bit_member(*this, static_cast<int>(i));
  1037d0:	56                   	push   esi
  1037d1:	8d 84 24 14 01 00 00 	lea    eax,[esp+0x114]
  1037d8:	50                   	push   eax
  1037d9:	8d 84 24 90 00 00 00 	lea    eax,[esp+0x90]
  1037e0:	50                   	push   eax
  1037e1:	e8 6a 07 00 00       	call   103f50 <bit_sequence<2000>::bit_member::bit_member(bit_sequence<2000>&, int)>
  1037e6:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  1037e9:	80 bc 24 90 00 00 00 	cmp    BYTE PTR [esp+0x90],0x0
  1037f0:	00 

    void draw() {
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                auto c = board(x, y);
                term::write(c ? 'X' : '-');
  1037f1:	b8 58 00 00 00       	mov    eax,0x58
  1037f6:	0f 44 c3             	cmove  eax,ebx
  1037f9:	50                   	push   eax
  1037fa:	e8 71 d9 ff ff       	call   101170 <term::write(char)>
  1037ff:	83 c4 04             	add    esp,0x4
            for (int y = 0; y < height; y++) {
  103802:	83 c6 50             	add    esi,0x50
  103805:	4f                   	dec    edi
  103806:	75 c8                	jne    1037d0 <kernel_main+0x1d60>
  103808:	8b 34 24             	mov    esi,DWORD PTR [esp]
        for (int x = 0; x < width; x++) {
  10380b:	46                   	inc    esi
  10380c:	83 fe 50             	cmp    esi,0x50
  10380f:	75 af                	jne    1037c0 <kernel_main+0x1d50>
  103811:	90                   	nop
  103812:	90                   	nop
  103813:	90                   	nop
  103814:	90                   	nop
  103815:	90                   	nop
  103816:	90                   	nop
  103817:	90                   	nop
  103818:	90                   	nop
  103819:	90                   	nop
  10381a:	90                   	nop
  10381b:	90                   	nop
  10381c:	90                   	nop
  10381d:	90                   	nop
  10381e:	90                   	nop
  10381f:	90                   	nop
            while(true);
  103820:	eb fe                	jmp    103820 <kernel_main+0x1db0>
        term::fatal_error("FAIL (shutting down)\n");
  103822:	68 11 00 10 00       	push   0x100011
  103827:	e8 64 04 00 00       	call   103c90 <void term::fatal_error<char const*>(char const*)>
  10382c:	90                   	nop
  10382d:	90                   	nop
  10382e:	90                   	nop
  10382f:	90                   	nop

00103830 <term::$_2::increment_cursor(int&, int&, int, int, int)>:
                          int cross_limit, int times = 0) {
  103830:	55                   	push   ebp
  103831:	89 e5                	mov    ebp,esp
  103833:	53                   	push   ebx
  103834:	57                   	push   edi
  103835:	56                   	push   esi
  103836:	83 ec 08             	sub    esp,0x8
  103839:	89 55 f0             	mov    DWORD PTR [ebp-0x10],edx
  10383c:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
        for (int a = 0; a < times; a++) {
  10383f:	85 c0                	test   eax,eax
  103841:	0f 8e 13 03 00 00    	jle    103b5a <term::$_2::increment_cursor(int&, int&, int, int, int)+0x32a>
  103847:	89 cf                	mov    edi,ecx
  103849:	80 3d 0e 60 10 00 00 	cmp    BYTE PTR ds:0x10600e,0x0
  103850:	75 25                	jne    103877 <term::$_2::increment_cursor(int&, int&, int, int, int)+0x47>
  103852:	8b 1d 0c 60 10 00    	mov    ebx,DWORD PTR ds:0x10600c
  103858:	c1 e3 08             	shl    ebx,0x8
  10385b:	83 cb 20             	or     ebx,0x20
  10385e:	8b 35 00 60 10 00    	mov    esi,DWORD PTR ds:0x106000
  103864:	31 c9                	xor    ecx,ecx
  103866:	89 7d ec             	mov    DWORD PTR [ebp-0x14],edi
  103869:	eb 61                	jmp    1038cc <term::$_2::increment_cursor(int&, int&, int, int, int)+0x9c>
  10386b:	90                   	nop
  10386c:	90                   	nop
  10386d:	90                   	nop
  10386e:	90                   	nop
  10386f:	90                   	nop
  103870:	48                   	dec    eax
  103871:	0f 84 e3 02 00 00    	je     103b5a <term::$_2::increment_cursor(int&, int&, int, int, int)+0x32a>
            main++;
  103877:	8b 0f                	mov    ecx,DWORD PTR [edi]
  103879:	41                   	inc    ecx
  10387a:	89 0f                	mov    DWORD PTR [edi],ecx
            if (main == main_limit) {
  10387c:	3b 4d 08             	cmp    ecx,DWORD PTR [ebp+0x8]
  10387f:	75 1f                	jne    1038a0 <term::$_2::increment_cursor(int&, int&, int, int, int)+0x70>
                main = 0;
  103881:	c7 07 00 00 00 00    	mov    DWORD PTR [edi],0x0
  103887:	8b 4d f0             	mov    ecx,DWORD PTR [ebp-0x10]
                cross++;
  10388a:	8b 11                	mov    edx,DWORD PTR [ecx]
  10388c:	42                   	inc    edx
  10388d:	89 11                	mov    DWORD PTR [ecx],edx
            if (cross == cross_limit) {
  10388f:	3b 55 0c             	cmp    edx,DWORD PTR [ebp+0xc]
  103892:	75 dc                	jne    103870 <term::$_2::increment_cursor(int&, int&, int, int, int)+0x40>
  103894:	eb 14                	jmp    1038aa <term::$_2::increment_cursor(int&, int&, int, int, int)+0x7a>
  103896:	90                   	nop
  103897:	90                   	nop
  103898:	90                   	nop
  103899:	90                   	nop
  10389a:	90                   	nop
  10389b:	90                   	nop
  10389c:	90                   	nop
  10389d:	90                   	nop
  10389e:	90                   	nop
  10389f:	90                   	nop
  1038a0:	8b 4d f0             	mov    ecx,DWORD PTR [ebp-0x10]
  1038a3:	8b 11                	mov    edx,DWORD PTR [ecx]
  1038a5:	3b 55 0c             	cmp    edx,DWORD PTR [ebp+0xc]
  1038a8:	75 c6                	jne    103870 <term::$_2::increment_cursor(int&, int&, int, int, int)+0x40>
  1038aa:	c7 07 00 00 00 00    	mov    DWORD PTR [edi],0x0
  1038b0:	8b 4d f0             	mov    ecx,DWORD PTR [ebp-0x10]
                    cross = 0;
  1038b3:	c7 01 00 00 00 00    	mov    DWORD PTR [ecx],0x0
  1038b9:	eb b5                	jmp    103870 <term::$_2::increment_cursor(int&, int&, int, int, int)+0x40>
  1038bb:	90                   	nop
  1038bc:	90                   	nop
  1038bd:	90                   	nop
  1038be:	90                   	nop
  1038bf:	90                   	nop
        for (int a = 0; a < times; a++) {
  1038c0:	41                   	inc    ecx
  1038c1:	39 c1                	cmp    ecx,eax
  1038c3:	8b 7d ec             	mov    edi,DWORD PTR [ebp-0x14]
  1038c6:	0f 84 8e 02 00 00    	je     103b5a <term::$_2::increment_cursor(int&, int&, int, int, int)+0x32a>
  1038cc:	89 fa                	mov    edx,edi
            main++;
  1038ce:	8b 3f                	mov    edi,DWORD PTR [edi]
  1038d0:	47                   	inc    edi
  1038d1:	89 3a                	mov    DWORD PTR [edx],edi
            if (main == main_limit) {
  1038d3:	3b 7d 08             	cmp    edi,DWORD PTR [ebp+0x8]
  1038d6:	75 18                	jne    1038f0 <term::$_2::increment_cursor(int&, int&, int, int, int)+0xc0>
                main = 0;
  1038d8:	c7 02 00 00 00 00    	mov    DWORD PTR [edx],0x0
  1038de:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
                cross++;
  1038e1:	8b 3a                	mov    edi,DWORD PTR [edx]
  1038e3:	47                   	inc    edi
  1038e4:	89 3a                	mov    DWORD PTR [edx],edi
            if (cross == cross_limit) {
  1038e6:	3b 7d 0c             	cmp    edi,DWORD PTR [ebp+0xc]
  1038e9:	75 d5                	jne    1038c0 <term::$_2::increment_cursor(int&, int&, int, int, int)+0x90>
  1038eb:	eb 0d                	jmp    1038fa <term::$_2::increment_cursor(int&, int&, int, int, int)+0xca>
  1038ed:	90                   	nop
  1038ee:	90                   	nop
  1038ef:	90                   	nop
  1038f0:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
  1038f3:	8b 3a                	mov    edi,DWORD PTR [edx]
  1038f5:	3b 7d 0c             	cmp    edi,DWORD PTR [ebp+0xc]
  1038f8:	75 c6                	jne    1038c0 <term::$_2::increment_cursor(int&, int&, int, int, int)+0x90>
  1038fa:	8b 55 ec             	mov    edx,DWORD PTR [ebp-0x14]
  1038fd:	c7 02 00 00 00 00    	mov    DWORD PTR [edx],0x0
  103903:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
                    cross--;
  103906:	ff 0a                	dec    DWORD PTR [edx]
  103908:	bf 00 f1 ff ff       	mov    edi,0xfffff100
  10390d:	90                   	nop
  10390e:	90                   	nop
  10390f:	90                   	nop
                        VGA_BUF[a] = VGA_BUF[a + max_col];
  103910:	0f b7 94 3e a0 0f 00 	movzx  edx,WORD PTR [esi+edi*1+0xfa0]
  103917:	00 
  103918:	66 89 94 3e 00 0f 00 	mov    WORD PTR [esi+edi*1+0xf00],dx
  10391f:	00 
  103920:	83 c7 02             	add    edi,0x2
                    for (auto a : range<0, (max_row - 1) * max_col>) {
  103923:	75 eb                	jne    103910 <term::$_2::increment_cursor(int&, int&, int, int, int)+0xe0>
                        VGA_BUF[a] = static_cast<uint16>((colour << 8) | ' ');
  103925:	66 89 9e 00 0f 00 00 	mov    WORD PTR [esi+0xf00],bx
  10392c:	66 89 9e 02 0f 00 00 	mov    WORD PTR [esi+0xf02],bx
  103933:	66 89 9e 04 0f 00 00 	mov    WORD PTR [esi+0xf04],bx
  10393a:	66 89 9e 06 0f 00 00 	mov    WORD PTR [esi+0xf06],bx
  103941:	66 89 9e 08 0f 00 00 	mov    WORD PTR [esi+0xf08],bx
  103948:	66 89 9e 0a 0f 00 00 	mov    WORD PTR [esi+0xf0a],bx
  10394f:	66 89 9e 0c 0f 00 00 	mov    WORD PTR [esi+0xf0c],bx
  103956:	66 89 9e 0e 0f 00 00 	mov    WORD PTR [esi+0xf0e],bx
  10395d:	66 89 9e 10 0f 00 00 	mov    WORD PTR [esi+0xf10],bx
  103964:	66 89 9e 12 0f 00 00 	mov    WORD PTR [esi+0xf12],bx
  10396b:	66 89 9e 14 0f 00 00 	mov    WORD PTR [esi+0xf14],bx
  103972:	66 89 9e 16 0f 00 00 	mov    WORD PTR [esi+0xf16],bx
  103979:	66 89 9e 18 0f 00 00 	mov    WORD PTR [esi+0xf18],bx
  103980:	66 89 9e 1a 0f 00 00 	mov    WORD PTR [esi+0xf1a],bx
  103987:	66 89 9e 1c 0f 00 00 	mov    WORD PTR [esi+0xf1c],bx
  10398e:	66 89 9e 1e 0f 00 00 	mov    WORD PTR [esi+0xf1e],bx
  103995:	66 89 9e 20 0f 00 00 	mov    WORD PTR [esi+0xf20],bx
  10399c:	66 89 9e 22 0f 00 00 	mov    WORD PTR [esi+0xf22],bx
  1039a3:	66 89 9e 24 0f 00 00 	mov    WORD PTR [esi+0xf24],bx
  1039aa:	66 89 9e 26 0f 00 00 	mov    WORD PTR [esi+0xf26],bx
  1039b1:	66 89 9e 28 0f 00 00 	mov    WORD PTR [esi+0xf28],bx
  1039b8:	66 89 9e 2a 0f 00 00 	mov    WORD PTR [esi+0xf2a],bx
  1039bf:	66 89 9e 2c 0f 00 00 	mov    WORD PTR [esi+0xf2c],bx
  1039c6:	66 89 9e 2e 0f 00 00 	mov    WORD PTR [esi+0xf2e],bx
  1039cd:	66 89 9e 30 0f 00 00 	mov    WORD PTR [esi+0xf30],bx
  1039d4:	66 89 9e 32 0f 00 00 	mov    WORD PTR [esi+0xf32],bx
  1039db:	66 89 9e 34 0f 00 00 	mov    WORD PTR [esi+0xf34],bx
  1039e2:	66 89 9e 36 0f 00 00 	mov    WORD PTR [esi+0xf36],bx
  1039e9:	66 89 9e 38 0f 00 00 	mov    WORD PTR [esi+0xf38],bx
  1039f0:	66 89 9e 3a 0f 00 00 	mov    WORD PTR [esi+0xf3a],bx
  1039f7:	66 89 9e 3c 0f 00 00 	mov    WORD PTR [esi+0xf3c],bx
  1039fe:	66 89 9e 3e 0f 00 00 	mov    WORD PTR [esi+0xf3e],bx
  103a05:	66 89 9e 40 0f 00 00 	mov    WORD PTR [esi+0xf40],bx
  103a0c:	66 89 9e 42 0f 00 00 	mov    WORD PTR [esi+0xf42],bx
  103a13:	66 89 9e 44 0f 00 00 	mov    WORD PTR [esi+0xf44],bx
  103a1a:	66 89 9e 46 0f 00 00 	mov    WORD PTR [esi+0xf46],bx
  103a21:	66 89 9e 48 0f 00 00 	mov    WORD PTR [esi+0xf48],bx
  103a28:	66 89 9e 4a 0f 00 00 	mov    WORD PTR [esi+0xf4a],bx
  103a2f:	66 89 9e 4c 0f 00 00 	mov    WORD PTR [esi+0xf4c],bx
  103a36:	66 89 9e 4e 0f 00 00 	mov    WORD PTR [esi+0xf4e],bx
  103a3d:	66 89 9e 50 0f 00 00 	mov    WORD PTR [esi+0xf50],bx
  103a44:	66 89 9e 52 0f 00 00 	mov    WORD PTR [esi+0xf52],bx
  103a4b:	66 89 9e 54 0f 00 00 	mov    WORD PTR [esi+0xf54],bx
  103a52:	66 89 9e 56 0f 00 00 	mov    WORD PTR [esi+0xf56],bx
  103a59:	66 89 9e 58 0f 00 00 	mov    WORD PTR [esi+0xf58],bx
  103a60:	66 89 9e 5a 0f 00 00 	mov    WORD PTR [esi+0xf5a],bx
  103a67:	66 89 9e 5c 0f 00 00 	mov    WORD PTR [esi+0xf5c],bx
  103a6e:	66 89 9e 5e 0f 00 00 	mov    WORD PTR [esi+0xf5e],bx
  103a75:	66 89 9e 60 0f 00 00 	mov    WORD PTR [esi+0xf60],bx
  103a7c:	66 89 9e 62 0f 00 00 	mov    WORD PTR [esi+0xf62],bx
  103a83:	66 89 9e 64 0f 00 00 	mov    WORD PTR [esi+0xf64],bx
  103a8a:	66 89 9e 66 0f 00 00 	mov    WORD PTR [esi+0xf66],bx
  103a91:	66 89 9e 68 0f 00 00 	mov    WORD PTR [esi+0xf68],bx
  103a98:	66 89 9e 6a 0f 00 00 	mov    WORD PTR [esi+0xf6a],bx
  103a9f:	66 89 9e 6c 0f 00 00 	mov    WORD PTR [esi+0xf6c],bx
  103aa6:	66 89 9e 6e 0f 00 00 	mov    WORD PTR [esi+0xf6e],bx
  103aad:	66 89 9e 70 0f 00 00 	mov    WORD PTR [esi+0xf70],bx
  103ab4:	66 89 9e 72 0f 00 00 	mov    WORD PTR [esi+0xf72],bx
  103abb:	66 89 9e 74 0f 00 00 	mov    WORD PTR [esi+0xf74],bx
  103ac2:	66 89 9e 76 0f 00 00 	mov    WORD PTR [esi+0xf76],bx
  103ac9:	66 89 9e 78 0f 00 00 	mov    WORD PTR [esi+0xf78],bx
  103ad0:	66 89 9e 7a 0f 00 00 	mov    WORD PTR [esi+0xf7a],bx
  103ad7:	66 89 9e 7c 0f 00 00 	mov    WORD PTR [esi+0xf7c],bx
  103ade:	66 89 9e 7e 0f 00 00 	mov    WORD PTR [esi+0xf7e],bx
  103ae5:	66 89 9e 80 0f 00 00 	mov    WORD PTR [esi+0xf80],bx
  103aec:	66 89 9e 82 0f 00 00 	mov    WORD PTR [esi+0xf82],bx
  103af3:	66 89 9e 84 0f 00 00 	mov    WORD PTR [esi+0xf84],bx
  103afa:	66 89 9e 86 0f 00 00 	mov    WORD PTR [esi+0xf86],bx
  103b01:	66 89 9e 88 0f 00 00 	mov    WORD PTR [esi+0xf88],bx
  103b08:	66 89 9e 8a 0f 00 00 	mov    WORD PTR [esi+0xf8a],bx
  103b0f:	66 89 9e 8c 0f 00 00 	mov    WORD PTR [esi+0xf8c],bx
  103b16:	66 89 9e 8e 0f 00 00 	mov    WORD PTR [esi+0xf8e],bx
  103b1d:	66 89 9e 90 0f 00 00 	mov    WORD PTR [esi+0xf90],bx
  103b24:	66 89 9e 92 0f 00 00 	mov    WORD PTR [esi+0xf92],bx
  103b2b:	66 89 9e 94 0f 00 00 	mov    WORD PTR [esi+0xf94],bx
  103b32:	66 89 9e 96 0f 00 00 	mov    WORD PTR [esi+0xf96],bx
  103b39:	66 89 9e 98 0f 00 00 	mov    WORD PTR [esi+0xf98],bx
  103b40:	66 89 9e 9a 0f 00 00 	mov    WORD PTR [esi+0xf9a],bx
  103b47:	66 89 9e 9c 0f 00 00 	mov    WORD PTR [esi+0xf9c],bx
  103b4e:	66 89 9e 9e 0f 00 00 	mov    WORD PTR [esi+0xf9e],bx
  103b55:	e9 66 fd ff ff       	jmp    1038c0 <term::$_2::increment_cursor(int&, int&, int, int, int)+0x90>
    }
  103b5a:	83 c4 08             	add    esp,0x8
  103b5d:	5e                   	pop    esi
  103b5e:	5f                   	pop    edi
  103b5f:	5b                   	pop    ebx
  103b60:	5d                   	pop    ebp
  103b61:	c3                   	ret    
  103b62:	cc                   	int3   
  103b63:	cc                   	int3   
  103b64:	cc                   	int3   
  103b65:	cc                   	int3   
  103b66:	cc                   	int3   
  103b67:	cc                   	int3   
  103b68:	cc                   	int3   
  103b69:	cc                   	int3   
  103b6a:	cc                   	int3   
  103b6b:	cc                   	int3   
  103b6c:	cc                   	int3   
  103b6d:	cc                   	int3   
  103b6e:	cc                   	int3   
  103b6f:	cc                   	int3   

00103b70 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)>:

template <class... S> void write(S... p) {
  103b70:	55                   	push   ebp
  103b71:	89 e5                	mov    ebp,esp
  103b73:	53                   	push   ebx
  103b74:	57                   	push   edi
  103b75:	56                   	push   esi
  103b76:	83 ec 1c             	sub    esp,0x1c
  103b79:	8b 45 18             	mov    eax,DWORD PTR [ebp+0x18]
  103b7c:	8b 4d 14             	mov    ecx,DWORD PTR [ebp+0x14]
  103b7f:	8b 5d 10             	mov    ebx,DWORD PTR [ebp+0x10]
  103b82:	8b 75 0c             	mov    esi,DWORD PTR [ebp+0xc]
  103b85:	8b 7d 08             	mov    edi,DWORD PTR [ebp+0x8]
    for (auto &a : {p...}) {
  103b88:	89 7d d8             	mov    DWORD PTR [ebp-0x28],edi
  103b8b:	89 75 dc             	mov    DWORD PTR [ebp-0x24],esi
  103b8e:	89 5d e0             	mov    DWORD PTR [ebp-0x20],ebx
  103b91:	89 4d e4             	mov    DWORD PTR [ebp-0x1c],ecx
  103b94:	89 45 e8             	mov    DWORD PTR [ebp-0x18],eax
  103b97:	8b 45 1c             	mov    eax,DWORD PTR [ebp+0x1c]
  103b9a:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
  103b9d:	8b 45 20             	mov    eax,DWORD PTR [ebp+0x20]
  103ba0:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
    for (int a = 0; s[a] != 0; a++) {
  103ba3:	8a 07                	mov    al,BYTE PTR [edi]
  103ba5:	84 c0                	test   al,al
  103ba7:	74 1b                	je     103bc4 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x54>
  103ba9:	47                   	inc    edi
  103baa:	90                   	nop
  103bab:	90                   	nop
  103bac:	90                   	nop
  103bad:	90                   	nop
  103bae:	90                   	nop
  103baf:	90                   	nop
        write(s[a]);
  103bb0:	0f be c0             	movsx  eax,al
  103bb3:	50                   	push   eax
  103bb4:	e8 b7 d5 ff ff       	call   101170 <term::write(char)>
  103bb9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103bbc:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  103bbf:	47                   	inc    edi
  103bc0:	84 c0                	test   al,al
  103bc2:	75 ec                	jne    103bb0 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x40>
  103bc4:	8a 06                	mov    al,BYTE PTR [esi]
  103bc6:	84 c0                	test   al,al
  103bc8:	74 1a                	je     103be4 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x74>
  103bca:	46                   	inc    esi
  103bcb:	90                   	nop
  103bcc:	90                   	nop
  103bcd:	90                   	nop
  103bce:	90                   	nop
  103bcf:	90                   	nop
        write(s[a]);
  103bd0:	0f be c0             	movsx  eax,al
  103bd3:	50                   	push   eax
  103bd4:	e8 97 d5 ff ff       	call   101170 <term::write(char)>
  103bd9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103bdc:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  103bdf:	46                   	inc    esi
  103be0:	84 c0                	test   al,al
  103be2:	75 ec                	jne    103bd0 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x60>
  103be4:	8a 03                	mov    al,BYTE PTR [ebx]
  103be6:	84 c0                	test   al,al
  103be8:	8b 7d 14             	mov    edi,DWORD PTR [ebp+0x14]
  103beb:	74 17                	je     103c04 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x94>
  103bed:	43                   	inc    ebx
  103bee:	90                   	nop
  103bef:	90                   	nop
        write(s[a]);
  103bf0:	0f be c0             	movsx  eax,al
  103bf3:	50                   	push   eax
  103bf4:	e8 77 d5 ff ff       	call   101170 <term::write(char)>
  103bf9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103bfc:	0f b6 03             	movzx  eax,BYTE PTR [ebx]
  103bff:	43                   	inc    ebx
  103c00:	84 c0                	test   al,al
  103c02:	75 ec                	jne    103bf0 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x80>
  103c04:	8a 07                	mov    al,BYTE PTR [edi]
  103c06:	84 c0                	test   al,al
  103c08:	8b 75 18             	mov    esi,DWORD PTR [ebp+0x18]
  103c0b:	74 17                	je     103c24 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xb4>
  103c0d:	47                   	inc    edi
  103c0e:	90                   	nop
  103c0f:	90                   	nop
        write(s[a]);
  103c10:	0f be c0             	movsx  eax,al
  103c13:	50                   	push   eax
  103c14:	e8 57 d5 ff ff       	call   101170 <term::write(char)>
  103c19:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103c1c:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  103c1f:	47                   	inc    edi
  103c20:	84 c0                	test   al,al
  103c22:	75 ec                	jne    103c10 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xa0>
  103c24:	8a 06                	mov    al,BYTE PTR [esi]
  103c26:	84 c0                	test   al,al
  103c28:	74 1a                	je     103c44 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xd4>
  103c2a:	46                   	inc    esi
  103c2b:	90                   	nop
  103c2c:	90                   	nop
  103c2d:	90                   	nop
  103c2e:	90                   	nop
  103c2f:	90                   	nop
        write(s[a]);
  103c30:	0f be c0             	movsx  eax,al
  103c33:	50                   	push   eax
  103c34:	e8 37 d5 ff ff       	call   101170 <term::write(char)>
  103c39:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103c3c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  103c3f:	46                   	inc    esi
  103c40:	84 c0                	test   al,al
  103c42:	75 ec                	jne    103c30 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xc0>
        write(a);
  103c44:	8b 75 ec             	mov    esi,DWORD PTR [ebp-0x14]
    for (int a = 0; s[a] != 0; a++) {
  103c47:	8a 06                	mov    al,BYTE PTR [esi]
  103c49:	84 c0                	test   al,al
  103c4b:	74 17                	je     103c64 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xf4>
  103c4d:	46                   	inc    esi
  103c4e:	90                   	nop
  103c4f:	90                   	nop
        write(s[a]);
  103c50:	0f be c0             	movsx  eax,al
  103c53:	50                   	push   eax
  103c54:	e8 17 d5 ff ff       	call   101170 <term::write(char)>
  103c59:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103c5c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  103c5f:	46                   	inc    esi
  103c60:	84 c0                	test   al,al
  103c62:	75 ec                	jne    103c50 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xe0>
        write(a);
  103c64:	8b 75 f0             	mov    esi,DWORD PTR [ebp-0x10]
    for (int a = 0; s[a] != 0; a++) {
  103c67:	8a 06                	mov    al,BYTE PTR [esi]
  103c69:	84 c0                	test   al,al
  103c6b:	74 17                	je     103c84 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x114>
  103c6d:	46                   	inc    esi
  103c6e:	90                   	nop
  103c6f:	90                   	nop
        write(s[a]);
  103c70:	0f be c0             	movsx  eax,al
  103c73:	50                   	push   eax
  103c74:	e8 f7 d4 ff ff       	call   101170 <term::write(char)>
  103c79:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103c7c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  103c7f:	46                   	inc    esi
  103c80:	84 c0                	test   al,al
  103c82:	75 ec                	jne    103c70 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x100>
    }
}
  103c84:	83 c4 1c             	add    esp,0x1c
  103c87:	5e                   	pop    esi
  103c88:	5f                   	pop    edi
  103c89:	5b                   	pop    ebx
  103c8a:	5d                   	pop    ebp
  103c8b:	c3                   	ret    
  103c8c:	cc                   	int3   
  103c8d:	cc                   	int3   
  103c8e:	cc                   	int3   
  103c8f:	cc                   	int3   

00103c90 <void term::fatal_error<char const*>(char const*)>:

template <class... S>[[noreturn]] void fatal_error(S... msg) {
  103c90:	55                   	push   ebp
  103c91:	89 e5                	mov    ebp,esp
  103c93:	56                   	push   esi
  103c94:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
    for (int a = 0; s[a] != 0; a++) {
  103c97:	8a 06                	mov    al,BYTE PTR [esi]
  103c99:	84 c0                	test   al,al
  103c9b:	74 17                	je     103cb4 <void term::fatal_error<char const*>(char const*)+0x24>
  103c9d:	46                   	inc    esi
  103c9e:	90                   	nop
  103c9f:	90                   	nop
        write(s[a]);
  103ca0:	0f be c0             	movsx  eax,al
  103ca3:	50                   	push   eax
  103ca4:	e8 c7 d4 ff ff       	call   101170 <term::write(char)>
  103ca9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103cac:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  103caf:	46                   	inc    esi
  103cb0:	84 c0                	test   al,al
  103cb2:	75 ec                	jne    103ca0 <void term::fatal_error<char const*>(char const*)+0x10>
    asm("hlt");
  103cb4:	f4                   	hlt    
  103cb5:	90                   	nop
  103cb6:	90                   	nop
  103cb7:	90                   	nop
  103cb8:	90                   	nop
  103cb9:	90                   	nop
  103cba:	90                   	nop
  103cbb:	90                   	nop
  103cbc:	90                   	nop
  103cbd:	90                   	nop
  103cbe:	90                   	nop
  103cbf:	90                   	nop
    while (true)
  103cc0:	eb fe                	jmp    103cc0 <void term::fatal_error<char const*>(char const*)+0x30>
  103cc2:	cc                   	int3   
  103cc3:	cc                   	int3   
  103cc4:	cc                   	int3   
  103cc5:	cc                   	int3   
  103cc6:	cc                   	int3   
  103cc7:	cc                   	int3   
  103cc8:	cc                   	int3   
  103cc9:	cc                   	int3   
  103cca:	cc                   	int3   
  103ccb:	cc                   	int3   
  103ccc:	cc                   	int3   
  103ccd:	cc                   	int3   
  103cce:	cc                   	int3   
  103ccf:	cc                   	int3   

00103cd0 <game_of_life::game_of_life()>:
    game_of_life() {
  103cd0:	55                   	push   ebp
  103cd1:	89 e5                	mov    ebp,esp
  103cd3:	53                   	push   ebx
  103cd4:	57                   	push   edi
  103cd5:	56                   	push   esi
  103cd6:	83 e4 f8             	and    esp,0xfffffff8
  103cd9:	81 ec e0 09 00 00    	sub    esp,0x9e0
    constexpr array(U &&... p) : data_{static_cast<T>(p)...} {}
  103cdf:	68 00 02 00 00       	push   0x200
  103ce4:	6a 00                	push   0x0
  103ce6:	ff 75 08             	push   DWORD PTR [ebp+0x8]
  103ce9:	e8 22 d3 ff ff       	call   101010 <memset>
  103cee:	83 c4 0c             	add    esp,0xc
    int index_ = 0;
  103cf1:	8d 44 24 18          	lea    eax,[esp+0x18]
  103cf5:	68 c0 09 00 00       	push   0x9c0
  103cfa:	6a 00                	push   0x0
  103cfc:	50                   	push   eax
  103cfd:	e8 0e d3 ff ff       	call   101010 <memset>
  103d02:	83 c4 0c             	add    esp,0xc
        mt[0] = seed & static_cast<uint32>(~0);
  103d05:	c7 44 24 10 71 15 00 	mov    DWORD PTR [esp+0x10],0x1571
  103d0c:	00 
            mt[mti] =
  103d0d:	c7 44 24 14 96 ee 98 	mov    DWORD PTR [esp+0x14],0x4d98ee96
  103d14:	4d 
  103d15:	c7 44 24 18 95 f0 25 	mov    DWORD PTR [esp+0x18],0xaf25f095
  103d1c:	af 
  103d1d:	c7 84 24 d8 09 00 00 	mov    DWORD PTR [esp+0x9d8],0x3
  103d24:	03 00 00 00 
  103d28:	b9 02 00 00 00       	mov    ecx,0x2
  103d2d:	b8 03 00 00 00       	mov    eax,0x3
  103d32:	90                   	nop
  103d33:	90                   	nop
  103d34:	90                   	nop
  103d35:	90                   	nop
  103d36:	90                   	nop
  103d37:	90                   	nop
  103d38:	90                   	nop
  103d39:	90                   	nop
  103d3a:	90                   	nop
  103d3b:	90                   	nop
  103d3c:	90                   	nop
  103d3d:	90                   	nop
  103d3e:	90                   	nop
  103d3f:	90                   	nop
                (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
  103d40:	8b 4c 8c 10          	mov    ecx,DWORD PTR [esp+ecx*4+0x10]
  103d44:	89 ca                	mov    edx,ecx
  103d46:	c1 ea 1e             	shr    edx,0x1e
  103d49:	31 ca                	xor    edx,ecx
  103d4b:	69 ca 65 89 07 6c    	imul   ecx,edx,0x6c078965
  103d51:	01 c1                	add    ecx,eax
            mt[mti] =
  103d53:	89 4c 84 10          	mov    DWORD PTR [esp+eax*4+0x10],ecx
            mt[mti] &= static_cast<uint32>(~0);
  103d57:	8b 8c 24 d8 09 00 00 	mov    ecx,DWORD PTR [esp+0x9d8]
        for (mti = 1; mti < N; mti++) {
  103d5e:	8d 41 01             	lea    eax,[ecx+0x1]
  103d61:	89 84 24 d8 09 00 00 	mov    DWORD PTR [esp+0x9d8],eax
  103d68:	3d 70 02 00 00       	cmp    eax,0x270
  103d6d:	72 d1                	jb     103d40 <game_of_life::game_of_life()+0x70>
  103d6f:	bb 64 00 00 00       	mov    ebx,0x64
  103d74:	8d 7c 24 10          	lea    edi,[esp+0x10]
  103d78:	90                   	nop
  103d79:	90                   	nop
  103d7a:	90                   	nop
  103d7b:	90                   	nop
  103d7c:	90                   	nop
  103d7d:	90                   	nop
  103d7e:	90                   	nop
  103d7f:	90                   	nop
                auto x=rnd.next()%width;
  103d80:	6a 00                	push   0x0
  103d82:	57                   	push   edi
  103d83:	e8 88 00 00 00       	call   103e10 <rand::random_gen::next(unsigned int)>
  103d88:	83 c4 08             	add    esp,0x8
  103d8b:	89 c6                	mov    esi,eax
  103d8d:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  103d92:	f7 e1                	mul    ecx
  103d94:	c1 ea 02             	shr    edx,0x2
  103d97:	83 e2 f0             	and    edx,0xfffffff0
  103d9a:	8d 04 92             	lea    eax,[edx+edx*4]
  103d9d:	29 c6                	sub    esi,eax
                auto y=rnd.next()%height;
  103d9f:	6a 00                	push   0x0
  103da1:	57                   	push   edi
  103da2:	e8 69 00 00 00       	call   103e10 <rand::random_gen::next(unsigned int)>
  103da7:	83 c4 08             	add    esp,0x8
  103daa:	89 c1                	mov    ecx,eax
  103dac:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  103db1:	f7 e2                	mul    edx
  103db3:	c1 ea 03             	shr    edx,0x3
  103db6:	8d 04 92             	lea    eax,[edx+edx*4]
  103db9:	8d 04 80             	lea    eax,[eax+eax*4]
  103dbc:	29 c1                	sub    ecx,eax
                board_[width * y + x]=1;
  103dbe:	8d 04 89             	lea    eax,[ecx+ecx*4]
  103dc1:	c1 e0 04             	shl    eax,0x4
  103dc4:	01 f0                	add    eax,esi
        return bit_member(*this, static_cast<int>(i));
  103dc6:	50                   	push   eax
  103dc7:	ff 75 08             	push   DWORD PTR [ebp+0x8]
  103dca:	8d 44 24 08          	lea    eax,[esp+0x8]
  103dce:	50                   	push   eax
  103dcf:	e8 7c 01 00 00       	call   103f50 <bit_sequence<2000>::bit_member::bit_member(bit_sequence<2000>&, int)>
  103dd4:	83 c4 0c             	add    esp,0xc
            b_.bytes_[pos_ / 8] &= (p << (pos_ % 8));
  103dd7:	8b 34 24             	mov    esi,DWORD PTR [esp]
  103dda:	8b 44 24 04          	mov    eax,DWORD PTR [esp+0x4]
  103dde:	89 c1                	mov    ecx,eax
  103de0:	80 e1 07             	and    cl,0x7
  103de3:	ba 01 00 00 00       	mov    edx,0x1
  103de8:	d3 e2                	shl    edx,cl
  103dea:	8d 48 07             	lea    ecx,[eax+0x7]
  103ded:	85 c0                	test   eax,eax
  103def:	0f 49 c8             	cmovns ecx,eax
  103df2:	c1 f9 03             	sar    ecx,0x3
  103df5:	20 14 0e             	and    BYTE PTR [esi+ecx*1],dl
            for(int a=0; a<100; a++) {
  103df8:	4b                   	dec    ebx
  103df9:	75 85                	jne    103d80 <game_of_life::game_of_life()+0xb0>
    }
  103dfb:	8d 65 f4             	lea    esp,[ebp-0xc]
  103dfe:	5e                   	pop    esi
  103dff:	5f                   	pop    edi
  103e00:	5b                   	pop    ebx
  103e01:	5d                   	pop    ebp
  103e02:	c3                   	ret    
  103e03:	cc                   	int3   
  103e04:	cc                   	int3   
  103e05:	cc                   	int3   
  103e06:	cc                   	int3   
  103e07:	cc                   	int3   
  103e08:	cc                   	int3   
  103e09:	cc                   	int3   
  103e0a:	cc                   	int3   
  103e0b:	cc                   	int3   
  103e0c:	cc                   	int3   
  103e0d:	cc                   	int3   
  103e0e:	cc                   	int3   
  103e0f:	cc                   	int3   

00103e10 <rand::random_gen::next(unsigned int)>:
        }
    }

    uint32 next(uint32 limit = 0) {
  103e10:	55                   	push   ebp
  103e11:	89 e5                	mov    ebp,esp
  103e13:	53                   	push   ebx
  103e14:	57                   	push   edi
  103e15:	56                   	push   esi
  103e16:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
  103e19:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
        uint32 y = 0;

        if (mti >= N) { /* generate N words at one time */
  103e1c:	8b 90 c8 09 00 00    	mov    edx,DWORD PTR [eax+0x9c8]
  103e22:	81 fa 70 02 00 00    	cmp    edx,0x270
  103e28:	0f 82 d7 00 00 00    	jb     103f05 <rand::random_gen::next(unsigned int)+0xf5>
            uint32 kk = 0;

            for (; kk < N - M; kk++) {
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  103e2e:	8b 30                	mov    esi,DWORD PTR [eax]
  103e30:	ba 1d ff ff ff       	mov    edx,0xffffff1d
  103e35:	90                   	nop
  103e36:	90                   	nop
  103e37:	90                   	nop
  103e38:	90                   	nop
  103e39:	90                   	nop
  103e3a:	90                   	nop
  103e3b:	90                   	nop
  103e3c:	90                   	nop
  103e3d:	90                   	nop
  103e3e:	90                   	nop
  103e3f:	90                   	nop
  103e40:	81 e6 00 00 00 80    	and    esi,0x80000000
  103e46:	8b bc 90 90 03 00 00 	mov    edi,DWORD PTR [eax+edx*4+0x390]
  103e4d:	89 fb                	mov    ebx,edi
  103e4f:	81 e3 fe ff ff 7f    	and    ebx,0x7ffffffe
  103e55:	09 f3                	or     ebx,esi
                mt[kk] = mt[kk + M] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  103e57:	d1 eb                	shr    ebx,1
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  103e59:	89 fe                	mov    esi,edi
                mt[kk] = mt[kk + M] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  103e5b:	83 e7 01             	and    edi,0x1
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  103e5e:	8b 3c bd 84 00 10 00 	mov    edi,DWORD PTR [edi*4+0x100084]
  103e65:	33 bc 90 c0 09 00 00 	xor    edi,DWORD PTR [eax+edx*4+0x9c0]
  103e6c:	31 df                	xor    edi,ebx
  103e6e:	89 bc 90 8c 03 00 00 	mov    DWORD PTR [eax+edx*4+0x38c],edi
            for (; kk < N - M; kk++) {
  103e75:	42                   	inc    edx
  103e76:	75 c8                	jne    103e40 <rand::random_gen::next(unsigned int)+0x30>
            }
            for (; kk < N - 1; kk++) {
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  103e78:	8b b0 8c 03 00 00    	mov    esi,DWORD PTR [eax+0x38c]
  103e7e:	ba 74 fe ff ff       	mov    edx,0xfffffe74
  103e83:	90                   	nop
  103e84:	90                   	nop
  103e85:	90                   	nop
  103e86:	90                   	nop
  103e87:	90                   	nop
  103e88:	90                   	nop
  103e89:	90                   	nop
  103e8a:	90                   	nop
  103e8b:	90                   	nop
  103e8c:	90                   	nop
  103e8d:	90                   	nop
  103e8e:	90                   	nop
  103e8f:	90                   	nop
  103e90:	81 e6 00 00 00 80    	and    esi,0x80000000
  103e96:	8b bc 90 c0 09 00 00 	mov    edi,DWORD PTR [eax+edx*4+0x9c0]
  103e9d:	89 fb                	mov    ebx,edi
  103e9f:	81 e3 fe ff ff 7f    	and    ebx,0x7ffffffe
  103ea5:	09 f3                	or     ebx,esi
                mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  103ea7:	d1 eb                	shr    ebx,1
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  103ea9:	89 fe                	mov    esi,edi
                mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  103eab:	83 e7 01             	and    edi,0x1
  103eae:	8b 3c bd 84 00 10 00 	mov    edi,DWORD PTR [edi*4+0x100084]
  103eb5:	33 bc 90 30 06 00 00 	xor    edi,DWORD PTR [eax+edx*4+0x630]
  103ebc:	31 df                	xor    edi,ebx
  103ebe:	89 bc 90 bc 09 00 00 	mov    DWORD PTR [eax+edx*4+0x9bc],edi
            for (; kk < N - 1; kk++) {
  103ec5:	42                   	inc    edx
  103ec6:	75 c8                	jne    103e90 <rand::random_gen::next(unsigned int)+0x80>
  103ec8:	ba 00 00 00 80       	mov    edx,0x80000000
            }
            y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);
  103ecd:	23 90 bc 09 00 00    	and    edx,DWORD PTR [eax+0x9bc]
  103ed3:	8b 30                	mov    esi,DWORD PTR [eax]
  103ed5:	89 f7                	mov    edi,esi
  103ed7:	81 e7 fe ff ff 7f    	and    edi,0x7ffffffe
  103edd:	09 d7                	or     edi,edx
            mt[N - 1] = mt[M - 1] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  103edf:	d1 ef                	shr    edi,1
  103ee1:	83 e6 01             	and    esi,0x1
  103ee4:	8b 14 b5 84 00 10 00 	mov    edx,DWORD PTR [esi*4+0x100084]
  103eeb:	33 90 30 06 00 00    	xor    edx,DWORD PTR [eax+0x630]
  103ef1:	31 fa                	xor    edx,edi
  103ef3:	89 90 bc 09 00 00    	mov    DWORD PTR [eax+0x9bc],edx

            mti = 0;
  103ef9:	c7 80 c8 09 00 00 00 	mov    DWORD PTR [eax+0x9c8],0x0
  103f00:	00 00 00 
  103f03:	31 d2                	xor    edx,edx
        }

        y = mt[mti++];
  103f05:	8d 72 01             	lea    esi,[edx+0x1]
  103f08:	89 b0 c8 09 00 00    	mov    DWORD PTR [eax+0x9c8],esi
  103f0e:	8b 04 90             	mov    eax,DWORD PTR [eax+edx*4]

        /* Tempering */
        y ^= (y >> 11);
  103f11:	89 c2                	mov    edx,eax
  103f13:	c1 ea 0b             	shr    edx,0xb
  103f16:	31 c2                	xor    edx,eax
        y ^= (y << 7) & 0x9d2c5680UL;
  103f18:	89 d0                	mov    eax,edx
  103f1a:	c1 e0 07             	shl    eax,0x7
  103f1d:	25 80 56 2c 9d       	and    eax,0x9d2c5680
  103f22:	31 d0                	xor    eax,edx
        y ^= (y << 15) & 0xefc60000UL;
  103f24:	89 c2                	mov    edx,eax
  103f26:	c1 e2 0f             	shl    edx,0xf
  103f29:	81 e2 00 00 c6 ef    	and    edx,0xefc60000
  103f2f:	31 c2                	xor    edx,eax
        y ^= (y >> 18);
  103f31:	89 d0                	mov    eax,edx
  103f33:	c1 e8 12             	shr    eax,0x12
  103f36:	31 d0                	xor    eax,edx

        if (limit == 0)
  103f38:	85 c9                	test   ecx,ecx
  103f3a:	74 06                	je     103f42 <rand::random_gen::next(unsigned int)+0x132>
            return y;
        else
            return y % limit;
  103f3c:	31 d2                	xor    edx,edx
  103f3e:	f7 f1                	div    ecx
  103f40:	89 d0                	mov    eax,edx
    }
  103f42:	5e                   	pop    esi
  103f43:	5f                   	pop    edi
  103f44:	5b                   	pop    ebx
  103f45:	5d                   	pop    ebp
  103f46:	c3                   	ret    
  103f47:	cc                   	int3   
  103f48:	cc                   	int3   
  103f49:	cc                   	int3   
  103f4a:	cc                   	int3   
  103f4b:	cc                   	int3   
  103f4c:	cc                   	int3   
  103f4d:	cc                   	int3   
  103f4e:	cc                   	int3   
  103f4f:	cc                   	int3   

00103f50 <bit_sequence<2000>::bit_member::bit_member(bit_sequence<2000>&, int)>:
            : b_(b), pos_(pos), val_(b[pos]) {}
  103f50:	55                   	push   ebp
  103f51:	89 e5                	mov    ebp,esp
  103f53:	56                   	push   esi
  103f54:	83 e4 f8             	and    esp,0xfffffff8
  103f57:	83 ec 10             	sub    esp,0x10
  103f5a:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
  103f5d:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
  103f60:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  103f63:	89 0e                	mov    DWORD PTR [esi],ecx
  103f65:	89 46 04             	mov    DWORD PTR [esi+0x4],eax
  103f68:	89 e2                	mov    edx,esp
        return bit_member(*this, static_cast<int>(i));
  103f6a:	50                   	push   eax
  103f6b:	51                   	push   ecx
  103f6c:	52                   	push   edx
  103f6d:	e8 de ff ff ff       	call   103f50 <bit_sequence<2000>::bit_member::bit_member(bit_sequence<2000>&, int)>
  103f72:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  103f75:	8a 44 24 08          	mov    al,BYTE PTR [esp+0x8]
            : b_(b), pos_(pos), val_(b[pos]) {}
  103f79:	88 46 08             	mov    BYTE PTR [esi+0x8],al
  103f7c:	8d 65 fc             	lea    esp,[ebp-0x4]
  103f7f:	5e                   	pop    esi
  103f80:	5d                   	pop    ebp
  103f81:	c3                   	ret    
  103f82:	cc                   	int3   
  103f83:	cc                   	int3   
  103f84:	cc                   	int3   
  103f85:	cc                   	int3   
  103f86:	cc                   	int3   
  103f87:	cc                   	int3   
  103f88:	cc                   	int3   
  103f89:	cc                   	int3   
  103f8a:	cc                   	int3   
  103f8b:	cc                   	int3   
  103f8c:	cc                   	int3   
  103f8d:	cc                   	int3   
  103f8e:	cc                   	int3   
  103f8f:	cc                   	int3   

00103f90 <game_of_life::step()>:
    void step() {
  103f90:	55                   	push   ebp
  103f91:	89 e5                	mov    ebp,esp
  103f93:	53                   	push   ebx
  103f94:	57                   	push   edi
  103f95:	56                   	push   esi
  103f96:	83 e4 f8             	and    esp,0xfffffff8
  103f99:	83 ec 38             	sub    esp,0x38
  103f9c:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
        term::clear();
  103f9f:	e8 dc d0 ff ff       	call   101080 <term::clear()>
  103fa4:	81 c6 00 01 00 00    	add    esi,0x100
  103faa:	31 db                	xor    ebx,ebx
  103fac:	89 34 24             	mov    DWORD PTR [esp],esi
  103faf:	eb 1d                	jmp    103fce <game_of_life::step()+0x3e>
  103fb1:	90                   	nop
  103fb2:	90                   	nop
  103fb3:	90                   	nop
  103fb4:	90                   	nop
  103fb5:	90                   	nop
  103fb6:	90                   	nop
  103fb7:	90                   	nop
  103fb8:	90                   	nop
  103fb9:	90                   	nop
  103fba:	90                   	nop
  103fbb:	90                   	nop
  103fbc:	90                   	nop
  103fbd:	90                   	nop
  103fbe:	90                   	nop
  103fbf:	90                   	nop
  103fc0:	8b 5c 24 04          	mov    ebx,DWORD PTR [esp+0x4]
        for (int x = 0; x < width; x++) {
  103fc4:	43                   	inc    ebx
  103fc5:	83 fb 50             	cmp    ebx,0x50
  103fc8:	0f 84 b2 00 00 00    	je     104080 <game_of_life::step()+0xf0>
  103fce:	89 5c 24 04          	mov    DWORD PTR [esp+0x4],ebx
  103fd2:	31 ff                	xor    edi,edi
  103fd4:	eb 5e                	jmp    104034 <game_of_life::step()+0xa4>
  103fd6:	90                   	nop
  103fd7:	90                   	nop
  103fd8:	90                   	nop
  103fd9:	90                   	nop
  103fda:	90                   	nop
  103fdb:	90                   	nop
  103fdc:	90                   	nop
  103fdd:	90                   	nop
  103fde:	90                   	nop
  103fdf:	90                   	nop
        return bit_member(*this, static_cast<int>(i));
  103fe0:	53                   	push   ebx
  103fe1:	56                   	push   esi
  103fe2:	8d 44 24 20          	lea    eax,[esp+0x20]
  103fe6:	50                   	push   eax
  103fe7:	e8 64 ff ff ff       	call   103f50 <bit_sequence<2000>::bit_member::bit_member(bit_sequence<2000>&, int)>
  103fec:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  103fef:	0f b6 74 24 20       	movzx  esi,BYTE PTR [esp+0x20]
        return bit_member(*this, static_cast<int>(i));
  103ff4:	53                   	push   ebx
  103ff5:	ff 74 24 04          	push   DWORD PTR [esp+0x4]
  103ff9:	8d 44 24 10          	lea    eax,[esp+0x10]
  103ffd:	50                   	push   eax
  103ffe:	e8 4d ff ff ff       	call   103f50 <bit_sequence<2000>::bit_member::bit_member(bit_sequence<2000>&, int)>
  104003:	83 c4 0c             	add    esp,0xc
  104006:	89 f0                	mov    eax,esi
            b_.bytes_[pos_ / 8] &= (p << (pos_ % 8));
  104008:	83 f0 01             	xor    eax,0x1
  10400b:	8b 74 24 08          	mov    esi,DWORD PTR [esp+0x8]
  10400f:	8b 54 24 0c          	mov    edx,DWORD PTR [esp+0xc]
  104013:	89 d1                	mov    ecx,edx
  104015:	80 e1 07             	and    cl,0x7
  104018:	d3 e0                	shl    eax,cl
  10401a:	8d 4a 07             	lea    ecx,[edx+0x7]
  10401d:	85 d2                	test   edx,edx
  10401f:	0f 49 ca             	cmovns ecx,edx
  104022:	c1 f9 03             	sar    ecx,0x3
  104025:	20 04 0e             	and    BYTE PTR [esi+ecx*1],al
  104028:	8b 34 24             	mov    esi,DWORD PTR [esp]
            for (int y = 0; y < height; y++) {
  10402b:	47                   	inc    edi
  10402c:	83 c3 50             	add    ebx,0x50
  10402f:	83 ff 19             	cmp    edi,0x19
  104032:	74 8c                	je     103fc0 <game_of_life::step()+0x30>
        return bit_member(*this, static_cast<int>(i));
  104034:	53                   	push   ebx
  104035:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  104038:	50                   	push   eax
  104039:	8d 44 24 30          	lea    eax,[esp+0x30]
  10403d:	50                   	push   eax
  10403e:	e8 0d ff ff ff       	call   103f50 <bit_sequence<2000>::bit_member::bit_member(bit_sequence<2000>&, int)>
  104043:	83 c4 0c             	add    esp,0xc
                int n = neighbours(x, y);
  104046:	57                   	push   edi
  104047:	ff 74 24 08          	push   DWORD PTR [esp+0x8]
  10404b:	ff 75 08             	push   DWORD PTR [ebp+0x8]
  10404e:	e8 9d 00 00 00       	call   1040f0 <game_of_life::neighbours(int, int) const>
  104053:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  104056:	80 7c 24 30 00       	cmp    BYTE PTR [esp+0x30],0x0
  10405b:	0f 94 c1             	sete   cl
                if ((c == 1 && (n < 2 || n > 3)) || (c == 0 && n == 3))
  10405e:	89 c2                	mov    edx,eax
  104060:	83 e2 fe             	and    edx,0xfffffffe
  104063:	83 fa 02             	cmp    edx,0x2
  104066:	0f 94 c2             	sete   dl
  104069:	83 f8 03             	cmp    eax,0x3
  10406c:	0f 94 c0             	sete   al
  10406f:	84 c8                	test   al,cl
  104071:	0f 85 69 ff ff ff    	jne    103fe0 <game_of_life::step()+0x50>
  104077:	08 d1                	or     cl,dl
  104079:	75 b0                	jne    10402b <game_of_life::step()+0x9b>
  10407b:	e9 60 ff ff ff       	jmp    103fe0 <game_of_life::step()+0x50>
  104080:	31 f6                	xor    esi,esi
  104082:	8d 7c 24 08          	lea    edi,[esp+0x8]
  104086:	90                   	nop
  104087:	90                   	nop
  104088:	90                   	nop
  104089:	90                   	nop
  10408a:	90                   	nop
  10408b:	90                   	nop
  10408c:	90                   	nop
  10408d:	90                   	nop
  10408e:	90                   	nop
  10408f:	90                   	nop
        return bit_member(*this, static_cast<int>(i));
  104090:	56                   	push   esi
  104091:	ff 74 24 04          	push   DWORD PTR [esp+0x4]
  104095:	8d 44 24 20          	lea    eax,[esp+0x20]
  104099:	50                   	push   eax
  10409a:	e8 b1 fe ff ff       	call   103f50 <bit_sequence<2000>::bit_member::bit_member(bit_sequence<2000>&, int)>
  10409f:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  1040a2:	0f b6 5c 24 20       	movzx  ebx,BYTE PTR [esp+0x20]
        return bit_member(*this, static_cast<int>(i));
  1040a7:	56                   	push   esi
  1040a8:	ff 75 08             	push   DWORD PTR [ebp+0x8]
  1040ab:	57                   	push   edi
  1040ac:	e8 9f fe ff ff       	call   103f50 <bit_sequence<2000>::bit_member::bit_member(bit_sequence<2000>&, int)>
  1040b1:	83 c4 0c             	add    esp,0xc
            b_.bytes_[pos_ / 8] &= (p << (pos_ % 8));
  1040b4:	8b 54 24 08          	mov    edx,DWORD PTR [esp+0x8]
  1040b8:	8b 44 24 0c          	mov    eax,DWORD PTR [esp+0xc]
  1040bc:	89 c1                	mov    ecx,eax
  1040be:	80 e1 07             	and    cl,0x7
  1040c1:	d3 e3                	shl    ebx,cl
  1040c3:	8d 48 07             	lea    ecx,[eax+0x7]
  1040c6:	85 c0                	test   eax,eax
  1040c8:	0f 49 c8             	cmovns ecx,eax
  1040cb:	c1 f9 03             	sar    ecx,0x3
  1040ce:	20 1c 0a             	and    BYTE PTR [edx+ecx*1],bl
        for (int a = 0; a < board_.size(); a++) {
  1040d1:	46                   	inc    esi
  1040d2:	81 fe d0 07 00 00    	cmp    esi,0x7d0
  1040d8:	75 b6                	jne    104090 <game_of_life::step()+0x100>
    }
  1040da:	8d 65 f4             	lea    esp,[ebp-0xc]
  1040dd:	5e                   	pop    esi
  1040de:	5f                   	pop    edi
  1040df:	5b                   	pop    ebx
  1040e0:	5d                   	pop    ebp
  1040e1:	c3                   	ret    
  1040e2:	cc                   	int3   
  1040e3:	cc                   	int3   
  1040e4:	cc                   	int3   
  1040e5:	cc                   	int3   
  1040e6:	cc                   	int3   
  1040e7:	cc                   	int3   
  1040e8:	cc                   	int3   
  1040e9:	cc                   	int3   
  1040ea:	cc                   	int3   
  1040eb:	cc                   	int3   
  1040ec:	cc                   	int3   
  1040ed:	cc                   	int3   
  1040ee:	cc                   	int3   
  1040ef:	cc                   	int3   

001040f0 <game_of_life::neighbours(int, int) const>:
        // screen.write(width + 1, 1, "Alive: " + str(alive));
        // screen.write(width + 1, 2, "Max alive: " + str(maxAlive));
        // screen.refresh();
    }

    int neighbours(int x, int y) const {
  1040f0:	55                   	push   ebp
  1040f1:	89 e5                	mov    ebp,esp
  1040f3:	53                   	push   ebx
  1040f4:	57                   	push   edi
  1040f5:	56                   	push   esi
  1040f6:	83 ec 08             	sub    esp,0x8
  1040f9:	8b 75 10             	mov    esi,DWORD PTR [ebp+0x10]
  1040fc:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  1040ff:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
        int r = 0;
        if (x > 0) {
  104102:	85 d2                	test   edx,edx
  104104:	0f 8e 83 00 00 00    	jle    10418d <game_of_life::neighbours(int, int) const+0x9d>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  10410a:	89 f0                	mov    eax,esi
  10410c:	c1 e0 04             	shl    eax,0x4
  10410f:	8d 3c 80             	lea    edi,[eax+eax*4]
  104112:	8d 44 3a ff          	lea    eax,[edx+edi*1-0x1]
        auto b = bytes_[i / 8];
  104116:	8d 5c 3a 06          	lea    ebx,[edx+edi*1+0x6]
  10411a:	85 c0                	test   eax,eax
  10411c:	0f 49 d8             	cmovns ebx,eax
  10411f:	c1 fb 03             	sar    ebx,0x3
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  104122:	0f b6 1c 19          	movzx  ebx,BYTE PTR [ecx+ebx*1]
        return (b & (1 << (i % 8))) != 0;
  104126:	24 07                	and    al,0x7
  104128:	0f b6 c8             	movzx  ecx,al
  10412b:	31 c0                	xor    eax,eax
  10412d:	0f a3 cb             	bt     ebx,ecx
  104130:	0f 92 c0             	setb   al
            r += board(x - 1, y);
            if (y > 0)
  104133:	85 f6                	test   esi,esi
  104135:	7e 29                	jle    104160 <game_of_life::neighbours(int, int) const+0x70>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  104137:	8d 5c 3a af          	lea    ebx,[edx+edi*1-0x51]
        auto b = bytes_[i / 8];
  10413b:	8d 4c 3a b6          	lea    ecx,[edx+edi*1-0x4a]
  10413f:	85 db                	test   ebx,ebx
  104141:	0f 49 cb             	cmovns ecx,ebx
  104144:	c1 f9 03             	sar    ecx,0x3
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  104147:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  10414a:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  10414e:	80 e3 07             	and    bl,0x7
  104151:	0f b6 db             	movzx  ebx,bl
  104154:	0f a3 d9             	bt     ecx,ebx
                r += board(x - 1, y - 1);
  104157:	83 d0 00             	adc    eax,0x0
            if (y < height - 1)
  10415a:	83 7d 10 17          	cmp    DWORD PTR [ebp+0x10],0x17
  10415e:	7f 23                	jg     104183 <game_of_life::neighbours(int, int) const+0x93>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  104160:	8d 5c 3a 4f          	lea    ebx,[edx+edi*1+0x4f]
        auto b = bytes_[i / 8];
  104164:	8d 4c 3a 56          	lea    ecx,[edx+edi*1+0x56]
  104168:	85 db                	test   ebx,ebx
  10416a:	0f 49 cb             	cmovns ecx,ebx
  10416d:	c1 f9 03             	sar    ecx,0x3
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  104170:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  104173:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  104177:	80 e3 07             	and    bl,0x7
  10417a:	0f b6 db             	movzx  ebx,bl
  10417d:	0f a3 d9             	bt     ecx,ebx
                r += board(x - 1, y + 1);
  104180:	83 d0 00             	adc    eax,0x0
        }
        if (x < width - 1) {
  104183:	83 fa 4e             	cmp    edx,0x4e
  104186:	7e 0f                	jle    104197 <game_of_life::neighbours(int, int) const+0xa7>
  104188:	e9 a4 00 00 00       	jmp    104231 <game_of_life::neighbours(int, int) const+0x141>
  10418d:	89 f0                	mov    eax,esi
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  10418f:	c1 e0 04             	shl    eax,0x4
  104192:	8d 3c 80             	lea    edi,[eax+eax*4]
  104195:	31 c0                	xor    eax,eax
  104197:	8d 5c 3a 01          	lea    ebx,[edx+edi*1+0x1]
        auto b = bytes_[i / 8];
  10419b:	8d 4c 3a 08          	lea    ecx,[edx+edi*1+0x8]
  10419f:	85 db                	test   ebx,ebx
  1041a1:	0f 49 cb             	cmovns ecx,ebx
  1041a4:	c1 f9 03             	sar    ecx,0x3
  1041a7:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  1041aa:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  1041ae:	80 e3 07             	and    bl,0x7
  1041b1:	0f b6 db             	movzx  ebx,bl
  1041b4:	0f a3 d9             	bt     ecx,ebx
            r += board(x + 1, y);
  1041b7:	83 d0 00             	adc    eax,0x0
  1041ba:	89 d1                	mov    ecx,edx
  1041bc:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
            if (y > 0)
  1041bf:	85 d2                	test   edx,edx
  1041c1:	89 7d ec             	mov    DWORD PTR [ebp-0x14],edi
  1041c4:	7e 3d                	jle    104203 <game_of_life::neighbours(int, int) const+0x113>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  1041c6:	8d 5c 39 b1          	lea    ebx,[ecx+edi*1-0x4f]
  1041ca:	89 c2                	mov    edx,eax
  1041cc:	89 f8                	mov    eax,edi
  1041ce:	89 cf                	mov    edi,ecx
        auto b = bytes_[i / 8];
  1041d0:	8d 4c 01 b8          	lea    ecx,[ecx+eax*1-0x48]
  1041d4:	85 db                	test   ebx,ebx
  1041d6:	0f 49 cb             	cmovns ecx,ebx
  1041d9:	c1 f9 03             	sar    ecx,0x3
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  1041dc:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  1041e0:	80 e3 07             	and    bl,0x7
  1041e3:	0f b6 db             	movzx  ebx,bl
  1041e6:	0f a3 d9             	bt     ecx,ebx
                r += board(x + 1, y - 1);
  1041e9:	83 d2 00             	adc    edx,0x0
  1041ec:	89 55 f0             	mov    DWORD PTR [ebp-0x10],edx
            if (y < height - 1)
  1041ef:	83 7d 10 17          	cmp    DWORD PTR [ebp+0x10],0x17
  1041f3:	7e 13                	jle    104208 <game_of_life::neighbours(int, int) const+0x118>
  1041f5:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  1041f8:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
  1041fb:	8b 7d ec             	mov    edi,DWORD PTR [ebp-0x14]
  1041fe:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
  104201:	eb 40                	jmp    104243 <game_of_life::neighbours(int, int) const+0x153>
  104203:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
  104206:	89 cf                	mov    edi,ecx
  104208:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  10420b:	8d 5c 07 51          	lea    ebx,[edi+eax*1+0x51]
        auto b = bytes_[i / 8];
  10420f:	8d 4c 07 58          	lea    ecx,[edi+eax*1+0x58]
  104213:	85 db                	test   ebx,ebx
  104215:	0f 49 cb             	cmovns ecx,ebx
  104218:	c1 f9 03             	sar    ecx,0x3
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  10421b:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  10421e:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  104222:	80 e3 07             	and    bl,0x7
  104225:	0f b6 fb             	movzx  edi,bl
  104228:	0f a3 f9             	bt     ecx,edi
  10422b:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
                r += board(x + 1, y + 1);
  10422e:	83 d0 00             	adc    eax,0x0
  104231:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
  104234:	89 d1                	mov    ecx,edx
  104236:	c1 e1 04             	shl    ecx,0x4
        }
        if (y > 0) {
  104239:	85 d2                	test   edx,edx
  10423b:	8d 3c 89             	lea    edi,[ecx+ecx*4]
  10423e:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  104241:	7e 28                	jle    10426b <game_of_life::neighbours(int, int) const+0x17b>
  104243:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  104246:	8d 5c 39 b0          	lea    ebx,[ecx+edi*1-0x50]
        auto b = bytes_[i / 8];
  10424a:	8d 4c 39 b7          	lea    ecx,[ecx+edi*1-0x49]
  10424e:	85 db                	test   ebx,ebx
  104250:	0f 49 cb             	cmovns ecx,ebx
  104253:	c1 f9 03             	sar    ecx,0x3
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  104256:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  10425a:	80 e3 07             	and    bl,0x7
  10425d:	0f b6 db             	movzx  ebx,bl
  104260:	0f a3 d9             	bt     ecx,ebx
            r += board(x, y - 1);
  104263:	83 d0 00             	adc    eax,0x0
        }
        if (y < height - 1) {
  104266:	83 fa 17             	cmp    edx,0x17
  104269:	7f 23                	jg     10428e <game_of_life::neighbours(int, int) const+0x19e>
  10426b:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  10426e:	8d 5c 39 50          	lea    ebx,[ecx+edi*1+0x50]
        auto b = bytes_[i / 8];
  104272:	8d 4c 39 57          	lea    ecx,[ecx+edi*1+0x57]
  104276:	85 db                	test   ebx,ebx
  104278:	0f 49 cb             	cmovns ecx,ebx
  10427b:	c1 f9 03             	sar    ecx,0x3
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  10427e:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  104282:	80 e3 07             	and    bl,0x7
  104285:	0f b6 d3             	movzx  edx,bl
  104288:	0f a3 d1             	bt     ecx,edx
            r += board(x, y + 1);
  10428b:	83 d0 00             	adc    eax,0x0
        }
        return r;
  10428e:	83 c4 08             	add    esp,0x8
  104291:	5e                   	pop    esi
  104292:	5f                   	pop    edi
  104293:	5b                   	pop    ebx
  104294:	5d                   	pop    ebp
  104295:	c3                   	ret    
