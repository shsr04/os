
kernel.elf:     file format elf32-i386


Disassembly of section .text:

00101000 <start>:
  101000:	89 25 00 70 11 00    	mov    DWORD PTR ds:0x117000,esp
  101006:	50                   	push   eax
  101007:	53                   	push   ebx
  101008:	e8 d3 0b 00 00       	call   101be0 <kernel_main>
  10100d:	f4                   	hlt    

0010100e <hang>:
  10100e:	eb fe                	jmp    10100e <hang>

00101010 <halt()>:
static_assert(test_string2.extract_word(0).value == "xy" &&
              test_string2.extract_word(1) &&
              test_string2.extract_word(1).value == "z");
} // namespace

[[noreturn]] void halt() {
  101010:	55                   	push   ebp
  101011:	89 e5                	mov    ebp,esp
    asm("hlt");
  101013:	f4                   	hlt    
  101014:	90                   	nop
  101015:	90                   	nop
  101016:	90                   	nop
  101017:	90                   	nop
  101018:	90                   	nop
  101019:	90                   	nop
  10101a:	90                   	nop
  10101b:	90                   	nop
  10101c:	90                   	nop
  10101d:	90                   	nop
  10101e:	90                   	nop
  10101f:	90                   	nop
    while (true)
  101020:	eb fe                	jmp    101020 <halt()+0x10>
  101022:	90                   	nop
  101023:	90                   	nop
  101024:	90                   	nop
  101025:	90                   	nop
  101026:	90                   	nop
  101027:	90                   	nop
  101028:	90                   	nop
  101029:	90                   	nop
  10102a:	90                   	nop
  10102b:	90                   	nop
  10102c:	90                   	nop
  10102d:	90                   	nop
  10102e:	90                   	nop
  10102f:	90                   	nop

00101030 <term::set(int, unsigned char, char)>:

constexpr auto index(int col = Term.col, int row = Term.row) {
    return (COLS * row) + col;
}

void set(int index, uint8 colour, char symbol) {
  101030:	55                   	push   ebp
  101031:	89 e5                	mov    ebp,esp
  101033:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  101036:	0f be 4d 10          	movsx  ecx,BYTE PTR [ebp+0x10]
    VGA_BUF[index] = static_cast<uint16>((colour << 8) | symbol);
  10103a:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  10103d:	c1 e2 08             	shl    edx,0x8
  101040:	09 ca                	or     edx,ecx
  101042:	8b 0d 00 60 10 00    	mov    ecx,DWORD PTR ds:0x106000
  101048:	66 89 14 41          	mov    WORD PTR [ecx+eax*2],dx
}
  10104c:	5d                   	pop    ebp
  10104d:	c3                   	ret    
  10104e:	90                   	nop
  10104f:	90                   	nop

00101050 <term::clear()>:

void clear() {
  101050:	55                   	push   ebp
  101051:	89 e5                	mov    ebp,esp
  101053:	a1 0c 60 10 00       	mov    eax,ds:0x10600c
  101058:	c1 e0 08             	shl    eax,0x8
  10105b:	83 c8 20             	or     eax,0x20
  10105e:	b9 00 0f 00 00       	mov    ecx,0xf00
    for (int a = 0; a < COLS; a++) {
  101063:	03 0d 00 60 10 00    	add    ecx,DWORD PTR ds:0x106000
  101069:	ba b0 ff ff ff       	mov    edx,0xffffffb0
  10106e:	90                   	nop
  10106f:	90                   	nop
    VGA_BUF[index] = static_cast<uint16>((colour << 8) | symbol);
  101070:	66 89 84 51 a0 f1 ff 	mov    WORD PTR [ecx+edx*2-0xe60],ax
  101077:	ff 
  101078:	66 89 84 51 40 f2 ff 	mov    WORD PTR [ecx+edx*2-0xdc0],ax
  10107f:	ff 
  101080:	66 89 84 51 e0 f2 ff 	mov    WORD PTR [ecx+edx*2-0xd20],ax
  101087:	ff 
  101088:	66 89 84 51 80 f3 ff 	mov    WORD PTR [ecx+edx*2-0xc80],ax
  10108f:	ff 
  101090:	66 89 84 51 20 f4 ff 	mov    WORD PTR [ecx+edx*2-0xbe0],ax
  101097:	ff 
  101098:	66 89 84 51 c0 f4 ff 	mov    WORD PTR [ecx+edx*2-0xb40],ax
  10109f:	ff 
  1010a0:	66 89 84 51 60 f5 ff 	mov    WORD PTR [ecx+edx*2-0xaa0],ax
  1010a7:	ff 
  1010a8:	66 89 84 51 00 f6 ff 	mov    WORD PTR [ecx+edx*2-0xa00],ax
  1010af:	ff 
  1010b0:	66 89 84 51 a0 f6 ff 	mov    WORD PTR [ecx+edx*2-0x960],ax
  1010b7:	ff 
  1010b8:	66 89 84 51 40 f7 ff 	mov    WORD PTR [ecx+edx*2-0x8c0],ax
  1010bf:	ff 
  1010c0:	66 89 84 51 e0 f7 ff 	mov    WORD PTR [ecx+edx*2-0x820],ax
  1010c7:	ff 
  1010c8:	66 89 84 51 80 f8 ff 	mov    WORD PTR [ecx+edx*2-0x780],ax
  1010cf:	ff 
  1010d0:	66 89 84 51 20 f9 ff 	mov    WORD PTR [ecx+edx*2-0x6e0],ax
  1010d7:	ff 
  1010d8:	66 89 84 51 c0 f9 ff 	mov    WORD PTR [ecx+edx*2-0x640],ax
  1010df:	ff 
  1010e0:	66 89 84 51 60 fa ff 	mov    WORD PTR [ecx+edx*2-0x5a0],ax
  1010e7:	ff 
  1010e8:	66 89 84 51 00 fb ff 	mov    WORD PTR [ecx+edx*2-0x500],ax
  1010ef:	ff 
  1010f0:	66 89 84 51 a0 fb ff 	mov    WORD PTR [ecx+edx*2-0x460],ax
  1010f7:	ff 
  1010f8:	66 89 84 51 40 fc ff 	mov    WORD PTR [ecx+edx*2-0x3c0],ax
  1010ff:	ff 
  101100:	66 89 84 51 e0 fc ff 	mov    WORD PTR [ecx+edx*2-0x320],ax
  101107:	ff 
  101108:	66 89 84 51 80 fd ff 	mov    WORD PTR [ecx+edx*2-0x280],ax
  10110f:	ff 
  101110:	66 89 84 51 20 fe ff 	mov    WORD PTR [ecx+edx*2-0x1e0],ax
  101117:	ff 
  101118:	66 89 84 51 c0 fe ff 	mov    WORD PTR [ecx+edx*2-0x140],ax
  10111f:	ff 
  101120:	66 89 84 51 60 ff ff 	mov    WORD PTR [ecx+edx*2-0xa0],ax
  101127:	ff 
  101128:	66 89 04 51          	mov    WORD PTR [ecx+edx*2],ax
  10112c:	66 89 84 51 a0 00 00 	mov    WORD PTR [ecx+edx*2+0xa0],ax
  101133:	00 
    for (int a = 0; a < COLS; a++) {
  101134:	42                   	inc    edx
  101135:	0f 85 35 ff ff ff    	jne    101070 <term::clear()+0x20>
        for (int b = 0; b < ROWS; b++) {
            set(index(a, b), Term.colour, ' ');
        }
    }
}
  10113b:	5d                   	pop    ebp
  10113c:	c3                   	ret    
  10113d:	90                   	nop
  10113e:	90                   	nop
  10113f:	90                   	nop

00101140 <term::write(char)>:

void write(char c) {
  101140:	55                   	push   ebp
  101141:	89 e5                	mov    ebp,esp
    switch (c) {
  101143:	0f be 45 08          	movsx  eax,BYTE PTR [ebp+0x8]
  101147:	83 f8 09             	cmp    eax,0x9
  10114a:	74 43                	je     10118f <term::write(char)+0x4f>
  10114c:	83 f8 0a             	cmp    eax,0xa
  10114f:	75 59                	jne    1011aa <term::write(char)+0x6a>
        if (!flipped) {
  101151:	80 3d 0d 60 10 00 00 	cmp    BYTE PTR ds:0x10600d,0x0
  101158:	0f 84 95 00 00 00    	je     1011f3 <term::write(char)+0xb3>
            increment_cursor(row, col, ROWS, COLS, ROWS - (row % ROWS));
  10115e:	8b 0d 08 60 10 00    	mov    ecx,DWORD PTR ds:0x106008
  101164:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  101169:	89 c8                	mov    eax,ecx
  10116b:	f7 ea                	imul   edx
  10116d:	89 d0                	mov    eax,edx
  10116f:	c1 e8 1f             	shr    eax,0x1f
  101172:	c1 fa 03             	sar    edx,0x3
  101175:	01 c2                	add    edx,eax
  101177:	8d 04 92             	lea    eax,[edx+edx*4]
  10117a:	8d 04 80             	lea    eax,[eax+eax*4]
  10117d:	29 c8                	sub    eax,ecx
  10117f:	83 c0 19             	add    eax,0x19
  101182:	b9 08 60 10 00       	mov    ecx,0x106008
  101187:	ba 04 60 10 00       	mov    edx,0x106004
  10118c:	50                   	push   eax
  10118d:	eb 56                	jmp    1011e5 <term::write(char)+0xa5>
        if (!flipped) {
  10118f:	80 3d 0d 60 10 00 00 	cmp    BYTE PTR ds:0x10600d,0x0
  101196:	0f 84 88 00 00 00    	je     101224 <term::write(char)+0xe4>
            increment_cursor(row, col, ROWS, COLS, n);
  10119c:	b9 08 60 10 00       	mov    ecx,0x106008
  1011a1:	ba 04 60 10 00       	mov    edx,0x106004
  1011a6:	6a 04                	push   0x4
  1011a8:	eb 3b                	jmp    1011e5 <term::write(char)+0xa5>
        break;
    case '\t':
        Term.advance(4);
        break;
    default:
        set(index(), Term.colour, c);
  1011aa:	8b 0d 08 60 10 00    	mov    ecx,DWORD PTR ds:0x106008
    return (COLS * row) + col;
  1011b0:	8d 0c 89             	lea    ecx,[ecx+ecx*4]
  1011b3:	c1 e1 04             	shl    ecx,0x4
  1011b6:	03 0d 04 60 10 00    	add    ecx,DWORD PTR ds:0x106004
    VGA_BUF[index] = static_cast<uint16>((colour << 8) | symbol);
  1011bc:	8b 15 0c 60 10 00    	mov    edx,DWORD PTR ds:0x10600c
  1011c2:	c1 e2 08             	shl    edx,0x8
  1011c5:	09 c2                	or     edx,eax
  1011c7:	a1 00 60 10 00       	mov    eax,ds:0x106000
  1011cc:	66 89 14 48          	mov    WORD PTR [eax+ecx*2],dx
        if (!flipped) {
  1011d0:	80 3d 0d 60 10 00 00 	cmp    BYTE PTR ds:0x10600d,0x0
  1011d7:	74 59                	je     101232 <term::write(char)+0xf2>
            increment_cursor(row, col, ROWS, COLS, n);
  1011d9:	b9 08 60 10 00       	mov    ecx,0x106008
  1011de:	ba 04 60 10 00       	mov    edx,0x106004
  1011e3:	6a 01                	push   0x1
  1011e5:	6a 50                	push   0x50
  1011e7:	6a 19                	push   0x19
  1011e9:	e8 b2 27 00 00       	call   1039a0 <term::$_0::increment_cursor(int&, int&, int, int, int)>
  1011ee:	83 c4 0c             	add    esp,0xc
        Term.advance();
        break;
    }
}
  1011f1:	5d                   	pop    ebp
  1011f2:	c3                   	ret    
            increment_cursor(col, row, COLS, ROWS, COLS - (col % COLS));
  1011f3:	8b 0d 04 60 10 00    	mov    ecx,DWORD PTR ds:0x106004
  1011f9:	ba 67 66 66 66       	mov    edx,0x66666667
  1011fe:	89 c8                	mov    eax,ecx
  101200:	f7 ea                	imul   edx
  101202:	89 d0                	mov    eax,edx
  101204:	c1 e8 1f             	shr    eax,0x1f
  101207:	c1 fa 05             	sar    edx,0x5
  10120a:	01 c2                	add    edx,eax
  10120c:	c1 e2 04             	shl    edx,0x4
  10120f:	8d 04 92             	lea    eax,[edx+edx*4]
  101212:	29 c8                	sub    eax,ecx
  101214:	83 c0 50             	add    eax,0x50
  101217:	b9 04 60 10 00       	mov    ecx,0x106004
  10121c:	ba 08 60 10 00       	mov    edx,0x106008
  101221:	50                   	push   eax
  101222:	eb 1a                	jmp    10123e <term::write(char)+0xfe>
            increment_cursor(col, row, COLS, ROWS, n);
  101224:	b9 04 60 10 00       	mov    ecx,0x106004
  101229:	ba 08 60 10 00       	mov    edx,0x106008
  10122e:	6a 04                	push   0x4
  101230:	eb 0c                	jmp    10123e <term::write(char)+0xfe>
  101232:	b9 04 60 10 00       	mov    ecx,0x106004
  101237:	ba 08 60 10 00       	mov    edx,0x106008
  10123c:	6a 01                	push   0x1
  10123e:	6a 19                	push   0x19
  101240:	6a 50                	push   0x50
  101242:	e8 59 27 00 00       	call   1039a0 <term::$_0::increment_cursor(int&, int&, int, int, int)>
  101247:	83 c4 0c             	add    esp,0xc
}
  10124a:	5d                   	pop    ebp
  10124b:	c3                   	ret    
  10124c:	90                   	nop
  10124d:	90                   	nop
  10124e:	90                   	nop
  10124f:	90                   	nop

00101250 <term::write(char const*)>:

void write(const char *s) {
  101250:	55                   	push   ebp
  101251:	89 e5                	mov    ebp,esp
  101253:	56                   	push   esi
  101254:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
    for (int a = 0; s[a] != 0; a++) {
  101257:	8a 06                	mov    al,BYTE PTR [esi]
  101259:	84 c0                	test   al,al
  10125b:	74 17                	je     101274 <term::write(char const*)+0x24>
  10125d:	46                   	inc    esi
  10125e:	90                   	nop
  10125f:	90                   	nop
        write(s[a]);
  101260:	0f be c0             	movsx  eax,al
  101263:	50                   	push   eax
  101264:	e8 d7 fe ff ff       	call   101140 <term::write(char)>
  101269:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10126c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10126f:	46                   	inc    esi
  101270:	84 c0                	test   al,al
  101272:	75 ec                	jne    101260 <term::write(char const*)+0x10>
    }
}
  101274:	5e                   	pop    esi
  101275:	5d                   	pop    ebp
  101276:	c3                   	ret    
  101277:	90                   	nop
  101278:	90                   	nop
  101279:	90                   	nop
  10127a:	90                   	nop
  10127b:	90                   	nop
  10127c:	90                   	nop
  10127d:	90                   	nop
  10127e:	90                   	nop
  10127f:	90                   	nop

00101280 <memset>:
#include "initializer_list.hpp"

/**
 * Auto-referenced by clang for some big initializations.
 */
extern "C" void *memset(void *dest, int ch, uint32 count) {
  101280:	55                   	push   ebp
  101281:	89 e5                	mov    ebp,esp
  101283:	56                   	push   esi
  101284:	8b 4d 10             	mov    ecx,DWORD PTR [ebp+0x10]
  101287:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
    for (uint32 a = 0; a < count; a++)
  10128a:	85 c9                	test   ecx,ecx
  10128c:	74 18                	je     1012a6 <memset+0x26>
  10128e:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  101291:	89 c6                	mov    esi,eax
  101293:	90                   	nop
  101294:	90                   	nop
  101295:	90                   	nop
  101296:	90                   	nop
  101297:	90                   	nop
  101298:	90                   	nop
  101299:	90                   	nop
  10129a:	90                   	nop
  10129b:	90                   	nop
  10129c:	90                   	nop
  10129d:	90                   	nop
  10129e:	90                   	nop
  10129f:	90                   	nop
        reinterpret_cast<uint8 *>(dest)[a] = static_cast<uint8>(ch);
  1012a0:	88 16                	mov    BYTE PTR [esi],dl
    for (uint32 a = 0; a < count; a++)
  1012a2:	46                   	inc    esi
  1012a3:	49                   	dec    ecx
  1012a4:	75 fa                	jne    1012a0 <memset+0x20>
    return dest;
  1012a6:	5e                   	pop    esi
  1012a7:	5d                   	pop    ebp
  1012a8:	c3                   	ret    
  1012a9:	90                   	nop
  1012aa:	90                   	nop
  1012ab:	90                   	nop
  1012ac:	90                   	nop
  1012ad:	90                   	nop
  1012ae:	90                   	nop
  1012af:	90                   	nop

001012b0 <operator new(unsigned int)>:

allocator<4 * sizeof(uint32), 1000> fast_allocator;

} // namespace

void *operator new(uint32 count) {
  1012b0:	55                   	push   ebp
  1012b1:	89 e5                	mov    ebp,esp
  1012b3:	53                   	push   ebx
  1012b4:	56                   	push   esi
  1012b5:	83 e4 f8             	and    esp,0xfffffff8
  1012b8:	83 ec 28             	sub    esp,0x28
    if (count >= 4 * sizeof(uint32)) {
  1012bb:	83 7d 08 10          	cmp    DWORD PTR [ebp+0x8],0x10
  1012bf:	0f 83 a2 00 00 00    	jae    101367 <operator new(unsigned int)+0xb7>
        if (blocks >= BN - next_free || !find_next_free())
  1012c5:	a1 00 70 11 00       	mov    eax,ds:0x117000
  1012ca:	3d e6 03 00 00       	cmp    eax,0x3e6
  1012cf:	7f 37                	jg     101308 <operator new(unsigned int)+0x58>
  1012d1:	31 c9                	xor    ecx,ecx
  1012d3:	90                   	nop
  1012d4:	90                   	nop
  1012d5:	90                   	nop
  1012d6:	90                   	nop
  1012d7:	90                   	nop
  1012d8:	90                   	nop
  1012d9:	90                   	nop
  1012da:	90                   	nop
  1012db:	90                   	nop
  1012dc:	90                   	nop
  1012dd:	90                   	nop
  1012de:	90                   	nop
  1012df:	90                   	nop
        auto b = bytes_[i / 8];
  1012e0:	89 ca                	mov    edx,ecx
  1012e2:	c1 ea 03             	shr    edx,0x3
  1012e5:	81 e2 ff 1f 00 00    	and    edx,0x1fff
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  1012eb:	0f b6 92 04 70 11 00 	movzx  edx,BYTE PTR [edx+0x117004]
        return (b & (1 << (i % 8))) != 0;
  1012f2:	89 cb                	mov    ebx,ecx
  1012f4:	80 e3 07             	and    bl,0x7
  1012f7:	0f b6 f3             	movzx  esi,bl
  1012fa:	0f a3 f2             	bt     edx,esi
            if (!block_list[a])
  1012fd:	73 1d                	jae    10131c <operator new(unsigned int)+0x6c>
        for (int a=0; a<BN; a++) {
  1012ff:	41                   	inc    ecx
  101300:	81 f9 e8 03 00 00    	cmp    ecx,0x3e8
  101306:	75 d8                	jne    1012e0 <operator new(unsigned int)+0x30>
                          int_to_string(4 * sizeof(uint32)).str(),
                          " bytes at once\n");
    }
    auto r = fast_allocator.allocate(1);
    if (!r) {
        term::fatal_error("Allocation failed: ", r.err, "\n");
  101308:	68 9f 00 10 00       	push   0x10009f
  10130d:	68 6f 00 10 00       	push   0x10006f
  101312:	68 a9 00 10 00       	push   0x1000a9
  101317:	e8 c4 29 00 00       	call   103ce0 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)>
        auto r = reinterpret_cast<uint32 *>(mem::HEAP_START + BS * next_free);
  10131c:	c1 e0 04             	shl    eax,0x4
  10131f:	05 00 00 20 00       	add    eax,0x200000
  101324:	31 c9                	xor    ecx,ecx
  101326:	90                   	nop
  101327:	90                   	nop
  101328:	90                   	nop
  101329:	90                   	nop
  10132a:	90                   	nop
  10132b:	90                   	nop
  10132c:	90                   	nop
  10132d:	90                   	nop
  10132e:	90                   	nop
  10132f:	90                   	nop
        auto b = bytes_[i / 8];
  101330:	89 ca                	mov    edx,ecx
  101332:	c1 ea 03             	shr    edx,0x3
  101335:	81 e2 ff 1f 00 00    	and    edx,0x1fff
  10133b:	0f b6 92 04 70 11 00 	movzx  edx,BYTE PTR [edx+0x117004]
        return (b & (1 << (i % 8))) != 0;
  101342:	89 cb                	mov    ebx,ecx
  101344:	80 e3 07             	and    bl,0x7
  101347:	0f b6 f3             	movzx  esi,bl
  10134a:	0f a3 f2             	bt     edx,esi
            if (!block_list[a])
  10134d:	73 0b                	jae    10135a <operator new(unsigned int)+0xaa>
        for (int a=0; a<BN; a++) {
  10134f:	41                   	inc    ecx
  101350:	81 f9 e8 03 00 00    	cmp    ecx,0x3e8
  101356:	75 d8                	jne    101330 <operator new(unsigned int)+0x80>
  101358:	31 c9                	xor    ecx,ecx
        next_free = find_next_free().value;
  10135a:	89 0d 00 70 11 00    	mov    DWORD PTR ds:0x117000,ecx
    }
    return r.value;
  101360:	8d 65 f8             	lea    esp,[ebp-0x8]
  101363:	5e                   	pop    esi
  101364:	5b                   	pop    ebx
  101365:	5d                   	pop    ebp
  101366:	c3                   	ret    
  101367:	89 e6                	mov    esi,esp
                          int_to_string(4 * sizeof(uint32)).str(),
  101369:	6a 10                	push   0x10
  10136b:	56                   	push   esi
  10136c:	e8 ff 29 00 00       	call   103d70 <auto int_to_string<10, unsigned int>(unsigned int)>
  101371:	83 c4 04             	add    esp,0x4
        term::fatal_error("Cannot allocate more than ",
  101374:	68 bd 00 10 00       	push   0x1000bd
  101379:	56                   	push   esi
  10137a:	68 11 00 10 00       	push   0x100011
  10137f:	e8 5c 29 00 00       	call   103ce0 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)>
  101384:	90                   	nop
  101385:	90                   	nop
  101386:	90                   	nop
  101387:	90                   	nop
  101388:	90                   	nop
  101389:	90                   	nop
  10138a:	90                   	nop
  10138b:	90                   	nop
  10138c:	90                   	nop
  10138d:	90                   	nop
  10138e:	90                   	nop
  10138f:	90                   	nop

00101390 <operator delete(void*)>:
}

void operator delete(void *p) noexcept { fast_allocator.deallocate(p); }
  101390:	55                   	push   ebp
  101391:	89 e5                	mov    ebp,esp
  101393:	53                   	push   ebx
  101394:	83 e4 f8             	and    esp,0xfffffff8
  101397:	83 ec 10             	sub    esp,0x10
  10139a:	bb 00 00 e0 ff       	mov    ebx,0xffe00000
        auto target = reinterpret_cast<uint32>(p) - mem::HEAP_START;
  10139f:	03 5d 08             	add    ebx,DWORD PTR [ebp+0x8]
  1013a2:	89 e0                	mov    eax,esp
        return bit_member(*this, static_cast<int>(i));
  1013a4:	53                   	push   ebx
  1013a5:	68 04 70 11 00       	push   0x117004
  1013aa:	50                   	push   eax
  1013ab:	e8 90 2e 00 00       	call   104240 <mem::bit_sequence<1000>::bit_member::bit_member(mem::bit_sequence<1000>&, int)>
  1013b0:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  1013b3:	80 7c 24 08 00       	cmp    BYTE PTR [esp+0x8],0x0
        if (!block_list[target]) {
  1013b8:	74 54                	je     10140e <operator delete(void*)+0x7e>
        auto &b = bytes_[i / 8];
  1013ba:	89 d8                	mov    eax,ebx
  1013bc:	c1 e8 03             	shr    eax,0x3
  1013bf:	80 e3 07             	and    bl,0x7
  1013c2:	ba 01 00 00 00       	mov    edx,0x1
  1013c7:	89 d9                	mov    ecx,ebx
  1013c9:	d3 e2                	shl    edx,cl
        if (x)
  1013cb:	f6 d2                	not    dl
  1013cd:	20 90 04 70 11 00    	and    BYTE PTR [eax+0x117004],dl
  1013d3:	31 c0                	xor    eax,eax
  1013d5:	90                   	nop
  1013d6:	90                   	nop
  1013d7:	90                   	nop
  1013d8:	90                   	nop
  1013d9:	90                   	nop
  1013da:	90                   	nop
  1013db:	90                   	nop
  1013dc:	90                   	nop
  1013dd:	90                   	nop
  1013de:	90                   	nop
  1013df:	90                   	nop
        auto b = bytes_[i / 8];
  1013e0:	89 c1                	mov    ecx,eax
  1013e2:	c1 e9 03             	shr    ecx,0x3
  1013e5:	81 e1 ff 1f 00 00    	and    ecx,0x1fff
  1013eb:	0f b6 89 04 70 11 00 	movzx  ecx,BYTE PTR [ecx+0x117004]
        return (b & (1 << (i % 8))) != 0;
  1013f2:	89 c2                	mov    edx,eax
  1013f4:	80 e2 07             	and    dl,0x7
  1013f7:	0f b6 d2             	movzx  edx,dl
  1013fa:	0f a3 d1             	bt     ecx,edx
            if (!block_list[a])
  1013fd:	73 0a                	jae    101409 <operator delete(void*)+0x79>
        for (int a=0; a<BN; a++) {
  1013ff:	40                   	inc    eax
  101400:	3d e8 03 00 00       	cmp    eax,0x3e8
  101405:	75 d9                	jne    1013e0 <operator delete(void*)+0x50>
  101407:	31 c0                	xor    eax,eax
        next_free = find_next_free().value;
  101409:	a3 00 70 11 00       	mov    ds:0x117000,eax
void operator delete(void *p) noexcept { fast_allocator.deallocate(p); }
  10140e:	8d 65 fc             	lea    esp,[ebp-0x4]
  101411:	5b                   	pop    ebx
  101412:	5d                   	pop    ebp
  101413:	c3                   	ret    
  101414:	90                   	nop
  101415:	90                   	nop
  101416:	90                   	nop
  101417:	90                   	nop
  101418:	90                   	nop
  101419:	90                   	nop
  10141a:	90                   	nop
  10141b:	90                   	nop
  10141c:	90                   	nop
  10141d:	90                   	nop
  10141e:	90                   	nop
  10141f:	90                   	nop

00101420 <io::send(unsigned short, unsigned char)>:
#pragma once
#include "core.hpp"

namespace io {
void send(uint16 port, uint8 byte) {
  101420:	55                   	push   ebp
  101421:	89 e5                	mov    ebp,esp
  101423:	0f b7 55 08          	movzx  edx,WORD PTR [ebp+0x8]
  101427:	8a 45 0c             	mov    al,BYTE PTR [ebp+0xc]
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10142a:	ee                   	out    dx,al
}
  10142b:	5d                   	pop    ebp
  10142c:	c3                   	ret    
  10142d:	90                   	nop
  10142e:	90                   	nop
  10142f:	90                   	nop

00101430 <io::receive(unsigned short)>:

uint8 receive(uint16 port) {
  101430:	55                   	push   ebp
  101431:	89 e5                	mov    ebp,esp
  101433:	0f b7 55 08          	movzx  edx,WORD PTR [ebp+0x8]
    uint8 r;
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101437:	ec                   	in     al,dx
    return r;
  101438:	5d                   	pop    ebp
  101439:	c3                   	ret    
  10143a:	90                   	nop
  10143b:	90                   	nop
  10143c:	90                   	nop
  10143d:	90                   	nop
  10143e:	90                   	nop
  10143f:	90                   	nop

00101440 <ps2::read_config()>:
 * Specialized send/receive functions with timeout
 */
// void send(uint16 port, uint8 byte);
// uint8 receive(uint16 port);

uint8 read_config() {
  101440:	55                   	push   ebp
  101441:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101443:	66 ba 64 00          	mov    dx,0x64
  101447:	b0 20                	mov    al,0x20
  101449:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10144a:	66 ba 60 00          	mov    dx,0x60
  10144e:	ec                   	in     al,dx
    /*5 	    Second PS/2 port clock (1 = disabled, 0 = enabled, only if 2
     * PS/2 ports supported)*/
    /*6 	    First PS/2 port translation (1 = enabled, 0 = disabled)*/
    /*7       Must be zero*/
    send(COMMAND, 0x20);
    return receive(DATA);
  10144f:	5d                   	pop    ebp
  101450:	c3                   	ret    
  101451:	90                   	nop
  101452:	90                   	nop
  101453:	90                   	nop
  101454:	90                   	nop
  101455:	90                   	nop
  101456:	90                   	nop
  101457:	90                   	nop
  101458:	90                   	nop
  101459:	90                   	nop
  10145a:	90                   	nop
  10145b:	90                   	nop
  10145c:	90                   	nop
  10145d:	90                   	nop
  10145e:	90                   	nop
  10145f:	90                   	nop

00101460 <ps2::write_config(unsigned char)>:
}
void write_config(uint8 byte) {
  101460:	55                   	push   ebp
  101461:	89 e5                	mov    ebp,esp
  101463:	8a 4d 08             	mov    cl,BYTE PTR [ebp+0x8]
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101466:	66 ba 64 00          	mov    dx,0x64
  10146a:	b0 60                	mov    al,0x60
  10146c:	ee                   	out    dx,al
  10146d:	66 ba 60 00          	mov    dx,0x60
  101471:	89 c8                	mov    eax,ecx
  101473:	ee                   	out    dx,al
    send(COMMAND, 0x60);
    send(DATA, byte);
}
  101474:	5d                   	pop    ebp
  101475:	c3                   	ret    
  101476:	90                   	nop
  101477:	90                   	nop
  101478:	90                   	nop
  101479:	90                   	nop
  10147a:	90                   	nop
  10147b:	90                   	nop
  10147c:	90                   	nop
  10147d:	90                   	nop
  10147e:	90                   	nop
  10147f:	90                   	nop

00101480 <ps2::status()>:

uint8 status() { return receive(COMMAND); }
  101480:	55                   	push   ebp
  101481:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101483:	66 ba 64 00          	mov    dx,0x64
  101487:	ec                   	in     al,dx
uint8 status() { return receive(COMMAND); }
  101488:	5d                   	pop    ebp
  101489:	c3                   	ret    
  10148a:	90                   	nop
  10148b:	90                   	nop
  10148c:	90                   	nop
  10148d:	90                   	nop
  10148e:	90                   	nop
  10148f:	90                   	nop

00101490 <ps2::has_output_data()>:
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101490:	55                   	push   ebp
  101491:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101493:	66 ba 64 00          	mov    dx,0x64
  101497:	ec                   	in     al,dx
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101498:	24 01                	and    al,0x1
  10149a:	5d                   	pop    ebp
  10149b:	c3                   	ret    
  10149c:	90                   	nop
  10149d:	90                   	nop
  10149e:	90                   	nop
  10149f:	90                   	nop

001014a0 <ps2::has_input_data()>:
bool has_input_data() { return (status() & 0b00000010) != 0; }
  1014a0:	55                   	push   ebp
  1014a1:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014a3:	66 ba 64 00          	mov    dx,0x64
  1014a7:	ec                   	in     al,dx
bool has_input_data() { return (status() & 0b00000010) != 0; }
  1014a8:	24 02                	and    al,0x2
  1014aa:	d0 e8                	shr    al,1
  1014ac:	5d                   	pop    ebp
  1014ad:	c3                   	ret    
  1014ae:	90                   	nop
  1014af:	90                   	nop

001014b0 <ps2::writing_to_controller()>:
bool writing_to_controller() { return (status() & 0b00001000) != 0; }
  1014b0:	55                   	push   ebp
  1014b1:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014b3:	66 ba 64 00          	mov    dx,0x64
  1014b7:	ec                   	in     al,dx
bool writing_to_controller() { return (status() & 0b00001000) != 0; }
  1014b8:	24 08                	and    al,0x8
  1014ba:	c0 e8 03             	shr    al,0x3
  1014bd:	5d                   	pop    ebp
  1014be:	c3                   	ret    
  1014bf:	90                   	nop

001014c0 <ps2::got_timeout_error()>:
bool got_timeout_error() { return (status() & 0b010000000) != 0; }
  1014c0:	55                   	push   ebp
  1014c1:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014c3:	66 ba 64 00          	mov    dx,0x64
  1014c7:	ec                   	in     al,dx
bool got_timeout_error() { return (status() & 0b010000000) != 0; }
  1014c8:	c0 e8 07             	shr    al,0x7
  1014cb:	5d                   	pop    ebp
  1014cc:	c3                   	ret    
  1014cd:	90                   	nop
  1014ce:	90                   	nop
  1014cf:	90                   	nop

001014d0 <ps2::got_parity_error()>:
bool got_parity_error() { return (status() & 0b10000000) != 0; }
  1014d0:	55                   	push   ebp
  1014d1:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014d3:	66 ba 64 00          	mov    dx,0x64
  1014d7:	ec                   	in     al,dx
bool got_parity_error() { return (status() & 0b10000000) != 0; }
  1014d8:	c0 e8 07             	shr    al,0x7
  1014db:	5d                   	pop    ebp
  1014dc:	c3                   	ret    
  1014dd:	90                   	nop
  1014de:	90                   	nop
  1014df:	90                   	nop

001014e0 <ps2::read_output_port()>:

uint8 read_output_port() {
  1014e0:	55                   	push   ebp
  1014e1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1014e3:	66 ba 64 00          	mov    dx,0x64
  1014e7:	b0 d0                	mov    al,0xd0
  1014e9:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1014ea:	66 ba 60 00          	mov    dx,0x60
  1014ee:	ec                   	in     al,dx
    send(COMMAND, 0xD0);
    return receive(DATA);
  1014ef:	5d                   	pop    ebp
  1014f0:	c3                   	ret    
  1014f1:	90                   	nop
  1014f2:	90                   	nop
  1014f3:	90                   	nop
  1014f4:	90                   	nop
  1014f5:	90                   	nop
  1014f6:	90                   	nop
  1014f7:	90                   	nop
  1014f8:	90                   	nop
  1014f9:	90                   	nop
  1014fa:	90                   	nop
  1014fb:	90                   	nop
  1014fc:	90                   	nop
  1014fd:	90                   	nop
  1014fe:	90                   	nop
  1014ff:	90                   	nop

00101500 <ps2::test_controller()>:
}

bool test_controller() {
  101500:	55                   	push   ebp
  101501:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101503:	66 ba 64 00          	mov    dx,0x64
  101507:	b0 aa                	mov    al,0xaa
  101509:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10150a:	66 ba 60 00          	mov    dx,0x60
  10150e:	ec                   	in     al,dx
    send(COMMAND, 0xAA);
    return receive(DATA) == 0x55;
  10150f:	3c 55                	cmp    al,0x55
  101511:	0f 94 c0             	sete   al
  101514:	5d                   	pop    ebp
  101515:	c3                   	ret    
  101516:	90                   	nop
  101517:	90                   	nop
  101518:	90                   	nop
  101519:	90                   	nop
  10151a:	90                   	nop
  10151b:	90                   	nop
  10151c:	90                   	nop
  10151d:	90                   	nop
  10151e:	90                   	nop
  10151f:	90                   	nop

00101520 <ps2::test_port_1()>:
}
bool test_port_1() {
  101520:	55                   	push   ebp
  101521:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101523:	66 ba 64 00          	mov    dx,0x64
  101527:	b0 ab                	mov    al,0xab
  101529:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10152a:	66 ba 60 00          	mov    dx,0x60
  10152e:	ec                   	in     al,dx
    send(COMMAND, 0xAB);
    return receive(DATA) == 0x00;
  10152f:	84 c0                	test   al,al
  101531:	0f 94 c0             	sete   al
  101534:	5d                   	pop    ebp
  101535:	c3                   	ret    
  101536:	90                   	nop
  101537:	90                   	nop
  101538:	90                   	nop
  101539:	90                   	nop
  10153a:	90                   	nop
  10153b:	90                   	nop
  10153c:	90                   	nop
  10153d:	90                   	nop
  10153e:	90                   	nop
  10153f:	90                   	nop

00101540 <ps2::disable_1()>:
}

void disable_1() { send(COMMAND, 0xAD); }
  101540:	55                   	push   ebp
  101541:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101543:	66 ba 64 00          	mov    dx,0x64
  101547:	b0 ad                	mov    al,0xad
  101549:	ee                   	out    dx,al
void disable_1() { send(COMMAND, 0xAD); }
  10154a:	5d                   	pop    ebp
  10154b:	c3                   	ret    
  10154c:	90                   	nop
  10154d:	90                   	nop
  10154e:	90                   	nop
  10154f:	90                   	nop

00101550 <ps2::enable_1()>:
void enable_1() { send(COMMAND, 0xAE); }
  101550:	55                   	push   ebp
  101551:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101553:	66 ba 64 00          	mov    dx,0x64
  101557:	b0 ae                	mov    al,0xae
  101559:	ee                   	out    dx,al
void enable_1() { send(COMMAND, 0xAE); }
  10155a:	5d                   	pop    ebp
  10155b:	c3                   	ret    
  10155c:	90                   	nop
  10155d:	90                   	nop
  10155e:	90                   	nop
  10155f:	90                   	nop

00101560 <ps2::disable_2()>:
void disable_2() { send(COMMAND, 0xA7); }
  101560:	55                   	push   ebp
  101561:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101563:	66 ba 64 00          	mov    dx,0x64
  101567:	b0 a7                	mov    al,0xa7
  101569:	ee                   	out    dx,al
void disable_2() { send(COMMAND, 0xA7); }
  10156a:	5d                   	pop    ebp
  10156b:	c3                   	ret    
  10156c:	90                   	nop
  10156d:	90                   	nop
  10156e:	90                   	nop
  10156f:	90                   	nop

00101570 <ps2::enable_2()>:
void enable_2() { send(COMMAND, 0xA8); }
  101570:	55                   	push   ebp
  101571:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101573:	66 ba 64 00          	mov    dx,0x64
  101577:	b0 a8                	mov    al,0xa8
  101579:	ee                   	out    dx,al
void enable_2() { send(COMMAND, 0xA8); }
  10157a:	5d                   	pop    ebp
  10157b:	c3                   	ret    
  10157c:	90                   	nop
  10157d:	90                   	nop
  10157e:	90                   	nop
  10157f:	90                   	nop

00101580 <ps2::reset_1()>:
bool reset_1() {
  101580:	55                   	push   ebp
  101581:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101583:	66 ba 60 00          	mov    dx,0x60
  101587:	b0 ff                	mov    al,0xff
  101589:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10158a:	66 ba 60 00          	mov    dx,0x60
  10158e:	ec                   	in     al,dx
  10158f:	66 ba 60 00          	mov    dx,0x60
  101593:	ec                   	in     al,dx
    send(DATA, 0xFF);
    receive(DATA); // this receive() should not be necessary...
    return receive(DATA) == 0xAA;
  101594:	3c aa                	cmp    al,0xaa
  101596:	0f 94 c0             	sete   al
  101599:	5d                   	pop    ebp
  10159a:	c3                   	ret    
  10159b:	90                   	nop
  10159c:	90                   	nop
  10159d:	90                   	nop
  10159e:	90                   	nop
  10159f:	90                   	nop

001015a0 <ps2::reset_2()>:
}
bool reset_2() {
  1015a0:	55                   	push   ebp
  1015a1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1015a3:	66 ba 64 00          	mov    dx,0x64
  1015a7:	b0 d4                	mov    al,0xd4
  1015a9:	ee                   	out    dx,al
  1015aa:	66 ba 60 00          	mov    dx,0x60
  1015ae:	b0 ff                	mov    al,0xff
  1015b0:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1015b1:	66 ba 60 00          	mov    dx,0x60
  1015b5:	ec                   	in     al,dx
  1015b6:	66 ba 60 00          	mov    dx,0x60
  1015ba:	ec                   	in     al,dx
    send(COMMAND, 0xD4);
    send(DATA, 0xFF);
    receive(DATA); // this receive() should not be necessary...
    return receive(DATA) == 0xAA;
  1015bb:	3c aa                	cmp    al,0xaa
  1015bd:	0f 94 c0             	sete   al
  1015c0:	5d                   	pop    ebp
  1015c1:	c3                   	ret    
  1015c2:	90                   	nop
  1015c3:	90                   	nop
  1015c4:	90                   	nop
  1015c5:	90                   	nop
  1015c6:	90                   	nop
  1015c7:	90                   	nop
  1015c8:	90                   	nop
  1015c9:	90                   	nop
  1015ca:	90                   	nop
  1015cb:	90                   	nop
  1015cc:	90                   	nop
  1015cd:	90                   	nop
  1015ce:	90                   	nop
  1015cf:	90                   	nop

001015d0 <ps2::hard_reset()>:
}

void hard_reset() { send(COMMAND, 0xFE); }
  1015d0:	55                   	push   ebp
  1015d1:	89 e5                	mov    ebp,esp
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1015d3:	66 ba 64 00          	mov    dx,0x64
  1015d7:	b0 fe                	mov    al,0xfe
  1015d9:	ee                   	out    dx,al
void hard_reset() { send(COMMAND, 0xFE); }
  1015da:	5d                   	pop    ebp
  1015db:	c3                   	ret    
  1015dc:	90                   	nop
  1015dd:	90                   	nop
  1015de:	90                   	nop
  1015df:	90                   	nop

001015e0 <ps2::get_output()>:

uint8 get_output() { return receive(DATA); }
  1015e0:	55                   	push   ebp
  1015e1:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1015e3:	66 ba 60 00          	mov    dx,0x60
  1015e7:	ec                   	in     al,dx
uint8 get_output() { return receive(DATA); }
  1015e8:	5d                   	pop    ebp
  1015e9:	c3                   	ret    
  1015ea:	90                   	nop
  1015eb:	90                   	nop
  1015ec:	90                   	nop
  1015ed:	90                   	nop
  1015ee:	90                   	nop
  1015ef:	90                   	nop

001015f0 <ps2::flush_output()>:

void flush_output() {
  1015f0:	55                   	push   ebp
  1015f1:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1015f3:	66 ba 64 00          	mov    dx,0x64
  1015f7:	ec                   	in     al,dx
  1015f8:	a8 01                	test   al,0x1
    while (has_output_data())
  1015fa:	74 12                	je     10160e <ps2::flush_output()+0x1e>
  1015fc:	90                   	nop
  1015fd:	90                   	nop
  1015fe:	90                   	nop
  1015ff:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101600:	66 ba 60 00          	mov    dx,0x60
  101604:	ec                   	in     al,dx
  101605:	66 ba 64 00          	mov    dx,0x64
  101609:	ec                   	in     al,dx
  10160a:	a8 01                	test   al,0x1
    while (has_output_data())
  10160c:	75 f2                	jne    101600 <ps2::flush_output()+0x10>
        receive(DATA);
}
  10160e:	5d                   	pop    ebp
  10160f:	c3                   	ret    

00101610 <ps2::startup(int)>:
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  101610:	66 ba 64 00          	mov    dx,0x64
  101614:	b0 ad                	mov    al,0xad
  101616:	ee                   	out    dx,al
  101617:	66 ba 64 00          	mov    dx,0x64
  10161b:	b0 a7                	mov    al,0xa7
  10161d:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10161e:	66 ba 64 00          	mov    dx,0x64
  101622:	ec                   	in     al,dx
  101623:	a8 01                	test   al,0x1
    while (has_output_data())
  101625:	74 17                	je     10163e <ps2::startup(int)+0x2e>
  101627:	90                   	nop
  101628:	90                   	nop
  101629:	90                   	nop
  10162a:	90                   	nop
  10162b:	90                   	nop
  10162c:	90                   	nop
  10162d:	90                   	nop
  10162e:	90                   	nop
  10162f:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101630:	66 ba 60 00          	mov    dx,0x60
  101634:	ec                   	in     al,dx
  101635:	66 ba 64 00          	mov    dx,0x64
  101639:	ec                   	in     al,dx
  10163a:	a8 01                	test   al,0x1
    while (has_output_data())
  10163c:	75 f2                	jne    101630 <ps2::startup(int)+0x20>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10163e:	66 ba 64 00          	mov    dx,0x64
  101642:	b0 20                	mov    al,0x20
  101644:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101645:	66 ba 60 00          	mov    dx,0x60
  101649:	ec                   	in     al,dx
  10164a:	89 c1                	mov    ecx,eax
bool startup(int device = 1) {
    ps2::disable_1();
    ps2::disable_2();
    ps2::flush_output();
    uint8 cb = ps2::read_config();
    cb &= 0b10111100; // disable interrupts and translation
  10164c:	80 e1 bc             	and    cl,0xbc
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10164f:	66 ba 64 00          	mov    dx,0x64
  101653:	b0 60                	mov    al,0x60
  101655:	ee                   	out    dx,al
  101656:	66 ba 60 00          	mov    dx,0x60
  10165a:	89 c8                	mov    eax,ecx
  10165c:	ee                   	out    dx,al
  10165d:	66 ba 64 00          	mov    dx,0x64
  101661:	b0 aa                	mov    al,0xaa
  101663:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101664:	66 ba 60 00          	mov    dx,0x60
  101668:	ec                   	in     al,dx
    return receive(DATA) == 0x55;
  101669:	3c 55                	cmp    al,0x55
    ps2::write_config(cb);
    if (!(ps2::test_controller() && ps2::test_port_1()))
  10166b:	75 5c                	jne    1016c9 <ps2::startup(int)+0xb9>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10166d:	66 ba 64 00          	mov    dx,0x64
  101671:	b0 ab                	mov    al,0xab
  101673:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101674:	66 ba 60 00          	mov    dx,0x60
  101678:	ec                   	in     al,dx
    return receive(DATA) == 0x00;
  101679:	84 c0                	test   al,al
    if (!(ps2::test_controller() && ps2::test_port_1()))
  10167b:	75 4c                	jne    1016c9 <ps2::startup(int)+0xb9>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  10167d:	66 ba 64 00          	mov    dx,0x64
  101681:	b0 ae                	mov    al,0xae
  101683:	ee                   	out    dx,al
  101684:	66 ba 60 00          	mov    dx,0x60
  101688:	b0 ff                	mov    al,0xff
  10168a:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  10168b:	66 ba 60 00          	mov    dx,0x60
  10168f:	ec                   	in     al,dx
  101690:	66 ba 60 00          	mov    dx,0x60
  101694:	ec                   	in     al,dx
    return receive(DATA) == 0xAA;
  101695:	3c aa                	cmp    al,0xaa
        return false;
    ps2::enable_1();
    if (!ps2::reset_1())
  101697:	75 30                	jne    1016c9 <ps2::startup(int)+0xb9>
  101699:	55                   	push   ebp
  10169a:	89 e5                	mov    ebp,esp
        return false;
    if (device == 2) {
  10169c:	83 7d 08 02          	cmp    DWORD PTR [ebp+0x8],0x2
  1016a0:	5d                   	pop    ebp
  1016a1:	75 23                	jne    1016c6 <ps2::startup(int)+0xb6>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1016a3:	66 ba 64 00          	mov    dx,0x64
  1016a7:	b0 a8                	mov    al,0xa8
  1016a9:	ee                   	out    dx,al
  1016aa:	66 ba 64 00          	mov    dx,0x64
  1016ae:	b0 d4                	mov    al,0xd4
  1016b0:	ee                   	out    dx,al
  1016b1:	66 ba 60 00          	mov    dx,0x60
  1016b5:	b0 ff                	mov    al,0xff
  1016b7:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1016b8:	66 ba 60 00          	mov    dx,0x60
  1016bc:	ec                   	in     al,dx
  1016bd:	66 ba 60 00          	mov    dx,0x60
  1016c1:	ec                   	in     al,dx
    return receive(DATA) == 0xAA;
  1016c2:	3c aa                	cmp    al,0xaa
        ps2::enable_2();
        if (!ps2::reset_2())
  1016c4:	75 03                	jne    1016c9 <ps2::startup(int)+0xb9>
  1016c6:	b0 01                	mov    al,0x1
            return false;
    }
    return true;
}
  1016c8:	c3                   	ret    
  1016c9:	31 c0                	xor    eax,eax
  1016cb:	c3                   	ret    
  1016cc:	90                   	nop
  1016cd:	90                   	nop
  1016ce:	90                   	nop
  1016cf:	90                   	nop

001016d0 <kbd::get_ascii()>:

string<80> LINE_BUFFER;

enum special_ascii : char { ASCII_END_OF_TEXT = 0x3, ASCII_BACKSPACE=0x8 };

optional<char> get_ascii() {
  1016d0:	55                   	push   ebp
  1016d1:	89 e5                	mov    ebp,esp
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1016d3:	66 ba 60 00          	mov    dx,0x60
  1016d7:	ec                   	in     al,dx
  1016d8:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
    static bool ctrl_pressed = false;
    auto a = ps2::get_output();
    // scan codes (set 2)
    // http://www.techtoys.com.hk/Downloads/Download/Microchip/PS2_driver/ScanCode.pdf
    switch (a) {
  1016db:	04 10                	add    al,0x10
  1016dd:	3c 76                	cmp    al,0x76
  1016df:	77 23                	ja     101704 <kbd::get_ascii()+0x34>
  1016e1:	0f b6 c0             	movzx  eax,al
  1016e4:	ff 24 85 00 50 10 00 	jmp    DWORD PTR [eax*4+0x105000]
  1016eb:	66 ba 60 00          	mov    dx,0x60
  1016ef:	ec                   	in     al,dx
    case 0xF0: {
        // break codes
        auto b = ps2::get_output();
        switch (b) {
  1016f0:	3c 14                	cmp    al,0x14
  1016f2:	75 10                	jne    101704 <kbd::get_ascii()+0x34>
        case 0x14:
            ctrl_pressed = false;
  1016f4:	c6 05 e0 70 11 00 00 	mov    BYTE PTR ds:0x1170e0,0x0
  1016fb:	eb 07                	jmp    101704 <kbd::get_ascii()+0x34>
            break;
        }
        break;
    }
    case 0x14:
        ctrl_pressed = true;
  1016fd:	c6 05 e0 70 11 00 01 	mov    BYTE PTR ds:0x1170e0,0x1
    bool loaded_ = false;
  101704:	66 c7 01 00 00       	mov    WORD PTR [ecx],0x0
  101709:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
    //  }
    default:
        break; // unhandled make/break code
    }
    return {};
}
  101710:	89 c8                	mov    eax,ecx
  101712:	5d                   	pop    ebp
  101713:	c2 04 00             	ret    0x4
    constexpr optional(T p) : loaded_(true), value(move(p)) {}
  101716:	66 c7 01 01 7a       	mov    WORD PTR [ecx],0x7a01
  10171b:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101722:	89 c8                	mov    eax,ecx
  101724:	5d                   	pop    ebp
  101725:	c2 04 00             	ret    0x4
        if (ctrl_pressed)
  101728:	a0 e0 70 11 00       	mov    al,ds:0x1170e0
  10172d:	c6 01 01             	mov    BYTE PTR [ecx],0x1
  101730:	3c 01                	cmp    al,0x1
  101732:	0f 85 05 03 00 00    	jne    101a3d <kbd::get_ascii()+0x36d>
  101738:	c6 41 01 03          	mov    BYTE PTR [ecx+0x1],0x3
  10173c:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
}
  101743:	89 c8                	mov    eax,ecx
  101745:	5d                   	pop    ebp
  101746:	c2 04 00             	ret    0x4
  101749:	66 c7 01 01 78       	mov    WORD PTR [ecx],0x7801
  10174e:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101755:	89 c8                	mov    eax,ecx
  101757:	5d                   	pop    ebp
  101758:	c2 04 00             	ret    0x4
  10175b:	66 c7 01 01 64       	mov    WORD PTR [ecx],0x6401
  101760:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101767:	89 c8                	mov    eax,ecx
  101769:	5d                   	pop    ebp
  10176a:	c2 04 00             	ret    0x4
  10176d:	66 c7 01 01 65       	mov    WORD PTR [ecx],0x6501
  101772:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101779:	89 c8                	mov    eax,ecx
  10177b:	5d                   	pop    ebp
  10177c:	c2 04 00             	ret    0x4
  10177f:	66 c7 01 01 66       	mov    WORD PTR [ecx],0x6601
  101784:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10178b:	89 c8                	mov    eax,ecx
  10178d:	5d                   	pop    ebp
  10178e:	c2 04 00             	ret    0x4
  101791:	66 c7 01 01 74       	mov    WORD PTR [ecx],0x7401
  101796:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10179d:	89 c8                	mov    eax,ecx
  10179f:	5d                   	pop    ebp
  1017a0:	c2 04 00             	ret    0x4
  1017a3:	66 c7 01 01 35       	mov    WORD PTR [ecx],0x3501
  1017a8:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1017af:	89 c8                	mov    eax,ecx
  1017b1:	5d                   	pop    ebp
  1017b2:	c2 04 00             	ret    0x4
  1017b5:	66 c7 01 01 6e       	mov    WORD PTR [ecx],0x6e01
  1017ba:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1017c1:	89 c8                	mov    eax,ecx
  1017c3:	5d                   	pop    ebp
  1017c4:	c2 04 00             	ret    0x4
  1017c7:	66 c7 01 01 62       	mov    WORD PTR [ecx],0x6201
  1017cc:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1017d3:	89 c8                	mov    eax,ecx
  1017d5:	5d                   	pop    ebp
  1017d6:	c2 04 00             	ret    0x4
  1017d9:	66 c7 01 01 68       	mov    WORD PTR [ecx],0x6801
  1017de:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1017e5:	89 c8                	mov    eax,ecx
  1017e7:	5d                   	pop    ebp
  1017e8:	c2 04 00             	ret    0x4
  1017eb:	66 c7 01 01 67       	mov    WORD PTR [ecx],0x6701
  1017f0:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1017f7:	89 c8                	mov    eax,ecx
  1017f9:	5d                   	pop    ebp
  1017fa:	c2 04 00             	ret    0x4
  1017fd:	66 c7 01 01 6d       	mov    WORD PTR [ecx],0x6d01
  101802:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101809:	89 c8                	mov    eax,ecx
  10180b:	5d                   	pop    ebp
  10180c:	c2 04 00             	ret    0x4
  10180f:	66 c7 01 01 6a       	mov    WORD PTR [ecx],0x6a01
  101814:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10181b:	89 c8                	mov    eax,ecx
  10181d:	5d                   	pop    ebp
  10181e:	c2 04 00             	ret    0x4
  101821:	66 c7 01 01 37       	mov    WORD PTR [ecx],0x3701
  101826:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10182d:	89 c8                	mov    eax,ecx
  10182f:	5d                   	pop    ebp
  101830:	c2 04 00             	ret    0x4
  101833:	66 c7 01 01 6b       	mov    WORD PTR [ecx],0x6b01
  101838:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10183f:	89 c8                	mov    eax,ecx
  101841:	5d                   	pop    ebp
  101842:	c2 04 00             	ret    0x4
  101845:	66 c7 01 01 30       	mov    WORD PTR [ecx],0x3001
  10184a:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101851:	89 c8                	mov    eax,ecx
  101853:	5d                   	pop    ebp
  101854:	c2 04 00             	ret    0x4
  101857:	66 c7 01 01 2e       	mov    WORD PTR [ecx],0x2e01
  10185c:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101863:	89 c8                	mov    eax,ecx
  101865:	5d                   	pop    ebp
  101866:	c2 04 00             	ret    0x4
  101869:	66 c7 01 01 2f       	mov    WORD PTR [ecx],0x2f01
  10186e:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101875:	89 c8                	mov    eax,ecx
  101877:	5d                   	pop    ebp
  101878:	c2 04 00             	ret    0x4
  10187b:	66 c7 01 01 6c       	mov    WORD PTR [ecx],0x6c01
  101880:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101887:	89 c8                	mov    eax,ecx
  101889:	5d                   	pop    ebp
  10188a:	c2 04 00             	ret    0x4
  10188d:	66 c7 01 01 70       	mov    WORD PTR [ecx],0x7001
  101892:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101899:	89 c8                	mov    eax,ecx
  10189b:	5d                   	pop    ebp
  10189c:	c2 04 00             	ret    0x4
  10189f:	66 c7 01 01 3d       	mov    WORD PTR [ecx],0x3d01
  1018a4:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1018ab:	89 c8                	mov    eax,ecx
  1018ad:	5d                   	pop    ebp
  1018ae:	c2 04 00             	ret    0x4
  1018b1:	66 c7 01 01 0a       	mov    WORD PTR [ecx],0xa01
  1018b6:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1018bd:	89 c8                	mov    eax,ecx
  1018bf:	5d                   	pop    ebp
  1018c0:	c2 04 00             	ret    0x4
  1018c3:	66 c7 01 01 09       	mov    WORD PTR [ecx],0x901
  1018c8:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1018cf:	89 c8                	mov    eax,ecx
  1018d1:	5d                   	pop    ebp
  1018d2:	c2 04 00             	ret    0x4
  1018d5:	66 c7 01 01 71       	mov    WORD PTR [ecx],0x7101
  1018da:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1018e1:	89 c8                	mov    eax,ecx
  1018e3:	5d                   	pop    ebp
  1018e4:	c2 04 00             	ret    0x4
  1018e7:	66 c7 01 01 31       	mov    WORD PTR [ecx],0x3101
  1018ec:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1018f3:	89 c8                	mov    eax,ecx
  1018f5:	5d                   	pop    ebp
  1018f6:	c2 04 00             	ret    0x4
  1018f9:	66 c7 01 01 73       	mov    WORD PTR [ecx],0x7301
  1018fe:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101905:	89 c8                	mov    eax,ecx
  101907:	5d                   	pop    ebp
  101908:	c2 04 00             	ret    0x4
  10190b:	66 c7 01 01 61       	mov    WORD PTR [ecx],0x6101
  101910:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101917:	89 c8                	mov    eax,ecx
  101919:	5d                   	pop    ebp
  10191a:	c2 04 00             	ret    0x4
  10191d:	66 c7 01 01 77       	mov    WORD PTR [ecx],0x7701
  101922:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101929:	89 c8                	mov    eax,ecx
  10192b:	5d                   	pop    ebp
  10192c:	c2 04 00             	ret    0x4
  10192f:	66 c7 01 01 32       	mov    WORD PTR [ecx],0x3201
  101934:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10193b:	89 c8                	mov    eax,ecx
  10193d:	5d                   	pop    ebp
  10193e:	c2 04 00             	ret    0x4
  101941:	66 c7 01 01 34       	mov    WORD PTR [ecx],0x3401
  101946:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10194d:	89 c8                	mov    eax,ecx
  10194f:	5d                   	pop    ebp
  101950:	c2 04 00             	ret    0x4
  101953:	66 c7 01 01 33       	mov    WORD PTR [ecx],0x3301
  101958:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  10195f:	89 c8                	mov    eax,ecx
  101961:	5d                   	pop    ebp
  101962:	c2 04 00             	ret    0x4
  101965:	66 c7 01 01 20       	mov    WORD PTR [ecx],0x2001
  10196a:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101971:	89 c8                	mov    eax,ecx
  101973:	5d                   	pop    ebp
  101974:	c2 04 00             	ret    0x4
  101977:	66 c7 01 01 76       	mov    WORD PTR [ecx],0x7601
  10197c:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101983:	89 c8                	mov    eax,ecx
  101985:	5d                   	pop    ebp
  101986:	c2 04 00             	ret    0x4
  101989:	66 c7 01 01 72       	mov    WORD PTR [ecx],0x7201
  10198e:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101995:	89 c8                	mov    eax,ecx
  101997:	5d                   	pop    ebp
  101998:	c2 04 00             	ret    0x4
  10199b:	66 c7 01 01 79       	mov    WORD PTR [ecx],0x7901
  1019a0:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1019a7:	89 c8                	mov    eax,ecx
  1019a9:	5d                   	pop    ebp
  1019aa:	c2 04 00             	ret    0x4
  1019ad:	66 c7 01 01 36       	mov    WORD PTR [ecx],0x3601
  1019b2:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1019b9:	89 c8                	mov    eax,ecx
  1019bb:	5d                   	pop    ebp
  1019bc:	c2 04 00             	ret    0x4
  1019bf:	66 c7 01 01 75       	mov    WORD PTR [ecx],0x7501
  1019c4:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1019cb:	89 c8                	mov    eax,ecx
  1019cd:	5d                   	pop    ebp
  1019ce:	c2 04 00             	ret    0x4
  1019d1:	66 c7 01 01 38       	mov    WORD PTR [ecx],0x3801
  1019d6:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1019dd:	89 c8                	mov    eax,ecx
  1019df:	5d                   	pop    ebp
  1019e0:	c2 04 00             	ret    0x4
  1019e3:	66 c7 01 01 69       	mov    WORD PTR [ecx],0x6901
  1019e8:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  1019ef:	89 c8                	mov    eax,ecx
  1019f1:	5d                   	pop    ebp
  1019f2:	c2 04 00             	ret    0x4
  1019f5:	66 c7 01 01 6f       	mov    WORD PTR [ecx],0x6f01
  1019fa:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101a01:	89 c8                	mov    eax,ecx
  101a03:	5d                   	pop    ebp
  101a04:	c2 04 00             	ret    0x4
  101a07:	66 c7 01 01 39       	mov    WORD PTR [ecx],0x3901
  101a0c:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101a13:	89 c8                	mov    eax,ecx
  101a15:	5d                   	pop    ebp
  101a16:	c2 04 00             	ret    0x4
  101a19:	66 c7 01 01 2d       	mov    WORD PTR [ecx],0x2d01
  101a1e:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101a25:	89 c8                	mov    eax,ecx
  101a27:	5d                   	pop    ebp
  101a28:	c2 04 00             	ret    0x4
  101a2b:	66 c7 01 01 08       	mov    WORD PTR [ecx],0x801
  101a30:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101a37:	89 c8                	mov    eax,ecx
  101a39:	5d                   	pop    ebp
  101a3a:	c2 04 00             	ret    0x4
  101a3d:	c6 41 01 63          	mov    BYTE PTR [ecx+0x1],0x63
  101a41:	c7 41 04 5f 00 10 00 	mov    DWORD PTR [ecx+0x4],0x10005f
  101a48:	89 c8                	mov    eax,ecx
  101a4a:	5d                   	pop    ebp
  101a4b:	c2 04 00             	ret    0x4
  101a4e:	90                   	nop
  101a4f:	90                   	nop

00101a50 <kbd::get_line(bool)>:

auto &get_line(bool echo = true) {
  101a50:	55                   	push   ebp
  101a51:	89 e5                	mov    ebp,esp
  101a53:	53                   	push   ebx
  101a54:	57                   	push   edi
  101a55:	56                   	push   esi
  101a56:	83 e4 f8             	and    esp,0xfffffff8
  101a59:	83 ec 10             	sub    esp,0x10
  101a5c:	31 f6                	xor    esi,esi
  101a5e:	89 e7                	mov    edi,esp
    int b = 0;
    while (b < LINE_BUFFER.size() - 1) {
  101a60:	80 7d 08 00          	cmp    BYTE PTR [ebp+0x8],0x0
  101a64:	75 2a                	jne    101a90 <kbd::get_line(bool)+0x40>
  101a66:	e9 85 00 00 00       	jmp    101af0 <kbd::get_line(bool)+0xa0>
            continue;
        char a = _a.value;

        if(a==ASCII_BACKSPACE) {
            b--;
            term::Term.col-=1;
  101a6b:	ff 0d 04 60 10 00    	dec    DWORD PTR ds:0x106004
        write(s[a]);
  101a71:	6a 20                	push   0x20
  101a73:	e8 c8 f6 ff ff       	call   101140 <term::write(char)>
  101a78:	83 c4 04             	add    esp,0x4
            b--;
  101a7b:	4e                   	dec    esi
            term::write(" ");
            term::Term.col-=1;
  101a7c:	ff 0d 04 60 10 00    	dec    DWORD PTR ds:0x106004
    while (b < LINE_BUFFER.size() - 1) {
  101a82:	83 fe 4f             	cmp    esi,0x4f
  101a85:	0f 8d 97 00 00 00    	jge    101b22 <kbd::get_line(bool)+0xd2>
  101a8b:	90                   	nop
  101a8c:	90                   	nop
  101a8d:	90                   	nop
  101a8e:	90                   	nop
  101a8f:	90                   	nop
  101a90:	66 ba 64 00          	mov    dx,0x64
  101a94:	ec                   	in     al,dx
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101a95:	a8 01                	test   al,0x1
        while (!ps2::has_output_data())
  101a97:	74 f7                	je     101a90 <kbd::get_line(bool)+0x40>
        auto _a = get_ascii();
  101a99:	57                   	push   edi
  101a9a:	e8 31 fc ff ff       	call   1016d0 <kbd::get_ascii()>
    constexpr operator bool() const { return loaded_; }
  101a9f:	80 3c 24 00          	cmp    BYTE PTR [esp],0x0
        if (!_a)
  101aa3:	74 dd                	je     101a82 <kbd::get_line(bool)+0x32>
        char a = _a.value;
  101aa5:	0f b6 5c 24 01       	movzx  ebx,BYTE PTR [esp+0x1]
        if(a==ASCII_BACKSPACE) {
  101aaa:	80 fb 08             	cmp    bl,0x8
  101aad:	74 bc                	je     101a6b <kbd::get_line(bool)+0x1b>
            continue;
        }
        if (echo) {
            term::write(a);
  101aaf:	0f be c3             	movsx  eax,bl
  101ab2:	50                   	push   eax
  101ab3:	e8 88 f6 ff ff       	call   101140 <term::write(char)>
  101ab8:	83 c4 04             	add    esp,0x4
        }
        if (a == '\n')
  101abb:	80 fb 03             	cmp    bl,0x3
  101abe:	74 76                	je     101b36 <kbd::get_line(bool)+0xe6>
  101ac0:	80 fb 0a             	cmp    bl,0xa
  101ac3:	74 5d                	je     101b22 <kbd::get_line(bool)+0xd2>
            term::write('\n');
            LINE_BUFFER[0] = 0;
            return LINE_BUFFER;
        }
        
        LINE_BUFFER[b++] = a;
  101ac5:	88 9e 88 70 11 00    	mov    BYTE PTR [esi+0x117088],bl
  101acb:	46                   	inc    esi
    while (b < LINE_BUFFER.size() - 1) {
  101acc:	83 fe 4f             	cmp    esi,0x4f
  101acf:	7c bf                	jl     101a90 <kbd::get_line(bool)+0x40>
  101ad1:	eb 4f                	jmp    101b22 <kbd::get_line(bool)+0xd2>
            term::Term.col-=1;
  101ad3:	ff 0d 04 60 10 00    	dec    DWORD PTR ds:0x106004
  101ad9:	6a 20                	push   0x20
  101adb:	e8 60 f6 ff ff       	call   101140 <term::write(char)>
  101ae0:	83 c4 04             	add    esp,0x4
            b--;
  101ae3:	4e                   	dec    esi
            term::Term.col-=1;
  101ae4:	ff 0d 04 60 10 00    	dec    DWORD PTR ds:0x106004
    while (b < LINE_BUFFER.size() - 1) {
  101aea:	83 fe 4f             	cmp    esi,0x4f
  101aed:	7d 33                	jge    101b22 <kbd::get_line(bool)+0xd2>
  101aef:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  101af0:	66 ba 64 00          	mov    dx,0x64
  101af4:	ec                   	in     al,dx
bool has_output_data() { return (status() & 0b00000001) != 0; }
  101af5:	a8 01                	test   al,0x1
        while (!ps2::has_output_data())
  101af7:	74 f7                	je     101af0 <kbd::get_line(bool)+0xa0>
        auto _a = get_ascii();
  101af9:	57                   	push   edi
  101afa:	e8 d1 fb ff ff       	call   1016d0 <kbd::get_ascii()>
  101aff:	80 3c 24 00          	cmp    BYTE PTR [esp],0x0
        if (!_a)
  101b03:	74 e5                	je     101aea <kbd::get_line(bool)+0x9a>
        char a = _a.value;
  101b05:	0f b6 44 24 01       	movzx  eax,BYTE PTR [esp+0x1]
        if(a==ASCII_BACKSPACE) {
  101b0a:	3c 08                	cmp    al,0x8
  101b0c:	74 c5                	je     101ad3 <kbd::get_line(bool)+0x83>
  101b0e:	3c 03                	cmp    al,0x3
  101b10:	74 24                	je     101b36 <kbd::get_line(bool)+0xe6>
  101b12:	3c 0a                	cmp    al,0xa
  101b14:	74 0c                	je     101b22 <kbd::get_line(bool)+0xd2>
        LINE_BUFFER[b++] = a;
  101b16:	88 86 88 70 11 00    	mov    BYTE PTR [esi+0x117088],al
  101b1c:	46                   	inc    esi
    while (b < LINE_BUFFER.size() - 1) {
  101b1d:	83 fe 4f             	cmp    esi,0x4f
  101b20:	7c ce                	jl     101af0 <kbd::get_line(bool)+0xa0>
    }
    LINE_BUFFER[b] = 0;
  101b22:	c6 86 88 70 11 00 00 	mov    BYTE PTR [esi+0x117088],0x0
    return LINE_BUFFER;
}
  101b29:	b8 88 70 11 00       	mov    eax,0x117088
  101b2e:	8d 65 f4             	lea    esp,[ebp-0xc]
  101b31:	5e                   	pop    esi
  101b32:	5f                   	pop    edi
  101b33:	5b                   	pop    ebx
  101b34:	5d                   	pop    ebp
  101b35:	c3                   	ret    
        if (!flipped) {
  101b36:	80 3d 0d 60 10 00 00 	cmp    BYTE PTR ds:0x10600d,0x0
  101b3d:	74 35                	je     101b74 <kbd::get_line(bool)+0x124>
            increment_cursor(row, col, ROWS, COLS, ROWS - (row % ROWS));
  101b3f:	8b 0d 08 60 10 00    	mov    ecx,DWORD PTR ds:0x106008
  101b45:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  101b4a:	89 c8                	mov    eax,ecx
  101b4c:	f7 ea                	imul   edx
  101b4e:	89 d0                	mov    eax,edx
  101b50:	c1 e8 1f             	shr    eax,0x1f
  101b53:	c1 fa 03             	sar    edx,0x3
  101b56:	01 c2                	add    edx,eax
  101b58:	8d 04 92             	lea    eax,[edx+edx*4]
  101b5b:	8d 04 80             	lea    eax,[eax+eax*4]
  101b5e:	29 c8                	sub    eax,ecx
  101b60:	83 c0 19             	add    eax,0x19
  101b63:	b9 08 60 10 00       	mov    ecx,0x106008
  101b68:	ba 04 60 10 00       	mov    edx,0x106004
  101b6d:	50                   	push   eax
  101b6e:	6a 50                	push   0x50
  101b70:	6a 19                	push   0x19
  101b72:	eb 33                	jmp    101ba7 <kbd::get_line(bool)+0x157>
            increment_cursor(col, row, COLS, ROWS, COLS - (col % COLS));
  101b74:	8b 0d 04 60 10 00    	mov    ecx,DWORD PTR ds:0x106004
  101b7a:	ba 67 66 66 66       	mov    edx,0x66666667
  101b7f:	89 c8                	mov    eax,ecx
  101b81:	f7 ea                	imul   edx
  101b83:	89 d0                	mov    eax,edx
  101b85:	c1 e8 1f             	shr    eax,0x1f
  101b88:	c1 fa 05             	sar    edx,0x5
  101b8b:	01 c2                	add    edx,eax
  101b8d:	c1 e2 04             	shl    edx,0x4
  101b90:	8d 04 92             	lea    eax,[edx+edx*4]
  101b93:	29 c8                	sub    eax,ecx
  101b95:	83 c0 50             	add    eax,0x50
  101b98:	b9 04 60 10 00       	mov    ecx,0x106004
  101b9d:	ba 08 60 10 00       	mov    edx,0x106008
  101ba2:	50                   	push   eax
  101ba3:	6a 19                	push   0x19
  101ba5:	6a 50                	push   0x50
  101ba7:	e8 f4 1d 00 00       	call   1039a0 <term::$_0::increment_cursor(int&, int&, int, int, int)>
  101bac:	83 c4 0c             	add    esp,0xc
            LINE_BUFFER[0] = 0;
  101baf:	c6 05 88 70 11 00 00 	mov    BYTE PTR ds:0x117088,0x0
  101bb6:	e9 6e ff ff ff       	jmp    101b29 <kbd::get_line(bool)+0xd9>
  101bbb:	90                   	nop
  101bbc:	90                   	nop
  101bbd:	90                   	nop
  101bbe:	90                   	nop
  101bbf:	90                   	nop

00101bc0 <time::delay(int)>:

/**
 * Spin the CPU for a given number of "moments".
 * (One "moment" is 2^16 AND operations.)
 */
void delay(int amount = 1) {
  101bc0:	55                   	push   ebp
  101bc1:	89 e5                	mov    ebp,esp
  101bc3:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
    for (int a = 0; a < (1 << 16) * amount; a++) {
  101bc6:	85 c0                	test   eax,eax
  101bc8:	7e 0d                	jle    101bd7 <time::delay(int)+0x17>
  101bca:	c1 e0 10             	shl    eax,0x10
  101bcd:	31 c9                	xor    ecx,ecx
  101bcf:	90                   	nop
        asm volatile ("and %eax,%eax");
  101bd0:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  101bd2:	41                   	inc    ecx
  101bd3:	39 c1                	cmp    ecx,eax
  101bd5:	7c f9                	jl     101bd0 <time::delay(int)+0x10>
    }
}
  101bd7:	5d                   	pop    ebp
  101bd8:	c3                   	ret    
  101bd9:	90                   	nop
  101bda:	90                   	nop
  101bdb:	90                   	nop
  101bdc:	90                   	nop
  101bdd:	90                   	nop
  101bde:	90                   	nop
  101bdf:	90                   	nop

00101be0 <kernel_main>:
        f_();
        term::write("Runner ended\n");
    }
};

extern "C" void kernel_main(multiboot_info_t *mb, uint32 magic, uint32 seed) {
  101be0:	55                   	push   ebp
  101be1:	89 e5                	mov    ebp,esp
  101be3:	53                   	push   ebx
  101be4:	57                   	push   edi
  101be5:	56                   	push   esi
  101be6:	83 e4 f8             	and    esp,0xfffffff8
  101be9:	81 ec e0 0c 00 00    	sub    esp,0xce0
  101bef:	8b 5d 0c             	mov    ebx,DWORD PTR [ebp+0xc]
    term::clear();
  101bf2:	e8 59 f4 ff ff       	call   101050 <term::clear()>
    constexpr array() : data_{T()} {}
  101bf7:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  101bfe:	00 00 00 00 
  101c02:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  101c09:	00 00 00 00 
  101c0d:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  101c14:	00 00 00 00 
  101c18:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  101c1f:	00 00 00 00 
  101c23:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  101c2a:	00 00 00 00 
  101c2e:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  101c35:	00 00 00 00 
  101c39:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  101c40:	00 00 00 00 
  101c44:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  101c4b:	00 00 00 00 
    int index_ = 0;
  101c4f:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  101c56:	00 00 00 00 
    if (x == 0)
  101c5a:	85 db                	test   ebx,ebx
  101c5c:	74 76                	je     101cd4 <kernel_main+0xf4>
    for (; x > 0; a++) {
  101c5e:	8d 84 24 0f 03 00 00 	lea    eax,[esp+0x30f]
  101c65:	31 f6                	xor    esi,esi
  101c67:	90                   	nop
  101c68:	90                   	nop
  101c69:	90                   	nop
  101c6a:	90                   	nop
  101c6b:	90                   	nop
  101c6c:	90                   	nop
  101c6d:	90                   	nop
  101c6e:	90                   	nop
  101c6f:	90                   	nop
        if ((x % B) < 10)
  101c70:	89 da                	mov    edx,ebx
  101c72:	83 e2 0f             	and    edx,0xf
  101c75:	89 d1                	mov    ecx,edx
  101c77:	80 c9 30             	or     cl,0x30
  101c7a:	88 dd                	mov    ch,bl
  101c7c:	80 c5 06             	add    ch,0x6
  101c7f:	80 e5 0f             	and    ch,0xf
  101c82:	80 c5 41             	add    ch,0x41
  101c85:	83 fa 0a             	cmp    edx,0xa
  101c88:	0f b6 d1             	movzx  edx,cl
  101c8b:	0f b6 cd             	movzx  ecx,ch
  101c8e:	0f 42 ca             	cmovb  ecx,edx
        r[a] = i2c(x);
  101c91:	88 48 01             	mov    BYTE PTR [eax+0x1],cl
  101c94:	40                   	inc    eax
        x /= B;
  101c95:	c1 eb 04             	shr    ebx,0x4
    for (; x > 0; a++) {
  101c98:	46                   	inc    esi
  101c99:	85 db                	test   ebx,ebx
  101c9b:	75 d3                	jne    101c70 <kernel_main+0x90>
    r[a] = 0;
  101c9d:	c6 40 01 00          	mov    BYTE PTR [eax+0x1],0x0
    for (auto b = 0; b < a / 2; b++) {
  101ca1:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  101ca7:	74 35                	je     101cde <kernel_main+0xfe>
  101ca9:	d1 ee                	shr    esi,1
  101cab:	8d 94 24 10 03 00 00 	lea    edx,[esp+0x310]
  101cb2:	90                   	nop
  101cb3:	90                   	nop
  101cb4:	90                   	nop
  101cb5:	90                   	nop
  101cb6:	90                   	nop
  101cb7:	90                   	nop
  101cb8:	90                   	nop
  101cb9:	90                   	nop
  101cba:	90                   	nop
  101cbb:	90                   	nop
  101cbc:	90                   	nop
  101cbd:	90                   	nop
  101cbe:	90                   	nop
  101cbf:	90                   	nop
        r[b] ^= r[a - b - 1];
  101cc0:	0f b6 0a             	movzx  ecx,BYTE PTR [edx]
  101cc3:	32 08                	xor    cl,BYTE PTR [eax]
  101cc5:	88 0a                	mov    BYTE PTR [edx],cl
        r[a - b - 1] ^= r[b];
  101cc7:	32 08                	xor    cl,BYTE PTR [eax]
  101cc9:	88 08                	mov    BYTE PTR [eax],cl
        r[b] ^= r[a - b - 1];
  101ccb:	30 0a                	xor    BYTE PTR [edx],cl
    for (auto b = 0; b < a / 2; b++) {
  101ccd:	42                   	inc    edx
  101cce:	48                   	dec    eax
  101ccf:	4e                   	dec    esi
  101cd0:	75 ee                	jne    101cc0 <kernel_main+0xe0>
  101cd2:	eb 0a                	jmp    101cde <kernel_main+0xfe>
        r[a++] = '0';
  101cd4:	66 c7 84 24 10 03 00 	mov    WORD PTR [esp+0x310],0x30
  101cdb:	00 30 00 
  101cde:	8d bc 24 10 01 00 00 	lea    edi,[esp+0x110]
  101ce5:	8d b4 24 10 03 00 00 	lea    esi,[esp+0x310]
    return r;
  101cec:	b9 09 00 00 00       	mov    ecx,0x9
  101cf1:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
        write(s[a]);
  101cf3:	6a 4c                	push   0x4c
  101cf5:	e8 46 f4 ff ff       	call   101140 <term::write(char)>
  101cfa:	83 c4 04             	add    esp,0x4
  101cfd:	6a 6f                	push   0x6f
  101cff:	e8 3c f4 ff ff       	call   101140 <term::write(char)>
  101d04:	83 c4 04             	add    esp,0x4
  101d07:	6a 61                	push   0x61
  101d09:	e8 32 f4 ff ff       	call   101140 <term::write(char)>
  101d0e:	83 c4 04             	add    esp,0x4
  101d11:	6a 64                	push   0x64
  101d13:	e8 28 f4 ff ff       	call   101140 <term::write(char)>
  101d18:	83 c4 04             	add    esp,0x4
  101d1b:	6a 65                	push   0x65
  101d1d:	e8 1e f4 ff ff       	call   101140 <term::write(char)>
  101d22:	83 c4 04             	add    esp,0x4
  101d25:	6a 64                	push   0x64
  101d27:	e8 14 f4 ff ff       	call   101140 <term::write(char)>
  101d2c:	83 c4 04             	add    esp,0x4
  101d2f:	6a 20                	push   0x20
  101d31:	e8 0a f4 ff ff       	call   101140 <term::write(char)>
  101d36:	83 c4 04             	add    esp,0x4
  101d39:	6a 47                	push   0x47
  101d3b:	e8 00 f4 ff ff       	call   101140 <term::write(char)>
  101d40:	83 c4 04             	add    esp,0x4
  101d43:	6a 52                	push   0x52
  101d45:	e8 f6 f3 ff ff       	call   101140 <term::write(char)>
  101d4a:	83 c4 04             	add    esp,0x4
  101d4d:	6a 55                	push   0x55
  101d4f:	e8 ec f3 ff ff       	call   101140 <term::write(char)>
  101d54:	83 c4 04             	add    esp,0x4
  101d57:	6a 42                	push   0x42
  101d59:	e8 e2 f3 ff ff       	call   101140 <term::write(char)>
  101d5e:	83 c4 04             	add    esp,0x4
  101d61:	6a 20                	push   0x20
  101d63:	e8 d8 f3 ff ff       	call   101140 <term::write(char)>
  101d68:	83 c4 04             	add    esp,0x4
  101d6b:	6a 69                	push   0x69
  101d6d:	e8 ce f3 ff ff       	call   101140 <term::write(char)>
  101d72:	83 c4 04             	add    esp,0x4
  101d75:	6a 6e                	push   0x6e
  101d77:	e8 c4 f3 ff ff       	call   101140 <term::write(char)>
  101d7c:	83 c4 04             	add    esp,0x4
  101d7f:	6a 66                	push   0x66
  101d81:	e8 ba f3 ff ff       	call   101140 <term::write(char)>
  101d86:	83 c4 04             	add    esp,0x4
  101d89:	6a 6f                	push   0x6f
  101d8b:	e8 b0 f3 ff ff       	call   101140 <term::write(char)>
  101d90:	83 c4 04             	add    esp,0x4
  101d93:	6a 3a                	push   0x3a
  101d95:	e8 a6 f3 ff ff       	call   101140 <term::write(char)>
  101d9a:	83 c4 04             	add    esp,0x4
  101d9d:	6a 20                	push   0x20
  101d9f:	e8 9c f3 ff ff       	call   101140 <term::write(char)>
  101da4:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  101da7:	8a 84 24 10 01 00 00 	mov    al,BYTE PTR [esp+0x110]
  101dae:	84 c0                	test   al,al
  101db0:	74 22                	je     101dd4 <kernel_main+0x1f4>
  101db2:	8d b4 24 11 01 00 00 	lea    esi,[esp+0x111]
  101db9:	90                   	nop
  101dba:	90                   	nop
  101dbb:	90                   	nop
  101dbc:	90                   	nop
  101dbd:	90                   	nop
  101dbe:	90                   	nop
  101dbf:	90                   	nop
        write(s[a]);
  101dc0:	0f be c0             	movsx  eax,al
  101dc3:	50                   	push   eax
  101dc4:	e8 77 f3 ff ff       	call   101140 <term::write(char)>
  101dc9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  101dcc:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  101dcf:	46                   	inc    esi
  101dd0:	84 c0                	test   al,al
  101dd2:	75 ec                	jne    101dc0 <kernel_main+0x1e0>
        write(s[a]);
  101dd4:	6a 0a                	push   0xa
  101dd6:	e8 65 f3 ff ff       	call   101140 <term::write(char)>
  101ddb:	83 c4 04             	add    esp,0x4
  101dde:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
    int count_;

  public:
    module_list(multiboot_info_t const &mb)
        : addr_(reinterpret_cast<multiboot_module_t *>(mb.mods_addr)),
          count_(static_cast<int>(mb.mods_count)) {}
  101de1:	8b 48 14             	mov    ecx,DWORD PTR [eax+0x14]
        : addr_(reinterpret_cast<multiboot_module_t *>(mb.mods_addr)),
  101de4:	8b 40 18             	mov    eax,DWORD PTR [eax+0x18]
  101de7:	89 44 24 10          	mov    DWORD PTR [esp+0x10],eax
  101deb:	89 4c 24 08          	mov    DWORD PTR [esp+0x8],ecx
    term::write("Loaded GRUB info: ", int_to_string<16>(magic).str(), "\n");

    mod::module_list mods(*mb);
    if (mods.size() > 0) {
  101def:	85 c9                	test   ecx,ecx
  101df1:	0f 8e d2 05 00 00    	jle    1023c9 <kernel_main+0x7e9>
    constexpr array() : data_{T()} {}
  101df7:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  101dfe:	00 00 00 00 
  101e02:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  101e09:	00 00 00 00 
  101e0d:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  101e14:	00 00 00 00 
  101e18:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  101e1f:	00 00 00 00 
  101e23:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  101e2a:	00 00 00 00 
  101e2e:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  101e35:	00 00 00 00 
  101e39:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  101e40:	00 00 00 00 
  101e44:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  101e4b:	00 00 00 00 
    int index_ = 0;
  101e4f:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  101e56:	00 00 00 00 
    for (; x > 0; a++) {
  101e5a:	8d b4 24 0f 03 00 00 	lea    esi,[esp+0x30f]
  101e61:	31 ff                	xor    edi,edi
  101e63:	8b 5c 24 08          	mov    ebx,DWORD PTR [esp+0x8]
  101e67:	90                   	nop
  101e68:	90                   	nop
  101e69:	90                   	nop
  101e6a:	90                   	nop
  101e6b:	90                   	nop
  101e6c:	90                   	nop
  101e6d:	90                   	nop
  101e6e:	90                   	nop
  101e6f:	90                   	nop
        x /= B;
  101e70:	89 d8                	mov    eax,ebx
  101e72:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  101e77:	f7 e1                	mul    ecx
  101e79:	c1 ea 03             	shr    edx,0x3
  101e7c:	8d 04 12             	lea    eax,[edx+edx*1]
  101e7f:	8d 04 80             	lea    eax,[eax+eax*4]
  101e82:	89 d9                	mov    ecx,ebx
  101e84:	29 c1                	sub    ecx,eax
            return '0' + (x % B);
  101e86:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  101e89:	88 4e 01             	mov    BYTE PTR [esi+0x1],cl
  101e8c:	46                   	inc    esi
    for (; x > 0; a++) {
  101e8d:	47                   	inc    edi
  101e8e:	83 fb 09             	cmp    ebx,0x9
  101e91:	89 d3                	mov    ebx,edx
  101e93:	77 db                	ja     101e70 <kernel_main+0x290>
    r[a] = 0;
  101e95:	c6 46 01 00          	mov    BYTE PTR [esi+0x1],0x0
    for (auto b = 0; b < a / 2; b++) {
  101e99:	f7 c7 fe ff ff ff    	test   edi,0xfffffffe
  101e9f:	74 21                	je     101ec2 <kernel_main+0x2e2>
  101ea1:	d1 ef                	shr    edi,1
  101ea3:	8d 84 24 10 03 00 00 	lea    eax,[esp+0x310]
  101eaa:	90                   	nop
  101eab:	90                   	nop
  101eac:	90                   	nop
  101ead:	90                   	nop
  101eae:	90                   	nop
  101eaf:	90                   	nop
        r[b] ^= r[a - b - 1];
  101eb0:	0f b6 08             	movzx  ecx,BYTE PTR [eax]
  101eb3:	32 0e                	xor    cl,BYTE PTR [esi]
  101eb5:	88 08                	mov    BYTE PTR [eax],cl
        r[a - b - 1] ^= r[b];
  101eb7:	32 0e                	xor    cl,BYTE PTR [esi]
  101eb9:	88 0e                	mov    BYTE PTR [esi],cl
        r[b] ^= r[a - b - 1];
  101ebb:	30 08                	xor    BYTE PTR [eax],cl
    for (auto b = 0; b < a / 2; b++) {
  101ebd:	40                   	inc    eax
  101ebe:	4e                   	dec    esi
  101ebf:	4f                   	dec    edi
  101ec0:	75 ee                	jne    101eb0 <kernel_main+0x2d0>
  101ec2:	8d bc 24 10 01 00 00 	lea    edi,[esp+0x110]
  101ec9:	8d 9c 24 10 03 00 00 	lea    ebx,[esp+0x310]
    return r;
  101ed0:	b9 09 00 00 00       	mov    ecx,0x9
  101ed5:	89 de                	mov    esi,ebx
  101ed7:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  101ed9:	6a 4c                	push   0x4c
  101edb:	e8 60 f2 ff ff       	call   101140 <term::write(char)>
  101ee0:	83 c4 04             	add    esp,0x4
  101ee3:	6a 6f                	push   0x6f
  101ee5:	e8 56 f2 ff ff       	call   101140 <term::write(char)>
  101eea:	83 c4 04             	add    esp,0x4
  101eed:	6a 61                	push   0x61
  101eef:	e8 4c f2 ff ff       	call   101140 <term::write(char)>
  101ef4:	83 c4 04             	add    esp,0x4
  101ef7:	6a 64                	push   0x64
  101ef9:	e8 42 f2 ff ff       	call   101140 <term::write(char)>
  101efe:	83 c4 04             	add    esp,0x4
  101f01:	6a 65                	push   0x65
  101f03:	e8 38 f2 ff ff       	call   101140 <term::write(char)>
  101f08:	83 c4 04             	add    esp,0x4
  101f0b:	6a 64                	push   0x64
  101f0d:	e8 2e f2 ff ff       	call   101140 <term::write(char)>
  101f12:	83 c4 04             	add    esp,0x4
  101f15:	6a 20                	push   0x20
  101f17:	e8 24 f2 ff ff       	call   101140 <term::write(char)>
  101f1c:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  101f1f:	8a 84 24 10 01 00 00 	mov    al,BYTE PTR [esp+0x110]
  101f26:	84 c0                	test   al,al
  101f28:	74 2a                	je     101f54 <kernel_main+0x374>
  101f2a:	8d b4 24 11 01 00 00 	lea    esi,[esp+0x111]
  101f31:	90                   	nop
  101f32:	90                   	nop
  101f33:	90                   	nop
  101f34:	90                   	nop
  101f35:	90                   	nop
  101f36:	90                   	nop
  101f37:	90                   	nop
  101f38:	90                   	nop
  101f39:	90                   	nop
  101f3a:	90                   	nop
  101f3b:	90                   	nop
  101f3c:	90                   	nop
  101f3d:	90                   	nop
  101f3e:	90                   	nop
  101f3f:	90                   	nop
        write(s[a]);
  101f40:	0f be c0             	movsx  eax,al
  101f43:	50                   	push   eax
  101f44:	e8 f7 f1 ff ff       	call   101140 <term::write(char)>
  101f49:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  101f4c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  101f4f:	46                   	inc    esi
  101f50:	84 c0                	test   al,al
  101f52:	75 ec                	jne    101f40 <kernel_main+0x360>
        write(s[a]);
  101f54:	6a 20                	push   0x20
  101f56:	e8 e5 f1 ff ff       	call   101140 <term::write(char)>
  101f5b:	83 c4 04             	add    esp,0x4
  101f5e:	6a 6d                	push   0x6d
  101f60:	e8 db f1 ff ff       	call   101140 <term::write(char)>
  101f65:	83 c4 04             	add    esp,0x4
  101f68:	6a 6f                	push   0x6f
  101f6a:	e8 d1 f1 ff ff       	call   101140 <term::write(char)>
  101f6f:	83 c4 04             	add    esp,0x4
  101f72:	6a 64                	push   0x64
  101f74:	e8 c7 f1 ff ff       	call   101140 <term::write(char)>
  101f79:	83 c4 04             	add    esp,0x4
  101f7c:	6a 75                	push   0x75
  101f7e:	e8 bd f1 ff ff       	call   101140 <term::write(char)>
  101f83:	83 c4 04             	add    esp,0x4
  101f86:	6a 6c                	push   0x6c
  101f88:	e8 b3 f1 ff ff       	call   101140 <term::write(char)>
  101f8d:	83 c4 04             	add    esp,0x4
  101f90:	6a 65                	push   0x65
  101f92:	e8 a9 f1 ff ff       	call   101140 <term::write(char)>
  101f97:	83 c4 04             	add    esp,0x4
  101f9a:	6a 73                	push   0x73
  101f9c:	e8 9f f1 ff ff       	call   101140 <term::write(char)>
  101fa1:	83 c4 04             	add    esp,0x4
  101fa4:	6a 0a                	push   0xa
  101fa6:	e8 95 f1 ff ff       	call   101140 <term::write(char)>
  101fab:	83 c4 04             	add    esp,0x4
        return ptr_ != p.ptr_;
  101fae:	83 7c 24 08 00       	cmp    DWORD PTR [esp+0x8],0x0
        term::write("Loaded ", int_to_string(mods.size()).str(), " modules\n");
        for (auto &&a : mods) {
  101fb3:	0f 84 10 04 00 00    	je     1023c9 <kernel_main+0x7e9>
  101fb9:	8b 4c 24 08          	mov    ecx,DWORD PTR [esp+0x8]
  101fbd:	c1 e1 04             	shl    ecx,0x4
  101fc0:	8b 44 24 10          	mov    eax,DWORD PTR [esp+0x10]
  101fc4:	01 c1                	add    ecx,eax
  101fc6:	89 4c 24 14          	mov    DWORD PTR [esp+0x14],ecx
  101fca:	31 c9                	xor    ecx,ecx
  101fcc:	eb 22                	jmp    101ff0 <kernel_main+0x410>
  101fce:	90                   	nop
  101fcf:	90                   	nop
  101fd0:	6a 0a                	push   0xa
  101fd2:	e8 69 f1 ff ff       	call   101140 <term::write(char)>
  101fd7:	83 c4 04             	add    esp,0x4
  101fda:	8b 4c 24 0c          	mov    ecx,DWORD PTR [esp+0xc]
        index_++;
  101fde:	41                   	inc    ecx
  101fdf:	8b 44 24 24          	mov    eax,DWORD PTR [esp+0x24]
        ptr_++;
  101fe3:	83 c0 10             	add    eax,0x10
        return ptr_ != p.ptr_;
  101fe6:	39 44 24 14          	cmp    DWORD PTR [esp+0x14],eax
  101fea:	0f 84 d9 03 00 00    	je     1023c9 <kernel_main+0x7e9>
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  101ff0:	8b 10                	mov    edx,DWORD PTR [eax]
  101ff2:	89 54 24 18          	mov    DWORD PTR [esp+0x18],edx
  101ff6:	8b 50 04             	mov    edx,DWORD PTR [eax+0x4]
  101ff9:	89 54 24 1c          	mov    DWORD PTR [esp+0x1c],edx
  101ffd:	89 44 24 24          	mov    DWORD PTR [esp+0x24],eax
  102001:	8b 40 08             	mov    eax,DWORD PTR [eax+0x8]
  102004:	89 44 24 20          	mov    DWORD PTR [esp+0x20],eax
    constexpr array() : data_{T()} {}
  102008:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  10200f:	00 00 00 00 
  102013:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  10201a:	00 00 00 00 
  10201e:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  102025:	00 00 00 00 
  102029:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  102030:	00 00 00 00 
  102034:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  10203b:	00 00 00 00 
  10203f:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  102046:	00 00 00 00 
  10204a:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  102051:	00 00 00 00 
  102055:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  10205c:	00 00 00 00 
    int index_ = 0;
  102060:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  102067:	00 00 00 00 
    if (x == 0)
  10206b:	85 c9                	test   ecx,ecx
  10206d:	89 4c 24 0c          	mov    DWORD PTR [esp+0xc],ecx
  102071:	0f 84 99 00 00 00    	je     102110 <kernel_main+0x530>
  102077:	31 ff                	xor    edi,edi
  102079:	c7 04 24 01 00 00 00 	mov    DWORD PTR [esp],0x1
  102080:	89 5c 24 04          	mov    DWORD PTR [esp+0x4],ebx
  102084:	89 cb                	mov    ebx,ecx
  102086:	90                   	nop
  102087:	90                   	nop
  102088:	90                   	nop
  102089:	90                   	nop
  10208a:	90                   	nop
  10208b:	90                   	nop
  10208c:	90                   	nop
  10208d:	90                   	nop
  10208e:	90                   	nop
  10208f:	90                   	nop
        x /= B;
  102090:	89 d8                	mov    eax,ebx
  102092:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  102097:	f7 e1                	mul    ecx
  102099:	c1 ea 03             	shr    edx,0x3
  10209c:	8d 04 12             	lea    eax,[edx+edx*1]
  10209f:	8d 04 80             	lea    eax,[eax+eax*4]
  1020a2:	89 d9                	mov    ecx,ebx
  1020a4:	29 c1                	sub    ecx,eax
  1020a6:	8b 04 24             	mov    eax,DWORD PTR [esp]
  1020a9:	8b 74 24 04          	mov    esi,DWORD PTR [esp+0x4]
            return '0' + (x % B);
  1020ad:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  1020b0:	88 8c 3c 10 03 00 00 	mov    BYTE PTR [esp+edi*1+0x310],cl
    for (; x > 0; a++) {
  1020b7:	47                   	inc    edi
  1020b8:	8d 48 01             	lea    ecx,[eax+0x1]
  1020bb:	89 0c 24             	mov    DWORD PTR [esp],ecx
  1020be:	83 fb 09             	cmp    ebx,0x9
  1020c1:	8d 4e 01             	lea    ecx,[esi+0x1]
  1020c4:	89 4c 24 04          	mov    DWORD PTR [esp+0x4],ecx
  1020c8:	89 d3                	mov    ebx,edx
  1020ca:	77 c4                	ja     102090 <kernel_main+0x4b0>
    r[a] = 0;
  1020cc:	c6 84 3c 10 03 00 00 	mov    BYTE PTR [esp+edi*1+0x310],0x0
  1020d3:	00 
    for (auto b = 0; b < a / 2; b++) {
  1020d4:	f7 c7 fe ff ff ff    	test   edi,0xfffffffe
  1020da:	8d 9c 24 10 03 00 00 	lea    ebx,[esp+0x310]
  1020e1:	74 37                	je     10211a <kernel_main+0x53a>
  1020e3:	d1 e8                	shr    eax,1
  1020e5:	89 d9                	mov    ecx,ebx
  1020e7:	90                   	nop
  1020e8:	90                   	nop
  1020e9:	90                   	nop
  1020ea:	90                   	nop
  1020eb:	90                   	nop
  1020ec:	90                   	nop
  1020ed:	90                   	nop
  1020ee:	90                   	nop
  1020ef:	90                   	nop
        r[b] ^= r[a - b - 1];
  1020f0:	0f b6 11             	movzx  edx,BYTE PTR [ecx]
  1020f3:	32 16                	xor    dl,BYTE PTR [esi]
  1020f5:	88 11                	mov    BYTE PTR [ecx],dl
        r[a - b - 1] ^= r[b];
  1020f7:	32 16                	xor    dl,BYTE PTR [esi]
  1020f9:	88 16                	mov    BYTE PTR [esi],dl
        r[b] ^= r[a - b - 1];
  1020fb:	30 11                	xor    BYTE PTR [ecx],dl
    for (auto b = 0; b < a / 2; b++) {
  1020fd:	41                   	inc    ecx
  1020fe:	4e                   	dec    esi
  1020ff:	48                   	dec    eax
  102100:	75 ee                	jne    1020f0 <kernel_main+0x510>
  102102:	eb 16                	jmp    10211a <kernel_main+0x53a>
  102104:	90                   	nop
  102105:	90                   	nop
  102106:	90                   	nop
  102107:	90                   	nop
  102108:	90                   	nop
  102109:	90                   	nop
  10210a:	90                   	nop
  10210b:	90                   	nop
  10210c:	90                   	nop
  10210d:	90                   	nop
  10210e:	90                   	nop
  10210f:	90                   	nop
        r[a++] = '0';
  102110:	66 c7 84 24 10 03 00 	mov    WORD PTR [esp+0x310],0x30
  102117:	00 30 00 
    return r;
  10211a:	b9 09 00 00 00       	mov    ecx,0x9
  10211f:	8d bc 24 10 01 00 00 	lea    edi,[esp+0x110]
  102126:	89 de                	mov    esi,ebx
  102128:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
    constexpr array() : data_{T()} {}
  10212a:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  102131:	00 00 00 00 
  102135:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  10213c:	00 00 00 00 
  102140:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  102147:	00 00 00 00 
  10214b:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  102152:	00 00 00 00 
  102156:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  10215d:	00 00 00 00 
  102161:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  102168:	00 00 00 00 
  10216c:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  102173:	00 00 00 00 
  102177:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  10217e:	00 00 00 00 
    int index_ = 0;
  102182:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  102189:	00 00 00 00 
  10218d:	8b 4c 24 18          	mov    ecx,DWORD PTR [esp+0x18]
    if (x == 0)
  102191:	85 c9                	test   ecx,ecx
  102193:	0f 84 97 00 00 00    	je     102230 <kernel_main+0x650>
  102199:	31 f6                	xor    esi,esi
  10219b:	b8 01 00 00 00       	mov    eax,0x1
  1021a0:	89 df                	mov    edi,ebx
  1021a2:	89 cb                	mov    ebx,ecx
  1021a4:	90                   	nop
  1021a5:	90                   	nop
  1021a6:	90                   	nop
  1021a7:	90                   	nop
  1021a8:	90                   	nop
  1021a9:	90                   	nop
  1021aa:	90                   	nop
  1021ab:	90                   	nop
  1021ac:	90                   	nop
  1021ad:	90                   	nop
  1021ae:	90                   	nop
  1021af:	90                   	nop
  1021b0:	89 04 24             	mov    DWORD PTR [esp],eax
  1021b3:	89 f9                	mov    ecx,edi
        if ((x % B) < 10)
  1021b5:	89 da                	mov    edx,ebx
  1021b7:	83 e2 0f             	and    edx,0xf
  1021ba:	89 d0                	mov    eax,edx
  1021bc:	0c 30                	or     al,0x30
  1021be:	88 dc                	mov    ah,bl
  1021c0:	80 c4 06             	add    ah,0x6
  1021c3:	80 e4 0f             	and    ah,0xf
  1021c6:	80 c4 41             	add    ah,0x41
  1021c9:	83 fa 0a             	cmp    edx,0xa
  1021cc:	0f b6 d0             	movzx  edx,al
  1021cf:	0f b6 c4             	movzx  eax,ah
  1021d2:	0f 42 c2             	cmovb  eax,edx
  1021d5:	8b 14 24             	mov    edx,DWORD PTR [esp]
        r[a] = i2c(x);
  1021d8:	88 84 34 10 03 00 00 	mov    BYTE PTR [esp+esi*1+0x310],al
        x /= B;
  1021df:	c1 eb 04             	shr    ebx,0x4
    for (; x > 0; a++) {
  1021e2:	46                   	inc    esi
  1021e3:	8d 42 01             	lea    eax,[edx+0x1]
  1021e6:	47                   	inc    edi
  1021e7:	85 db                	test   ebx,ebx
  1021e9:	75 c5                	jne    1021b0 <kernel_main+0x5d0>
    r[a] = 0;
  1021eb:	c6 84 34 10 03 00 00 	mov    BYTE PTR [esp+esi*1+0x310],0x0
  1021f2:	00 
    for (auto b = 0; b < a / 2; b++) {
  1021f3:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  1021f9:	8d 9c 24 10 03 00 00 	lea    ebx,[esp+0x310]
  102200:	74 38                	je     10223a <kernel_main+0x65a>
  102202:	89 d6                	mov    esi,edx
  102204:	d1 ee                	shr    esi,1
  102206:	89 da                	mov    edx,ebx
  102208:	90                   	nop
  102209:	90                   	nop
  10220a:	90                   	nop
  10220b:	90                   	nop
  10220c:	90                   	nop
  10220d:	90                   	nop
  10220e:	90                   	nop
  10220f:	90                   	nop
        r[b] ^= r[a - b - 1];
  102210:	0f b6 02             	movzx  eax,BYTE PTR [edx]
  102213:	32 01                	xor    al,BYTE PTR [ecx]
  102215:	88 02                	mov    BYTE PTR [edx],al
        r[a - b - 1] ^= r[b];
  102217:	32 01                	xor    al,BYTE PTR [ecx]
  102219:	88 01                	mov    BYTE PTR [ecx],al
        r[b] ^= r[a - b - 1];
  10221b:	30 02                	xor    BYTE PTR [edx],al
    for (auto b = 0; b < a / 2; b++) {
  10221d:	42                   	inc    edx
  10221e:	49                   	dec    ecx
  10221f:	4e                   	dec    esi
  102220:	75 ee                	jne    102210 <kernel_main+0x630>
  102222:	eb 16                	jmp    10223a <kernel_main+0x65a>
  102224:	90                   	nop
  102225:	90                   	nop
  102226:	90                   	nop
  102227:	90                   	nop
  102228:	90                   	nop
  102229:	90                   	nop
  10222a:	90                   	nop
  10222b:	90                   	nop
  10222c:	90                   	nop
  10222d:	90                   	nop
  10222e:	90                   	nop
  10222f:	90                   	nop
        r[a++] = '0';
  102230:	66 c7 84 24 10 03 00 	mov    WORD PTR [esp+0x310],0x30
  102237:	00 30 00 
    return r;
  10223a:	b9 09 00 00 00       	mov    ecx,0x9
  10223f:	8d 7c 24 28          	lea    edi,[esp+0x28]
  102243:	89 de                	mov    esi,ebx
  102245:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
    constexpr array() : data_{T()} {}
  102247:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  10224e:	00 00 00 00 
  102252:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  102259:	00 00 00 00 
  10225d:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  102264:	00 00 00 00 
  102268:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  10226f:	00 00 00 00 
  102273:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  10227a:	00 00 00 00 
  10227e:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  102285:	00 00 00 00 
  102289:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  102290:	00 00 00 00 
  102294:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  10229b:	00 00 00 00 
    int index_ = 0;
  10229f:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  1022a6:	00 00 00 00 
  1022aa:	8b 4c 24 1c          	mov    ecx,DWORD PTR [esp+0x1c]
    if (x == 0)
  1022ae:	85 c9                	test   ecx,ecx
  1022b0:	0f 84 9a 00 00 00    	je     102350 <kernel_main+0x770>
  1022b6:	31 f6                	xor    esi,esi
  1022b8:	b8 01 00 00 00       	mov    eax,0x1
  1022bd:	89 df                	mov    edi,ebx
  1022bf:	89 cb                	mov    ebx,ecx
  1022c1:	90                   	nop
  1022c2:	90                   	nop
  1022c3:	90                   	nop
  1022c4:	90                   	nop
  1022c5:	90                   	nop
  1022c6:	90                   	nop
  1022c7:	90                   	nop
  1022c8:	90                   	nop
  1022c9:	90                   	nop
  1022ca:	90                   	nop
  1022cb:	90                   	nop
  1022cc:	90                   	nop
  1022cd:	90                   	nop
  1022ce:	90                   	nop
  1022cf:	90                   	nop
  1022d0:	89 04 24             	mov    DWORD PTR [esp],eax
  1022d3:	89 f9                	mov    ecx,edi
        if ((x % B) < 10)
  1022d5:	89 da                	mov    edx,ebx
  1022d7:	83 e2 0f             	and    edx,0xf
  1022da:	89 d0                	mov    eax,edx
  1022dc:	0c 30                	or     al,0x30
  1022de:	88 dc                	mov    ah,bl
  1022e0:	80 c4 06             	add    ah,0x6
  1022e3:	80 e4 0f             	and    ah,0xf
  1022e6:	80 c4 41             	add    ah,0x41
  1022e9:	83 fa 0a             	cmp    edx,0xa
  1022ec:	0f b6 d0             	movzx  edx,al
  1022ef:	0f b6 c4             	movzx  eax,ah
  1022f2:	0f 42 c2             	cmovb  eax,edx
  1022f5:	8b 14 24             	mov    edx,DWORD PTR [esp]
        r[a] = i2c(x);
  1022f8:	88 84 34 10 03 00 00 	mov    BYTE PTR [esp+esi*1+0x310],al
        x /= B;
  1022ff:	c1 eb 04             	shr    ebx,0x4
    for (; x > 0; a++) {
  102302:	46                   	inc    esi
  102303:	8d 42 01             	lea    eax,[edx+0x1]
  102306:	47                   	inc    edi
  102307:	85 db                	test   ebx,ebx
  102309:	75 c5                	jne    1022d0 <kernel_main+0x6f0>
    r[a] = 0;
  10230b:	c6 84 34 10 03 00 00 	mov    BYTE PTR [esp+esi*1+0x310],0x0
  102312:	00 
    for (auto b = 0; b < a / 2; b++) {
  102313:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  102319:	8d 9c 24 10 03 00 00 	lea    ebx,[esp+0x310]
  102320:	74 38                	je     10235a <kernel_main+0x77a>
  102322:	89 d6                	mov    esi,edx
  102324:	d1 ee                	shr    esi,1
  102326:	89 da                	mov    edx,ebx
  102328:	90                   	nop
  102329:	90                   	nop
  10232a:	90                   	nop
  10232b:	90                   	nop
  10232c:	90                   	nop
  10232d:	90                   	nop
  10232e:	90                   	nop
  10232f:	90                   	nop
        r[b] ^= r[a - b - 1];
  102330:	0f b6 02             	movzx  eax,BYTE PTR [edx]
  102333:	32 01                	xor    al,BYTE PTR [ecx]
  102335:	88 02                	mov    BYTE PTR [edx],al
        r[a - b - 1] ^= r[b];
  102337:	32 01                	xor    al,BYTE PTR [ecx]
  102339:	88 01                	mov    BYTE PTR [ecx],al
        r[b] ^= r[a - b - 1];
  10233b:	30 02                	xor    BYTE PTR [edx],al
    for (auto b = 0; b < a / 2; b++) {
  10233d:	42                   	inc    edx
  10233e:	49                   	dec    ecx
  10233f:	4e                   	dec    esi
  102340:	75 ee                	jne    102330 <kernel_main+0x750>
  102342:	eb 16                	jmp    10235a <kernel_main+0x77a>
  102344:	90                   	nop
  102345:	90                   	nop
  102346:	90                   	nop
  102347:	90                   	nop
  102348:	90                   	nop
  102349:	90                   	nop
  10234a:	90                   	nop
  10234b:	90                   	nop
  10234c:	90                   	nop
  10234d:	90                   	nop
  10234e:	90                   	nop
  10234f:	90                   	nop
        r[a++] = '0';
  102350:	66 c7 84 24 10 03 00 	mov    WORD PTR [esp+0x310],0x30
  102357:	00 30 00 
    return r;
  10235a:	b9 09 00 00 00       	mov    ecx,0x9
  10235f:	8d 84 24 b0 00 00 00 	lea    eax,[esp+0xb0]
  102366:	89 c7                	mov    edi,eax
  102368:	89 de                	mov    esi,ebx
  10236a:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
            term::write("Module ", int_to_string(a.index).str(), ": from ",
  10236c:	68 9f 00 10 00       	push   0x10009f
  102371:	50                   	push   eax
  102372:	68 9a 00 10 00       	push   0x10009a
  102377:	8d 44 24 34          	lea    eax,[esp+0x34]
  10237b:	50                   	push   eax
  10237c:	68 a1 00 10 00       	push   0x1000a1
  102381:	8d 84 24 24 01 00 00 	lea    eax,[esp+0x124]
  102388:	50                   	push   eax
  102389:	68 49 00 10 00       	push   0x100049
  10238e:	e8 cd 1a 00 00       	call   103e60 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)>
  102393:	83 c4 1c             	add    esp,0x1c
  102396:	6a 20                	push   0x20
  102398:	e8 a3 ed ff ff       	call   101140 <term::write(char)>
  10239d:	83 c4 04             	add    esp,0x4
  1023a0:	8b 74 24 20          	mov    esi,DWORD PTR [esp+0x20]
    for (int a = 0; s[a] != 0; a++) {
  1023a4:	8a 06                	mov    al,BYTE PTR [esi]
  1023a6:	84 c0                	test   al,al
  1023a8:	0f 84 22 fc ff ff    	je     101fd0 <kernel_main+0x3f0>
  1023ae:	46                   	inc    esi
  1023af:	90                   	nop
        write(s[a]);
  1023b0:	0f be c0             	movsx  eax,al
  1023b3:	50                   	push   eax
  1023b4:	e8 87 ed ff ff       	call   101140 <term::write(char)>
  1023b9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  1023bc:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  1023bf:	46                   	inc    esi
  1023c0:	84 c0                	test   al,al
  1023c2:	75 ec                	jne    1023b0 <kernel_main+0x7d0>
  1023c4:	e9 07 fc ff ff       	jmp    101fd0 <kernel_main+0x3f0>
                        int_to_string<16>(a().mod_end).str(), "\n");
            term::write(" ", reinterpret_cast<const char *>(a().cmdline), "\n");
        }
    }

    if ((mb->flags & 1) == 1) {
  1023c9:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  1023cc:	f6 00 01             	test   BYTE PTR [eax],0x1
  1023cf:	0f 84 b7 01 00 00    	je     10258c <kernel_main+0x9ac>
        term::write("Mem size: ",
                    int_to_string(mb->mem_upper * mem::KB / mem::MB).str(),
  1023d5:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  1023d8:	8b 58 08             	mov    ebx,DWORD PTR [eax+0x8]
  1023db:	c1 eb 0a             	shr    ebx,0xa
    if (x == 0)
  1023de:	81 e3 ff 0f 00 00    	and    ebx,0xfff
    constexpr array() : data_{T()} {}
  1023e4:	c7 84 24 2b 03 00 00 	mov    DWORD PTR [esp+0x32b],0x0
  1023eb:	00 00 00 00 
  1023ef:	c7 84 24 28 03 00 00 	mov    DWORD PTR [esp+0x328],0x0
  1023f6:	00 00 00 00 
  1023fa:	c7 84 24 24 03 00 00 	mov    DWORD PTR [esp+0x324],0x0
  102401:	00 00 00 00 
  102405:	c7 84 24 20 03 00 00 	mov    DWORD PTR [esp+0x320],0x0
  10240c:	00 00 00 00 
  102410:	c7 84 24 1c 03 00 00 	mov    DWORD PTR [esp+0x31c],0x0
  102417:	00 00 00 00 
  10241b:	c7 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],0x0
  102422:	00 00 00 00 
  102426:	c7 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],0x0
  10242d:	00 00 00 00 
  102431:	c7 84 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],0x0
  102438:	00 00 00 00 
    int index_ = 0;
  10243c:	c7 84 24 30 03 00 00 	mov    DWORD PTR [esp+0x330],0x0
  102443:	00 00 00 00 
    if (x == 0)
  102447:	74 6b                	je     1024b4 <kernel_main+0x8d4>
    for (; x > 0; a++) {
  102449:	8d b4 24 0f 03 00 00 	lea    esi,[esp+0x30f]
  102450:	31 ff                	xor    edi,edi
  102452:	90                   	nop
  102453:	90                   	nop
  102454:	90                   	nop
  102455:	90                   	nop
  102456:	90                   	nop
  102457:	90                   	nop
  102458:	90                   	nop
  102459:	90                   	nop
  10245a:	90                   	nop
  10245b:	90                   	nop
  10245c:	90                   	nop
  10245d:	90                   	nop
  10245e:	90                   	nop
  10245f:	90                   	nop
        x /= B;
  102460:	89 d8                	mov    eax,ebx
  102462:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  102467:	f7 e1                	mul    ecx
  102469:	c1 ea 03             	shr    edx,0x3
  10246c:	8d 04 12             	lea    eax,[edx+edx*1]
  10246f:	8d 04 80             	lea    eax,[eax+eax*4]
  102472:	89 d9                	mov    ecx,ebx
  102474:	29 c1                	sub    ecx,eax
            return '0' + (x % B);
  102476:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  102479:	88 4e 01             	mov    BYTE PTR [esi+0x1],cl
  10247c:	46                   	inc    esi
    for (; x > 0; a++) {
  10247d:	47                   	inc    edi
  10247e:	83 fb 09             	cmp    ebx,0x9
  102481:	89 d3                	mov    ebx,edx
  102483:	77 db                	ja     102460 <kernel_main+0x880>
    r[a] = 0;
  102485:	c6 46 01 00          	mov    BYTE PTR [esi+0x1],0x0
    for (auto b = 0; b < a / 2; b++) {
  102489:	f7 c7 fe ff ff ff    	test   edi,0xfffffffe
  10248f:	8d 8c 24 10 03 00 00 	lea    ecx,[esp+0x310]
  102496:	74 26                	je     1024be <kernel_main+0x8de>
  102498:	d1 ef                	shr    edi,1
  10249a:	90                   	nop
  10249b:	90                   	nop
  10249c:	90                   	nop
  10249d:	90                   	nop
  10249e:	90                   	nop
  10249f:	90                   	nop
        r[b] ^= r[a - b - 1];
  1024a0:	0f b6 01             	movzx  eax,BYTE PTR [ecx]
  1024a3:	32 06                	xor    al,BYTE PTR [esi]
  1024a5:	88 01                	mov    BYTE PTR [ecx],al
        r[a - b - 1] ^= r[b];
  1024a7:	32 06                	xor    al,BYTE PTR [esi]
  1024a9:	88 06                	mov    BYTE PTR [esi],al
        r[b] ^= r[a - b - 1];
  1024ab:	30 01                	xor    BYTE PTR [ecx],al
    for (auto b = 0; b < a / 2; b++) {
  1024ad:	41                   	inc    ecx
  1024ae:	4e                   	dec    esi
  1024af:	4f                   	dec    edi
  1024b0:	75 ee                	jne    1024a0 <kernel_main+0x8c0>
  1024b2:	eb 0a                	jmp    1024be <kernel_main+0x8de>
        r[a++] = '0';
  1024b4:	66 c7 84 24 10 03 00 	mov    WORD PTR [esp+0x310],0x30
  1024bb:	00 30 00 
  1024be:	8d bc 24 10 01 00 00 	lea    edi,[esp+0x110]
  1024c5:	8d b4 24 10 03 00 00 	lea    esi,[esp+0x310]
    return r;
  1024cc:	b9 09 00 00 00       	mov    ecx,0x9
  1024d1:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
        write(s[a]);
  1024d3:	6a 4d                	push   0x4d
  1024d5:	e8 66 ec ff ff       	call   101140 <term::write(char)>
  1024da:	83 c4 04             	add    esp,0x4
  1024dd:	6a 65                	push   0x65
  1024df:	e8 5c ec ff ff       	call   101140 <term::write(char)>
  1024e4:	83 c4 04             	add    esp,0x4
  1024e7:	6a 6d                	push   0x6d
  1024e9:	e8 52 ec ff ff       	call   101140 <term::write(char)>
  1024ee:	83 c4 04             	add    esp,0x4
  1024f1:	6a 20                	push   0x20
  1024f3:	e8 48 ec ff ff       	call   101140 <term::write(char)>
  1024f8:	83 c4 04             	add    esp,0x4
  1024fb:	6a 73                	push   0x73
  1024fd:	e8 3e ec ff ff       	call   101140 <term::write(char)>
  102502:	83 c4 04             	add    esp,0x4
  102505:	6a 69                	push   0x69
  102507:	e8 34 ec ff ff       	call   101140 <term::write(char)>
  10250c:	83 c4 04             	add    esp,0x4
  10250f:	6a 7a                	push   0x7a
  102511:	e8 2a ec ff ff       	call   101140 <term::write(char)>
  102516:	83 c4 04             	add    esp,0x4
  102519:	6a 65                	push   0x65
  10251b:	e8 20 ec ff ff       	call   101140 <term::write(char)>
  102520:	83 c4 04             	add    esp,0x4
  102523:	6a 3a                	push   0x3a
  102525:	e8 16 ec ff ff       	call   101140 <term::write(char)>
  10252a:	83 c4 04             	add    esp,0x4
  10252d:	6a 20                	push   0x20
  10252f:	e8 0c ec ff ff       	call   101140 <term::write(char)>
  102534:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102537:	8a 84 24 10 01 00 00 	mov    al,BYTE PTR [esp+0x110]
  10253e:	84 c0                	test   al,al
  102540:	74 22                	je     102564 <kernel_main+0x984>
  102542:	8d b4 24 11 01 00 00 	lea    esi,[esp+0x111]
  102549:	90                   	nop
  10254a:	90                   	nop
  10254b:	90                   	nop
  10254c:	90                   	nop
  10254d:	90                   	nop
  10254e:	90                   	nop
  10254f:	90                   	nop
        write(s[a]);
  102550:	0f be c0             	movsx  eax,al
  102553:	50                   	push   eax
  102554:	e8 e7 eb ff ff       	call   101140 <term::write(char)>
  102559:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10255c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10255f:	46                   	inc    esi
  102560:	84 c0                	test   al,al
  102562:	75 ec                	jne    102550 <kernel_main+0x970>
        write(s[a]);
  102564:	6a 20                	push   0x20
  102566:	e8 d5 eb ff ff       	call   101140 <term::write(char)>
  10256b:	83 c4 04             	add    esp,0x4
  10256e:	6a 4d                	push   0x4d
  102570:	e8 cb eb ff ff       	call   101140 <term::write(char)>
  102575:	83 c4 04             	add    esp,0x4
  102578:	6a 42                	push   0x42
  10257a:	e8 c1 eb ff ff       	call   101140 <term::write(char)>
  10257f:	83 c4 04             	add    esp,0x4
  102582:	6a 0a                	push   0xa
  102584:	e8 b7 eb ff ff       	call   101140 <term::write(char)>
  102589:	83 c4 04             	add    esp,0x4
  10258c:	6a 50                	push   0x50
  10258e:	e8 ad eb ff ff       	call   101140 <term::write(char)>
  102593:	83 c4 04             	add    esp,0x4
  102596:	6a 53                	push   0x53
  102598:	e8 a3 eb ff ff       	call   101140 <term::write(char)>
  10259d:	83 c4 04             	add    esp,0x4
  1025a0:	6a 2f                	push   0x2f
  1025a2:	e8 99 eb ff ff       	call   101140 <term::write(char)>
  1025a7:	83 c4 04             	add    esp,0x4
  1025aa:	6a 32                	push   0x32
  1025ac:	e8 8f eb ff ff       	call   101140 <term::write(char)>
  1025b1:	83 c4 04             	add    esp,0x4
  1025b4:	6a 3a                	push   0x3a
  1025b6:	e8 85 eb ff ff       	call   101140 <term::write(char)>
  1025bb:	83 c4 04             	add    esp,0x4
  1025be:	6a 20                	push   0x20
  1025c0:	e8 7b eb ff ff       	call   101140 <term::write(char)>
  1025c5:	83 c4 04             	add    esp,0x4
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1025c8:	66 ba 64 00          	mov    dx,0x64
  1025cc:	b0 ad                	mov    al,0xad
  1025ce:	ee                   	out    dx,al
  1025cf:	66 ba 64 00          	mov    dx,0x64
  1025d3:	b0 a7                	mov    al,0xa7
  1025d5:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1025d6:	66 ba 64 00          	mov    dx,0x64
  1025da:	ec                   	in     al,dx
  1025db:	a8 01                	test   al,0x1
    while (has_output_data())
  1025dd:	74 0f                	je     1025ee <kernel_main+0xa0e>
  1025df:	90                   	nop
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1025e0:	66 ba 60 00          	mov    dx,0x60
  1025e4:	ec                   	in     al,dx
  1025e5:	66 ba 64 00          	mov    dx,0x64
  1025e9:	ec                   	in     al,dx
  1025ea:	a8 01                	test   al,0x1
    while (has_output_data())
  1025ec:	75 f2                	jne    1025e0 <kernel_main+0xa00>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1025ee:	66 ba 64 00          	mov    dx,0x64
  1025f2:	b0 20                	mov    al,0x20
  1025f4:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  1025f5:	66 ba 60 00          	mov    dx,0x60
  1025f9:	ec                   	in     al,dx
  1025fa:	89 c1                	mov    ecx,eax
    cb &= 0b10111100; // disable interrupts and translation
  1025fc:	80 e1 bc             	and    cl,0xbc
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1025ff:	66 ba 64 00          	mov    dx,0x64
  102603:	b0 60                	mov    al,0x60
  102605:	ee                   	out    dx,al
  102606:	66 ba 60 00          	mov    dx,0x60
  10260a:	89 c8                	mov    eax,ecx
  10260c:	ee                   	out    dx,al
  10260d:	66 ba 64 00          	mov    dx,0x64
  102611:	b0 aa                	mov    al,0xaa
  102613:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  102614:	66 ba 60 00          	mov    dx,0x60
  102618:	ec                   	in     al,dx
    return receive(DATA) == 0x55;
  102619:	3c 55                	cmp    al,0x55
    if (!(ps2::test_controller() && ps2::test_port_1()))
  10261b:	0f 85 71 13 00 00    	jne    103992 <kernel_main+0x1db2>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  102621:	66 ba 64 00          	mov    dx,0x64
  102625:	b0 ab                	mov    al,0xab
  102627:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  102628:	66 ba 60 00          	mov    dx,0x60
  10262c:	ec                   	in     al,dx
    return receive(DATA) == 0x00;
  10262d:	84 c0                	test   al,al
    if (!(ps2::test_controller() && ps2::test_port_1()))
  10262f:	0f 85 5d 13 00 00    	jne    103992 <kernel_main+0x1db2>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  102635:	66 ba 64 00          	mov    dx,0x64
  102639:	b0 ae                	mov    al,0xae
  10263b:	ee                   	out    dx,al
  10263c:	66 ba 60 00          	mov    dx,0x60
  102640:	b0 ff                	mov    al,0xff
  102642:	ee                   	out    dx,al
    asm volatile("inb %%dx,%%al" : "=a"(r) : "d"(port));
  102643:	66 ba 60 00          	mov    dx,0x60
  102647:	ec                   	in     al,dx
  102648:	66 ba 60 00          	mov    dx,0x60
  10264c:	ec                   	in     al,dx
    return receive(DATA) == 0xAA;
  10264d:	3c aa                	cmp    al,0xaa
    if (!ps2::reset_1())
  10264f:	0f 85 3d 13 00 00    	jne    103992 <kernel_main+0x1db2>
  102655:	8b 75 10             	mov    esi,DWORD PTR [ebp+0x10]
  102658:	6a 4f                	push   0x4f
  10265a:	e8 e1 ea ff ff       	call   101140 <term::write(char)>
  10265f:	83 c4 04             	add    esp,0x4
  102662:	6a 4b                	push   0x4b
  102664:	e8 d7 ea ff ff       	call   101140 <term::write(char)>
  102669:	83 c4 04             	add    esp,0x4
  10266c:	6a 0a                	push   0xa
  10266e:	e8 cd ea ff ff       	call   101140 <term::write(char)>
  102673:	83 c4 04             	add    esp,0x4
    int index_ = 0;
  102676:	8d 84 24 18 03 00 00 	lea    eax,[esp+0x318]
  10267d:	68 c0 09 00 00       	push   0x9c0
  102682:	6a 00                	push   0x0
  102684:	50                   	push   eax
  102685:	e8 f6 eb ff ff       	call   101280 <memset>
  10268a:	83 c4 0c             	add    esp,0xc
    array<uint32, N> mt; /* the array for the state vector  */
    uint32 mti = N + 1;  /* mti==N+1 means mt[N] is not initialized */

  public:
    random_gen(uint32 seed = 5489) {
        mt[0] = seed & static_cast<uint32>(~0);
  10268d:	89 b4 24 10 03 00 00 	mov    DWORD PTR [esp+0x310],esi
        for (mti = 1; mti < N; mti++) {
            mt[mti] =
                (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
  102694:	89 f0                	mov    eax,esi
  102696:	c1 e8 1e             	shr    eax,0x1e
  102699:	31 f0                	xor    eax,esi
  10269b:	69 c0 65 89 07 6c    	imul   eax,eax,0x6c078965
  1026a1:	40                   	inc    eax
            mt[mti] =
  1026a2:	89 84 24 14 03 00 00 	mov    DWORD PTR [esp+0x314],eax
                (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
  1026a9:	89 c1                	mov    ecx,eax
  1026ab:	c1 e9 1e             	shr    ecx,0x1e
  1026ae:	31 c1                	xor    ecx,eax
  1026b0:	69 c1 65 89 07 6c    	imul   eax,ecx,0x6c078965
  1026b6:	83 c0 02             	add    eax,0x2
            mt[mti] =
  1026b9:	89 84 24 18 03 00 00 	mov    DWORD PTR [esp+0x318],eax
  1026c0:	c7 84 24 d8 0c 00 00 	mov    DWORD PTR [esp+0xcd8],0x3
  1026c7:	03 00 00 00 
  1026cb:	31 c0                	xor    eax,eax
        for (mti = 1; mti < N; mti++) {
  1026cd:	84 c0                	test   al,al
  1026cf:	75 44                	jne    102715 <kernel_main+0xb35>
  1026d1:	b9 02 00 00 00       	mov    ecx,0x2
  1026d6:	b8 03 00 00 00       	mov    eax,0x3
  1026db:	90                   	nop
  1026dc:	90                   	nop
  1026dd:	90                   	nop
  1026de:	90                   	nop
  1026df:	90                   	nop
                (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
  1026e0:	8b 8c 8c 10 03 00 00 	mov    ecx,DWORD PTR [esp+ecx*4+0x310]
  1026e7:	89 ca                	mov    edx,ecx
  1026e9:	c1 ea 1e             	shr    edx,0x1e
  1026ec:	31 ca                	xor    edx,ecx
  1026ee:	69 ca 65 89 07 6c    	imul   ecx,edx,0x6c078965
  1026f4:	01 c1                	add    ecx,eax
            mt[mti] =
  1026f6:	89 8c 84 10 03 00 00 	mov    DWORD PTR [esp+eax*4+0x310],ecx
            mt[mti] &= static_cast<uint32>(~0);
  1026fd:	8b 8c 24 d8 0c 00 00 	mov    ecx,DWORD PTR [esp+0xcd8]
        for (mti = 1; mti < N; mti++) {
  102704:	8d 41 01             	lea    eax,[ecx+0x1]
  102707:	89 84 24 d8 0c 00 00 	mov    DWORD PTR [esp+0xcd8],eax
  10270e:	3d 70 02 00 00       	cmp    eax,0x270
  102713:	72 cb                	jb     1026e0 <kernel_main+0xb00>
  102715:	8d 9c 24 10 03 00 00 	lea    ebx,[esp+0x310]
  10271c:	eb 12                	jmp    102730 <kernel_main+0xb50>
        return p[length()] == 0;
  10271e:	85 c0                	test   eax,eax
            }
            term::Term.flipped = false;
            term::Term.wrap = false;
            term::Term.set_colour(term::WHITE);
        }
        if (command == "coredump") {
  102720:	0f 84 1a 04 00 00    	je     102b40 <kernel_main+0xf60>
  102726:	90                   	nop
  102727:	90                   	nop
  102728:	90                   	nop
  102729:	90                   	nop
  10272a:	90                   	nop
  10272b:	90                   	nop
  10272c:	90                   	nop
  10272d:	90                   	nop
  10272e:	90                   	nop
  10272f:	90                   	nop
  102730:	6a 3e                	push   0x3e
  102732:	e8 09 ea ff ff       	call   101140 <term::write(char)>
  102737:	83 c4 04             	add    esp,0x4
  10273a:	6a 20                	push   0x20
  10273c:	e8 ff e9 ff ff       	call   101140 <term::write(char)>
  102741:	83 c4 04             	add    esp,0x4
  102744:	6a 20                	push   0x20
  102746:	e8 f5 e9 ff ff       	call   101140 <term::write(char)>
  10274b:	83 c4 04             	add    esp,0x4
        auto &&line = kbd::get_line();
  10274e:	6a 01                	push   0x1
  102750:	e8 fb f2 ff ff       	call   101a50 <kbd::get_line(bool)>
  102755:	83 c4 04             	add    esp,0x4
  102758:	31 d2                	xor    edx,edx
    constexpr array() : data_{T()} {}
  10275a:	31 c0                	xor    eax,eax
  10275c:	b9 14 00 00 00       	mov    ecx,0x14
  102761:	8d bc 24 10 01 00 00 	lea    edi,[esp+0x110]
  102768:	f3 ab                	rep stos DWORD PTR es:[edi],eax
  10276a:	c6 84 24 60 01 00 00 	mov    BYTE PTR [esp+0x160],0x0
  102771:	00 
    int index_ = 0;
  102772:	c7 84 24 64 01 00 00 	mov    DWORD PTR [esp+0x164],0x0
  102779:	00 00 00 00 
  10277d:	90                   	nop
  10277e:	90                   	nop
  10277f:	90                   	nop
            if (this->operator[](a) == 0)
  102780:	80 ba 88 70 11 00 00 	cmp    BYTE PTR [edx+0x117088],0x0
  102787:	74 0b                	je     102794 <kernel_main+0xbb4>
        for (int a = 0; a < N; a++) {
  102789:	42                   	inc    edx
  10278a:	83 fa 50             	cmp    edx,0x50
  10278d:	75 f1                	jne    102780 <kernel_main+0xba0>
  10278f:	ba 50 00 00 00       	mov    edx,0x50
        return ptr_ != p.ptr_;
  102794:	85 d2                	test   edx,edx
        for (auto a : *this) {
  102796:	74 4c                	je     1027e4 <kernel_main+0xc04>
  102798:	31 c0                	xor    eax,eax
  10279a:	31 f6                	xor    esi,esi
  10279c:	31 ff                	xor    edi,edi
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  10279e:	8a 88 88 70 11 00    	mov    cl,BYTE PTR [eax+0x117088]
            if (a == separator) {
  1027a4:	80 f9 20             	cmp    cl,0x20
  1027a7:	75 18                	jne    1027c1 <kernel_main+0xbe1>
  1027a9:	90                   	nop
  1027aa:	90                   	nop
  1027ab:	90                   	nop
  1027ac:	90                   	nop
  1027ad:	90                   	nop
  1027ae:	90                   	nop
  1027af:	90                   	nop
                seps++;
  1027b0:	46                   	inc    esi
        return ptr_ != p.ptr_;
  1027b1:	40                   	inc    eax
  1027b2:	39 c2                	cmp    edx,eax
        for (auto a : *this) {
  1027b4:	74 2a                	je     1027e0 <kernel_main+0xc00>
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  1027b6:	8a 88 88 70 11 00    	mov    cl,BYTE PTR [eax+0x117088]
            if (a == separator) {
  1027bc:	80 f9 20             	cmp    cl,0x20
  1027bf:	74 ef                	je     1027b0 <kernel_main+0xbd0>
            } else if (seps == num) {
  1027c1:	85 f6                	test   esi,esi
  1027c3:	75 ec                	jne    1027b1 <kernel_main+0xbd1>
                r[i++] = a();
  1027c5:	88 8c 3c 10 01 00 00 	mov    BYTE PTR [esp+edi*1+0x110],cl
  1027cc:	47                   	inc    edi
  1027cd:	31 f6                	xor    esi,esi
        return ptr_ != p.ptr_;
  1027cf:	40                   	inc    eax
  1027d0:	39 c2                	cmp    edx,eax
        for (auto a : *this) {
  1027d2:	75 e2                	jne    1027b6 <kernel_main+0xbd6>
  1027d4:	90                   	nop
  1027d5:	90                   	nop
  1027d6:	90                   	nop
  1027d7:	90                   	nop
  1027d8:	90                   	nop
  1027d9:	90                   	nop
  1027da:	90                   	nop
  1027db:	90                   	nop
  1027dc:	90                   	nop
  1027dd:	90                   	nop
  1027de:	90                   	nop
  1027df:	90                   	nop
        if (seps < num)
  1027e0:	85 f6                	test   esi,esi
  1027e2:	78 1c                	js     102800 <kernel_main+0xc20>
    return static_cast<remove_ref<T> &&>(t);
  1027e4:	b9 16 00 00 00       	mov    ecx,0x16
  1027e9:	8d 7c 24 2c          	lea    edi,[esp+0x2c]
  1027ed:	8d 84 24 10 01 00 00 	lea    eax,[esp+0x110]
  1027f4:	89 c6                	mov    esi,eax
  1027f6:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  1027f8:	89 c7                	mov    edi,eax
  1027fa:	b2 01                	mov    dl,0x1
  1027fc:	eb 1a                	jmp    102818 <kernel_main+0xc38>
  1027fe:	90                   	nop
  1027ff:	90                   	nop
  102800:	31 d2                	xor    edx,edx
    constexpr optional() : value() {}
  102802:	31 c0                	xor    eax,eax
  102804:	b9 16 00 00 00       	mov    ecx,0x16
  102809:	8d 7c 24 2c          	lea    edi,[esp+0x2c]
  10280d:	f3 ab                	rep stos DWORD PTR es:[edi],eax
  10280f:	8d 84 24 10 01 00 00 	lea    eax,[esp+0x110]
  102816:	89 c7                	mov    edi,eax
    bool loaded_ = false;
  102818:	88 54 24 28          	mov    BYTE PTR [esp+0x28],dl
    const char *err = "(Unknown error)";
  10281c:	c7 84 24 84 00 00 00 	mov    DWORD PTR [esp+0x84],0x10005f
  102823:	5f 00 10 00 
  102827:	31 d2                	xor    edx,edx
    constexpr array() : data_{T()} {}
  102829:	31 c0                	xor    eax,eax
  10282b:	b9 14 00 00 00       	mov    ecx,0x14
  102830:	f3 ab                	rep stos DWORD PTR es:[edi],eax
  102832:	c6 84 24 60 01 00 00 	mov    BYTE PTR [esp+0x160],0x0
  102839:	00 
    int index_ = 0;
  10283a:	c7 84 24 64 01 00 00 	mov    DWORD PTR [esp+0x164],0x0
  102841:	00 00 00 00 
  102845:	90                   	nop
  102846:	90                   	nop
  102847:	90                   	nop
  102848:	90                   	nop
  102849:	90                   	nop
  10284a:	90                   	nop
  10284b:	90                   	nop
  10284c:	90                   	nop
  10284d:	90                   	nop
  10284e:	90                   	nop
  10284f:	90                   	nop
            if (this->operator[](a) == 0)
  102850:	80 ba 88 70 11 00 00 	cmp    BYTE PTR [edx+0x117088],0x0
  102857:	74 0b                	je     102864 <kernel_main+0xc84>
        for (int a = 0; a < N; a++) {
  102859:	42                   	inc    edx
  10285a:	83 fa 50             	cmp    edx,0x50
  10285d:	75 f1                	jne    102850 <kernel_main+0xc70>
  10285f:	ba 50 00 00 00       	mov    edx,0x50
        return ptr_ != p.ptr_;
  102864:	85 d2                	test   edx,edx
        for (auto a : *this) {
  102866:	74 68                	je     1028d0 <kernel_main+0xcf0>
  102868:	31 c0                	xor    eax,eax
  10286a:	31 f6                	xor    esi,esi
  10286c:	31 ff                	xor    edi,edi
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  10286e:	8a 88 88 70 11 00    	mov    cl,BYTE PTR [eax+0x117088]
            if (a == separator) {
  102874:	80 f9 20             	cmp    cl,0x20
  102877:	75 18                	jne    102891 <kernel_main+0xcb1>
  102879:	90                   	nop
  10287a:	90                   	nop
  10287b:	90                   	nop
  10287c:	90                   	nop
  10287d:	90                   	nop
  10287e:	90                   	nop
  10287f:	90                   	nop
                seps++;
  102880:	46                   	inc    esi
        return ptr_ != p.ptr_;
  102881:	40                   	inc    eax
  102882:	39 c2                	cmp    edx,eax
        for (auto a : *this) {
  102884:	74 22                	je     1028a8 <kernel_main+0xcc8>
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  102886:	8a 88 88 70 11 00    	mov    cl,BYTE PTR [eax+0x117088]
            if (a == separator) {
  10288c:	80 f9 20             	cmp    cl,0x20
  10288f:	74 ef                	je     102880 <kernel_main+0xca0>
            } else if (seps == num) {
  102891:	83 fe 01             	cmp    esi,0x1
  102894:	75 eb                	jne    102881 <kernel_main+0xca1>
                r[i++] = a();
  102896:	88 8c 3c 10 01 00 00 	mov    BYTE PTR [esp+edi*1+0x110],cl
  10289d:	47                   	inc    edi
  10289e:	be 01 00 00 00       	mov    esi,0x1
        return ptr_ != p.ptr_;
  1028a3:	40                   	inc    eax
  1028a4:	39 c2                	cmp    edx,eax
        for (auto a : *this) {
  1028a6:	75 de                	jne    102886 <kernel_main+0xca6>
        if (seps < num)
  1028a8:	85 f6                	test   esi,esi
  1028aa:	7e 24                	jle    1028d0 <kernel_main+0xcf0>
    return static_cast<remove_ref<T> &&>(t);
  1028ac:	b9 16 00 00 00       	mov    ecx,0x16
  1028b1:	8d bc 24 b4 00 00 00 	lea    edi,[esp+0xb4]
  1028b8:	8d b4 24 10 01 00 00 	lea    esi,[esp+0x110]
  1028bf:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  1028c1:	b2 01                	mov    dl,0x1
  1028c3:	eb 1d                	jmp    1028e2 <kernel_main+0xd02>
  1028c5:	90                   	nop
  1028c6:	90                   	nop
  1028c7:	90                   	nop
  1028c8:	90                   	nop
  1028c9:	90                   	nop
  1028ca:	90                   	nop
  1028cb:	90                   	nop
  1028cc:	90                   	nop
  1028cd:	90                   	nop
  1028ce:	90                   	nop
  1028cf:	90                   	nop
  1028d0:	31 d2                	xor    edx,edx
    constexpr optional() : value() {}
  1028d2:	31 c0                	xor    eax,eax
  1028d4:	b9 16 00 00 00       	mov    ecx,0x16
  1028d9:	8d bc 24 b4 00 00 00 	lea    edi,[esp+0xb4]
  1028e0:	f3 ab                	rep stos DWORD PTR es:[edi],eax
    bool loaded_ = false;
  1028e2:	88 94 24 b0 00 00 00 	mov    BYTE PTR [esp+0xb0],dl
    const char *err = "(Unknown error)";
  1028e9:	c7 84 24 0c 01 00 00 	mov    DWORD PTR [esp+0x10c],0x10005f
  1028f0:	5f 00 10 00 
  1028f4:	31 c0                	xor    eax,eax
  1028f6:	90                   	nop
  1028f7:	90                   	nop
  1028f8:	90                   	nop
  1028f9:	90                   	nop
  1028fa:	90                   	nop
  1028fb:	90                   	nop
  1028fc:	90                   	nop
  1028fd:	90                   	nop
  1028fe:	90                   	nop
  1028ff:	90                   	nop
  102900:	31 c9                	xor    ecx,ecx
  102902:	90                   	nop
  102903:	90                   	nop
  102904:	90                   	nop
  102905:	90                   	nop
  102906:	90                   	nop
  102907:	90                   	nop
  102908:	90                   	nop
  102909:	90                   	nop
  10290a:	90                   	nop
  10290b:	90                   	nop
  10290c:	90                   	nop
  10290d:	90                   	nop
  10290e:	90                   	nop
  10290f:	90                   	nop
            if (this->operator[](a) == 0)
  102910:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102915:	74 0b                	je     102922 <kernel_main+0xd42>
        for (int a = 0; a < N; a++) {
  102917:	41                   	inc    ecx
  102918:	83 f9 50             	cmp    ecx,0x50
  10291b:	75 f3                	jne    102910 <kernel_main+0xd30>
  10291d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  102922:	39 c8                	cmp    eax,ecx
  102924:	73 1a                	jae    102940 <kernel_main+0xd60>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102926:	83 f8 04             	cmp    eax,0x4
  102929:	74 45                	je     102970 <kernel_main+0xd90>
  10292b:	8a 88 51 00 10 00    	mov    cl,BYTE PTR [eax+0x100051]
  102931:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  102935:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102938:	74 c6                	je     102900 <kernel_main+0xd20>
  10293a:	eb 34                	jmp    102970 <kernel_main+0xd90>
  10293c:	90                   	nop
  10293d:	90                   	nop
  10293e:	90                   	nop
  10293f:	90                   	nop
  102940:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  102945:	90                   	nop
  102946:	90                   	nop
  102947:	90                   	nop
  102948:	90                   	nop
  102949:	90                   	nop
  10294a:	90                   	nop
  10294b:	90                   	nop
  10294c:	90                   	nop
  10294d:	90                   	nop
  10294e:	90                   	nop
  10294f:	90                   	nop
            if (this->operator[](a) == 0)
  102950:	80 7c 04 30 00       	cmp    BYTE PTR [esp+eax*1+0x30],0x0
  102955:	74 08                	je     10295f <kernel_main+0xd7f>
        for (int a = 0; a < N; a++) {
  102957:	40                   	inc    eax
  102958:	83 f8 4c             	cmp    eax,0x4c
  10295b:	75 f3                	jne    102950 <kernel_main+0xd70>
  10295d:	eb 11                	jmp    102970 <kernel_main+0xd90>
        return p[length()] == 0;
  10295f:	85 c0                	test   eax,eax
        if (command == "exit") {
  102961:	0f 84 8f 0f 00 00    	je     1038f6 <kernel_main+0x1d16>
  102967:	90                   	nop
  102968:	90                   	nop
  102969:	90                   	nop
  10296a:	90                   	nop
  10296b:	90                   	nop
  10296c:	90                   	nop
  10296d:	90                   	nop
  10296e:	90                   	nop
  10296f:	90                   	nop
  102970:	31 c0                	xor    eax,eax
  102972:	90                   	nop
  102973:	90                   	nop
  102974:	90                   	nop
  102975:	90                   	nop
  102976:	90                   	nop
  102977:	90                   	nop
  102978:	90                   	nop
  102979:	90                   	nop
  10297a:	90                   	nop
  10297b:	90                   	nop
  10297c:	90                   	nop
  10297d:	90                   	nop
  10297e:	90                   	nop
  10297f:	90                   	nop
  102980:	31 c9                	xor    ecx,ecx
  102982:	90                   	nop
  102983:	90                   	nop
  102984:	90                   	nop
  102985:	90                   	nop
  102986:	90                   	nop
  102987:	90                   	nop
  102988:	90                   	nop
  102989:	90                   	nop
  10298a:	90                   	nop
  10298b:	90                   	nop
  10298c:	90                   	nop
  10298d:	90                   	nop
  10298e:	90                   	nop
  10298f:	90                   	nop
            if (this->operator[](a) == 0)
  102990:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102995:	74 0b                	je     1029a2 <kernel_main+0xdc2>
        for (int a = 0; a < N; a++) {
  102997:	41                   	inc    ecx
  102998:	83 f9 50             	cmp    ecx,0x50
  10299b:	75 f3                	jne    102990 <kernel_main+0xdb0>
  10299d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  1029a2:	39 c8                	cmp    eax,ecx
  1029a4:	73 1a                	jae    1029c0 <kernel_main+0xde0>
            if (p[a] == 0 || p[a] != this->operator[](a))
  1029a6:	83 f8 05             	cmp    eax,0x5
  1029a9:	74 45                	je     1029f0 <kernel_main+0xe10>
  1029ab:	8a 88 d2 00 10 00    	mov    cl,BYTE PTR [eax+0x1000d2]
  1029b1:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  1029b5:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  1029b8:	74 c6                	je     102980 <kernel_main+0xda0>
  1029ba:	eb 34                	jmp    1029f0 <kernel_main+0xe10>
  1029bc:	90                   	nop
  1029bd:	90                   	nop
  1029be:	90                   	nop
  1029bf:	90                   	nop
  1029c0:	b8 fb ff ff ff       	mov    eax,0xfffffffb
  1029c5:	90                   	nop
  1029c6:	90                   	nop
  1029c7:	90                   	nop
  1029c8:	90                   	nop
  1029c9:	90                   	nop
  1029ca:	90                   	nop
  1029cb:	90                   	nop
  1029cc:	90                   	nop
  1029cd:	90                   	nop
  1029ce:	90                   	nop
  1029cf:	90                   	nop
            if (this->operator[](a) == 0)
  1029d0:	80 7c 04 31 00       	cmp    BYTE PTR [esp+eax*1+0x31],0x0
  1029d5:	74 08                	je     1029df <kernel_main+0xdff>
        for (int a = 0; a < N; a++) {
  1029d7:	40                   	inc    eax
  1029d8:	83 f8 4b             	cmp    eax,0x4b
  1029db:	75 f3                	jne    1029d0 <kernel_main+0xdf0>
  1029dd:	eb 11                	jmp    1029f0 <kernel_main+0xe10>
        return p[length()] == 0;
  1029df:	85 c0                	test   eax,eax
        if (command == "reset") {
  1029e1:	75 0d                	jne    1029f0 <kernel_main+0xe10>
    asm volatile("outb %%al,%%dx" ::"d"(port), "a"(byte));
  1029e3:	66 ba 64 00          	mov    dx,0x64
  1029e7:	b0 fe                	mov    al,0xfe
  1029e9:	ee                   	out    dx,al
  1029ea:	90                   	nop
  1029eb:	90                   	nop
  1029ec:	90                   	nop
  1029ed:	90                   	nop
  1029ee:	90                   	nop
  1029ef:	90                   	nop
  1029f0:	31 c0                	xor    eax,eax
  1029f2:	90                   	nop
  1029f3:	90                   	nop
  1029f4:	90                   	nop
  1029f5:	90                   	nop
  1029f6:	90                   	nop
  1029f7:	90                   	nop
  1029f8:	90                   	nop
  1029f9:	90                   	nop
  1029fa:	90                   	nop
  1029fb:	90                   	nop
  1029fc:	90                   	nop
  1029fd:	90                   	nop
  1029fe:	90                   	nop
  1029ff:	90                   	nop
  102a00:	31 c9                	xor    ecx,ecx
  102a02:	90                   	nop
  102a03:	90                   	nop
  102a04:	90                   	nop
  102a05:	90                   	nop
  102a06:	90                   	nop
  102a07:	90                   	nop
  102a08:	90                   	nop
  102a09:	90                   	nop
  102a0a:	90                   	nop
  102a0b:	90                   	nop
  102a0c:	90                   	nop
  102a0d:	90                   	nop
  102a0e:	90                   	nop
  102a0f:	90                   	nop
            if (this->operator[](a) == 0)
  102a10:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102a15:	74 0b                	je     102a22 <kernel_main+0xe42>
        for (int a = 0; a < N; a++) {
  102a17:	41                   	inc    ecx
  102a18:	83 f9 50             	cmp    ecx,0x50
  102a1b:	75 f3                	jne    102a10 <kernel_main+0xe30>
  102a1d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  102a22:	39 c8                	cmp    eax,ecx
  102a24:	73 1a                	jae    102a40 <kernel_main+0xe60>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102a26:	83 f8 05             	cmp    eax,0x5
  102a29:	74 45                	je     102a70 <kernel_main+0xe90>
  102a2b:	8a 88 86 00 10 00    	mov    cl,BYTE PTR [eax+0x100086]
  102a31:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  102a35:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102a38:	74 c6                	je     102a00 <kernel_main+0xe20>
  102a3a:	eb 34                	jmp    102a70 <kernel_main+0xe90>
  102a3c:	90                   	nop
  102a3d:	90                   	nop
  102a3e:	90                   	nop
  102a3f:	90                   	nop
  102a40:	b8 fb ff ff ff       	mov    eax,0xfffffffb
  102a45:	90                   	nop
  102a46:	90                   	nop
  102a47:	90                   	nop
  102a48:	90                   	nop
  102a49:	90                   	nop
  102a4a:	90                   	nop
  102a4b:	90                   	nop
  102a4c:	90                   	nop
  102a4d:	90                   	nop
  102a4e:	90                   	nop
  102a4f:	90                   	nop
            if (this->operator[](a) == 0)
  102a50:	80 7c 04 31 00       	cmp    BYTE PTR [esp+eax*1+0x31],0x0
  102a55:	74 08                	je     102a5f <kernel_main+0xe7f>
        for (int a = 0; a < N; a++) {
  102a57:	40                   	inc    eax
  102a58:	83 f8 4b             	cmp    eax,0x4b
  102a5b:	75 f3                	jne    102a50 <kernel_main+0xe70>
  102a5d:	eb 11                	jmp    102a70 <kernel_main+0xe90>
        return p[length()] == 0;
  102a5f:	85 c0                	test   eax,eax
        if (command == "clear") {
  102a61:	75 0d                	jne    102a70 <kernel_main+0xe90>
            term::clear();
  102a63:	e8 e8 e5 ff ff       	call   101050 <term::clear()>
  102a68:	90                   	nop
  102a69:	90                   	nop
  102a6a:	90                   	nop
  102a6b:	90                   	nop
  102a6c:	90                   	nop
  102a6d:	90                   	nop
  102a6e:	90                   	nop
  102a6f:	90                   	nop
  102a70:	31 c0                	xor    eax,eax
  102a72:	90                   	nop
  102a73:	90                   	nop
  102a74:	90                   	nop
  102a75:	90                   	nop
  102a76:	90                   	nop
  102a77:	90                   	nop
  102a78:	90                   	nop
  102a79:	90                   	nop
  102a7a:	90                   	nop
  102a7b:	90                   	nop
  102a7c:	90                   	nop
  102a7d:	90                   	nop
  102a7e:	90                   	nop
  102a7f:	90                   	nop
  102a80:	31 c9                	xor    ecx,ecx
  102a82:	90                   	nop
  102a83:	90                   	nop
  102a84:	90                   	nop
  102a85:	90                   	nop
  102a86:	90                   	nop
  102a87:	90                   	nop
  102a88:	90                   	nop
  102a89:	90                   	nop
  102a8a:	90                   	nop
  102a8b:	90                   	nop
  102a8c:	90                   	nop
  102a8d:	90                   	nop
  102a8e:	90                   	nop
  102a8f:	90                   	nop
            if (this->operator[](a) == 0)
  102a90:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102a95:	74 0b                	je     102aa2 <kernel_main+0xec2>
        for (int a = 0; a < N; a++) {
  102a97:	41                   	inc    ecx
  102a98:	83 f9 50             	cmp    ecx,0x50
  102a9b:	75 f3                	jne    102a90 <kernel_main+0xeb0>
  102a9d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  102aa2:	39 c8                	cmp    eax,ecx
  102aa4:	73 2a                	jae    102ad0 <kernel_main+0xef0>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102aa6:	83 f8 04             	cmp    eax,0x4
  102aa9:	0f 84 51 02 00 00    	je     102d00 <kernel_main+0x1120>
  102aaf:	8a 88 0c 00 10 00    	mov    cl,BYTE PTR [eax+0x10000c]
  102ab5:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  102ab9:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102abc:	74 c2                	je     102a80 <kernel_main+0xea0>
  102abe:	e9 3d 02 00 00       	jmp    102d00 <kernel_main+0x1120>
  102ac3:	90                   	nop
  102ac4:	90                   	nop
  102ac5:	90                   	nop
  102ac6:	90                   	nop
  102ac7:	90                   	nop
  102ac8:	90                   	nop
  102ac9:	90                   	nop
  102aca:	90                   	nop
  102acb:	90                   	nop
  102acc:	90                   	nop
  102acd:	90                   	nop
  102ace:	90                   	nop
  102acf:	90                   	nop
  102ad0:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  102ad5:	90                   	nop
  102ad6:	90                   	nop
  102ad7:	90                   	nop
  102ad8:	90                   	nop
  102ad9:	90                   	nop
  102ada:	90                   	nop
  102adb:	90                   	nop
  102adc:	90                   	nop
  102add:	90                   	nop
  102ade:	90                   	nop
  102adf:	90                   	nop
            if (this->operator[](a) == 0)
  102ae0:	80 7c 04 30 00       	cmp    BYTE PTR [esp+eax*1+0x30],0x0
  102ae5:	74 0b                	je     102af2 <kernel_main+0xf12>
        for (int a = 0; a < N; a++) {
  102ae7:	40                   	inc    eax
  102ae8:	83 f8 4c             	cmp    eax,0x4c
  102aeb:	75 f3                	jne    102ae0 <kernel_main+0xf00>
  102aed:	e9 0e 02 00 00       	jmp    102d00 <kernel_main+0x1120>
        return p[length()] == 0;
  102af2:	85 c0                	test   eax,eax
        if (command == "read") {
  102af4:	0f 85 06 02 00 00    	jne    102d00 <kernel_main+0x1120>
  102afa:	31 c0                	xor    eax,eax
  102afc:	90                   	nop
  102afd:	90                   	nop
  102afe:	90                   	nop
  102aff:	90                   	nop
            if (this->operator[](a) == 0)
  102b00:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  102b07:	00 
  102b08:	74 0b                	je     102b15 <kernel_main+0xf35>
        for (int a = 0; a < N; a++) {
  102b0a:	40                   	inc    eax
  102b0b:	83 f8 50             	cmp    eax,0x50
  102b0e:	75 f0                	jne    102b00 <kernel_main+0xf20>
  102b10:	b8 50 00 00 00       	mov    eax,0x50
        return dual_iterator<const char>(this->data_ + length());
  102b15:	8d 8c 04 b4 00 00 00 	lea    ecx,[esp+eax*1+0xb4]
  102b1c:	8d 94 24 b4 00 00 00 	lea    edx,[esp+0xb4]
        return ptr_ != p.ptr_;
  102b23:	39 ca                	cmp    edx,ecx
    for (auto c : p) {
  102b25:	74 5c                	je     102b83 <kernel_main+0xfa3>
  102b27:	31 c9                	xor    ecx,ecx
  102b29:	90                   	nop
  102b2a:	90                   	nop
  102b2b:	90                   	nop
  102b2c:	90                   	nop
  102b2d:	90                   	nop
  102b2e:	90                   	nop
  102b2f:	90                   	nop
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  102b30:	0f be 32             	movsx  esi,BYTE PTR [edx]
        r *= B;
  102b33:	c1 e1 04             	shl    ecx,0x4
        r += static_cast<int>(c.value - '0');
  102b36:	8d 4c 31 d0          	lea    ecx,[ecx+esi*1-0x30]
        ptr_++;
  102b3a:	42                   	inc    edx
        return ptr_ != p.ptr_;
  102b3b:	48                   	dec    eax
    for (auto c : p) {
  102b3c:	75 f2                	jne    102b30 <kernel_main+0xf50>
  102b3e:	eb 45                	jmp    102b85 <kernel_main+0xfa5>
  102b40:	31 f6                	xor    esi,esi
  102b42:	90                   	nop
  102b43:	90                   	nop
  102b44:	90                   	nop
  102b45:	90                   	nop
  102b46:	90                   	nop
  102b47:	90                   	nop
  102b48:	90                   	nop
  102b49:	90                   	nop
  102b4a:	90                   	nop
  102b4b:	90                   	nop
  102b4c:	90                   	nop
  102b4d:	90                   	nop
  102b4e:	90                   	nop
  102b4f:	90                   	nop
            for (auto a : range<0, (term::ROWS + 2) * term::COLS>) {
                (void)a;
                term::write(char('$' + (rnd.next(40))));
  102b50:	6a 28                	push   0x28
  102b52:	53                   	push   ebx
  102b53:	e8 a8 15 00 00       	call   104100 <rand::random_gen::next(unsigned int)>
  102b58:	83 c4 08             	add    esp,0x8
  102b5b:	04 24                	add    al,0x24
  102b5d:	0f be c0             	movsx  eax,al
  102b60:	50                   	push   eax
  102b61:	e8 da e5 ff ff       	call   101140 <term::write(char)>
  102b66:	83 c4 04             	add    esp,0x4
  102b69:	b8 00 00 14 00       	mov    eax,0x140000
  102b6e:	90                   	nop
  102b6f:	90                   	nop
        asm volatile ("and %eax,%eax");
  102b70:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  102b72:	48                   	dec    eax
  102b73:	75 fb                	jne    102b70 <kernel_main+0xf90>
            value++;
  102b75:	46                   	inc    esi
            return value != p.value;
  102b76:	81 fe 70 08 00 00    	cmp    esi,0x870
  102b7c:	75 d2                	jne    102b50 <kernel_main+0xf70>
  102b7e:	e9 ad fb ff ff       	jmp    102730 <kernel_main+0xb50>
  102b83:	31 c9                	xor    ecx,ecx
            term::write("-> 0x", int_to_string<16>(*address).str(), "\n");
  102b85:	8b 11                	mov    edx,DWORD PTR [ecx]
    constexpr array() : data_{T()} {}
  102b87:	c7 84 24 2b 01 00 00 	mov    DWORD PTR [esp+0x12b],0x0
  102b8e:	00 00 00 00 
  102b92:	c7 84 24 28 01 00 00 	mov    DWORD PTR [esp+0x128],0x0
  102b99:	00 00 00 00 
  102b9d:	c7 84 24 24 01 00 00 	mov    DWORD PTR [esp+0x124],0x0
  102ba4:	00 00 00 00 
  102ba8:	c7 84 24 20 01 00 00 	mov    DWORD PTR [esp+0x120],0x0
  102baf:	00 00 00 00 
  102bb3:	c7 84 24 1c 01 00 00 	mov    DWORD PTR [esp+0x11c],0x0
  102bba:	00 00 00 00 
  102bbe:	c7 84 24 18 01 00 00 	mov    DWORD PTR [esp+0x118],0x0
  102bc5:	00 00 00 00 
  102bc9:	c7 84 24 14 01 00 00 	mov    DWORD PTR [esp+0x114],0x0
  102bd0:	00 00 00 00 
  102bd4:	c7 84 24 10 01 00 00 	mov    DWORD PTR [esp+0x110],0x0
  102bdb:	00 00 00 00 
    int index_ = 0;
  102bdf:	c7 84 24 30 01 00 00 	mov    DWORD PTR [esp+0x130],0x0
  102be6:	00 00 00 00 
    if (x == 0)
  102bea:	85 d2                	test   edx,edx
  102bec:	0f 84 82 00 00 00    	je     102c74 <kernel_main+0x1094>
  102bf2:	31 f6                	xor    esi,esi
  102bf4:	b9 01 00 00 00       	mov    ecx,0x1
  102bf9:	8d 84 24 10 01 00 00 	lea    eax,[esp+0x110]
  102c00:	89 0c 24             	mov    DWORD PTR [esp],ecx
  102c03:	89 c7                	mov    edi,eax
        if ((x % B) < 10)
  102c05:	89 d0                	mov    eax,edx
  102c07:	83 e0 0f             	and    eax,0xf
  102c0a:	89 c1                	mov    ecx,eax
  102c0c:	80 c9 30             	or     cl,0x30
  102c0f:	88 d5                	mov    ch,dl
  102c11:	80 c5 06             	add    ch,0x6
  102c14:	80 e5 0f             	and    ch,0xf
  102c17:	80 c5 41             	add    ch,0x41
  102c1a:	83 f8 0a             	cmp    eax,0xa
  102c1d:	0f b6 c1             	movzx  eax,cl
  102c20:	0f b6 cd             	movzx  ecx,ch
  102c23:	0f 42 c8             	cmovb  ecx,eax
        r[a] = i2c(x);
  102c26:	88 8c 34 10 01 00 00 	mov    BYTE PTR [esp+esi*1+0x110],cl
        x /= B;
  102c2d:	c1 ea 04             	shr    edx,0x4
    for (; x > 0; a++) {
  102c30:	46                   	inc    esi
  102c31:	8b 04 24             	mov    eax,DWORD PTR [esp]
  102c34:	8d 48 01             	lea    ecx,[eax+0x1]
  102c37:	8d 47 01             	lea    eax,[edi+0x1]
  102c3a:	85 d2                	test   edx,edx
  102c3c:	75 c2                	jne    102c00 <kernel_main+0x1020>
    r[a] = 0;
  102c3e:	c6 84 34 10 01 00 00 	mov    BYTE PTR [esp+esi*1+0x110],0x0
  102c45:	00 
    for (auto b = 0; b < a / 2; b++) {
  102c46:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  102c4c:	8b 0c 24             	mov    ecx,DWORD PTR [esp]
  102c4f:	74 2d                	je     102c7e <kernel_main+0x109e>
  102c51:	d1 e9                	shr    ecx,1
  102c53:	8d 94 24 10 01 00 00 	lea    edx,[esp+0x110]
  102c5a:	90                   	nop
  102c5b:	90                   	nop
  102c5c:	90                   	nop
  102c5d:	90                   	nop
  102c5e:	90                   	nop
  102c5f:	90                   	nop
        r[b] ^= r[a - b - 1];
  102c60:	0f b6 02             	movzx  eax,BYTE PTR [edx]
  102c63:	32 07                	xor    al,BYTE PTR [edi]
  102c65:	88 02                	mov    BYTE PTR [edx],al
        r[a - b - 1] ^= r[b];
  102c67:	32 07                	xor    al,BYTE PTR [edi]
  102c69:	88 07                	mov    BYTE PTR [edi],al
        r[b] ^= r[a - b - 1];
  102c6b:	30 02                	xor    BYTE PTR [edx],al
    for (auto b = 0; b < a / 2; b++) {
  102c6d:	42                   	inc    edx
  102c6e:	4f                   	dec    edi
  102c6f:	49                   	dec    ecx
  102c70:	75 ee                	jne    102c60 <kernel_main+0x1080>
  102c72:	eb 0a                	jmp    102c7e <kernel_main+0x109e>
        r[a++] = '0';
  102c74:	66 c7 84 24 10 01 00 	mov    WORD PTR [esp+0x110],0x30
  102c7b:	00 30 00 
    return r;
  102c7e:	b9 09 00 00 00       	mov    ecx,0x9
  102c83:	8d bc 24 88 00 00 00 	lea    edi,[esp+0x88]
  102c8a:	8d b4 24 10 01 00 00 	lea    esi,[esp+0x110]
  102c91:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  102c93:	6a 2d                	push   0x2d
  102c95:	e8 a6 e4 ff ff       	call   101140 <term::write(char)>
  102c9a:	83 c4 04             	add    esp,0x4
  102c9d:	6a 3e                	push   0x3e
  102c9f:	e8 9c e4 ff ff       	call   101140 <term::write(char)>
  102ca4:	83 c4 04             	add    esp,0x4
  102ca7:	6a 20                	push   0x20
  102ca9:	e8 92 e4 ff ff       	call   101140 <term::write(char)>
  102cae:	83 c4 04             	add    esp,0x4
  102cb1:	6a 30                	push   0x30
  102cb3:	e8 88 e4 ff ff       	call   101140 <term::write(char)>
  102cb8:	83 c4 04             	add    esp,0x4
  102cbb:	6a 78                	push   0x78
  102cbd:	e8 7e e4 ff ff       	call   101140 <term::write(char)>
  102cc2:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102cc5:	8a 84 24 88 00 00 00 	mov    al,BYTE PTR [esp+0x88]
  102ccc:	84 c0                	test   al,al
  102cce:	74 24                	je     102cf4 <kernel_main+0x1114>
  102cd0:	8d b4 24 89 00 00 00 	lea    esi,[esp+0x89]
  102cd7:	90                   	nop
  102cd8:	90                   	nop
  102cd9:	90                   	nop
  102cda:	90                   	nop
  102cdb:	90                   	nop
  102cdc:	90                   	nop
  102cdd:	90                   	nop
  102cde:	90                   	nop
  102cdf:	90                   	nop
        write(s[a]);
  102ce0:	0f be c0             	movsx  eax,al
  102ce3:	50                   	push   eax
  102ce4:	e8 57 e4 ff ff       	call   101140 <term::write(char)>
  102ce9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102cec:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  102cef:	46                   	inc    esi
  102cf0:	84 c0                	test   al,al
  102cf2:	75 ec                	jne    102ce0 <kernel_main+0x1100>
        write(s[a]);
  102cf4:	6a 0a                	push   0xa
  102cf6:	e8 45 e4 ff ff       	call   101140 <term::write(char)>
  102cfb:	83 c4 04             	add    esp,0x4
  102cfe:	90                   	nop
  102cff:	90                   	nop
  102d00:	31 c0                	xor    eax,eax
  102d02:	90                   	nop
  102d03:	90                   	nop
  102d04:	90                   	nop
  102d05:	90                   	nop
  102d06:	90                   	nop
  102d07:	90                   	nop
  102d08:	90                   	nop
  102d09:	90                   	nop
  102d0a:	90                   	nop
  102d0b:	90                   	nop
  102d0c:	90                   	nop
  102d0d:	90                   	nop
  102d0e:	90                   	nop
  102d0f:	90                   	nop
  102d10:	31 c9                	xor    ecx,ecx
  102d12:	90                   	nop
  102d13:	90                   	nop
  102d14:	90                   	nop
  102d15:	90                   	nop
  102d16:	90                   	nop
  102d17:	90                   	nop
  102d18:	90                   	nop
  102d19:	90                   	nop
  102d1a:	90                   	nop
  102d1b:	90                   	nop
  102d1c:	90                   	nop
  102d1d:	90                   	nop
  102d1e:	90                   	nop
  102d1f:	90                   	nop
            if (this->operator[](a) == 0)
  102d20:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102d25:	74 0b                	je     102d32 <kernel_main+0x1152>
        for (int a = 0; a < N; a++) {
  102d27:	41                   	inc    ecx
  102d28:	83 f9 50             	cmp    ecx,0x50
  102d2b:	75 f3                	jne    102d20 <kernel_main+0x1140>
  102d2d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  102d32:	39 c8                	cmp    eax,ecx
  102d34:	73 1a                	jae    102d50 <kernel_main+0x1170>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102d36:	83 f8 04             	cmp    eax,0x4
  102d39:	74 45                	je     102d80 <kernel_main+0x11a0>
  102d3b:	8a 88 8c 00 10 00    	mov    cl,BYTE PTR [eax+0x10008c]
  102d41:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  102d45:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102d48:	74 c6                	je     102d10 <kernel_main+0x1130>
  102d4a:	eb 34                	jmp    102d80 <kernel_main+0x11a0>
  102d4c:	90                   	nop
  102d4d:	90                   	nop
  102d4e:	90                   	nop
  102d4f:	90                   	nop
  102d50:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  102d55:	90                   	nop
  102d56:	90                   	nop
  102d57:	90                   	nop
  102d58:	90                   	nop
  102d59:	90                   	nop
  102d5a:	90                   	nop
  102d5b:	90                   	nop
  102d5c:	90                   	nop
  102d5d:	90                   	nop
  102d5e:	90                   	nop
  102d5f:	90                   	nop
            if (this->operator[](a) == 0)
  102d60:	80 7c 04 30 00       	cmp    BYTE PTR [esp+eax*1+0x30],0x0
  102d65:	74 08                	je     102d6f <kernel_main+0x118f>
        for (int a = 0; a < N; a++) {
  102d67:	40                   	inc    eax
  102d68:	83 f8 4c             	cmp    eax,0x4c
  102d6b:	75 f3                	jne    102d60 <kernel_main+0x1180>
  102d6d:	eb 11                	jmp    102d80 <kernel_main+0x11a0>
        return p[length()] == 0;
  102d6f:	85 c0                	test   eax,eax
        if (command == "flip") {
  102d71:	75 0d                	jne    102d80 <kernel_main+0x11a0>
            term::Term.flipped = !term::Term.flipped;
  102d73:	80 35 0d 60 10 00 01 	xor    BYTE PTR ds:0x10600d,0x1
  102d7a:	90                   	nop
  102d7b:	90                   	nop
  102d7c:	90                   	nop
  102d7d:	90                   	nop
  102d7e:	90                   	nop
  102d7f:	90                   	nop
  102d80:	31 c0                	xor    eax,eax
  102d82:	90                   	nop
  102d83:	90                   	nop
  102d84:	90                   	nop
  102d85:	90                   	nop
  102d86:	90                   	nop
  102d87:	90                   	nop
  102d88:	90                   	nop
  102d89:	90                   	nop
  102d8a:	90                   	nop
  102d8b:	90                   	nop
  102d8c:	90                   	nop
  102d8d:	90                   	nop
  102d8e:	90                   	nop
  102d8f:	90                   	nop
  102d90:	31 c9                	xor    ecx,ecx
  102d92:	90                   	nop
  102d93:	90                   	nop
  102d94:	90                   	nop
  102d95:	90                   	nop
  102d96:	90                   	nop
  102d97:	90                   	nop
  102d98:	90                   	nop
  102d99:	90                   	nop
  102d9a:	90                   	nop
  102d9b:	90                   	nop
  102d9c:	90                   	nop
  102d9d:	90                   	nop
  102d9e:	90                   	nop
  102d9f:	90                   	nop
            if (this->operator[](a) == 0)
  102da0:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102da5:	74 0b                	je     102db2 <kernel_main+0x11d2>
        for (int a = 0; a < N; a++) {
  102da7:	41                   	inc    ecx
  102da8:	83 f9 50             	cmp    ecx,0x50
  102dab:	75 f3                	jne    102da0 <kernel_main+0x11c0>
  102dad:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  102db2:	39 c8                	cmp    eax,ecx
  102db4:	73 2a                	jae    102de0 <kernel_main+0x1200>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102db6:	83 f8 04             	cmp    eax,0x4
  102db9:	0f 84 41 01 00 00    	je     102f00 <kernel_main+0x1320>
  102dbf:	8a 88 cd 00 10 00    	mov    cl,BYTE PTR [eax+0x1000cd]
  102dc5:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  102dc9:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102dcc:	74 c2                	je     102d90 <kernel_main+0x11b0>
  102dce:	e9 2d 01 00 00       	jmp    102f00 <kernel_main+0x1320>
  102dd3:	90                   	nop
  102dd4:	90                   	nop
  102dd5:	90                   	nop
  102dd6:	90                   	nop
  102dd7:	90                   	nop
  102dd8:	90                   	nop
  102dd9:	90                   	nop
  102dda:	90                   	nop
  102ddb:	90                   	nop
  102ddc:	90                   	nop
  102ddd:	90                   	nop
  102dde:	90                   	nop
  102ddf:	90                   	nop
  102de0:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  102de5:	90                   	nop
  102de6:	90                   	nop
  102de7:	90                   	nop
  102de8:	90                   	nop
  102de9:	90                   	nop
  102dea:	90                   	nop
  102deb:	90                   	nop
  102dec:	90                   	nop
  102ded:	90                   	nop
  102dee:	90                   	nop
  102def:	90                   	nop
            if (this->operator[](a) == 0)
  102df0:	80 7c 04 30 00       	cmp    BYTE PTR [esp+eax*1+0x30],0x0
  102df5:	74 0b                	je     102e02 <kernel_main+0x1222>
        for (int a = 0; a < N; a++) {
  102df7:	40                   	inc    eax
  102df8:	83 f8 4c             	cmp    eax,0x4c
  102dfb:	75 f3                	jne    102df0 <kernel_main+0x1210>
  102dfd:	e9 fe 00 00 00       	jmp    102f00 <kernel_main+0x1320>
        return p[length()] == 0;
  102e02:	85 c0                	test   eax,eax
        if (command == "stoi") {
  102e04:	0f 85 f6 00 00 00    	jne    102f00 <kernel_main+0x1320>
  102e0a:	31 c0                	xor    eax,eax
  102e0c:	90                   	nop
  102e0d:	90                   	nop
  102e0e:	90                   	nop
  102e0f:	90                   	nop
            if (this->operator[](a) == 0)
  102e10:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  102e17:	00 
  102e18:	74 08                	je     102e22 <kernel_main+0x1242>
        for (int a = 0; a < N; a++) {
  102e1a:	40                   	inc    eax
  102e1b:	83 f8 50             	cmp    eax,0x50
  102e1e:	75 f0                	jne    102e10 <kernel_main+0x1230>
  102e20:	eb 04                	jmp    102e26 <kernel_main+0x1246>
        for (int a = 0; a < length(); a++) {
  102e22:	85 c0                	test   eax,eax
  102e24:	74 64                	je     102e8a <kernel_main+0x12aa>
  102e26:	6a 6e                	push   0x6e
  102e28:	e8 13 e3 ff ff       	call   101140 <term::write(char)>
  102e2d:	83 c4 04             	add    esp,0x4
  102e30:	6a 6f                	push   0x6f
  102e32:	e8 09 e3 ff ff       	call   101140 <term::write(char)>
  102e37:	83 c4 04             	add    esp,0x4
  102e3a:	6a 6e                	push   0x6e
  102e3c:	e8 ff e2 ff ff       	call   101140 <term::write(char)>
  102e41:	83 c4 04             	add    esp,0x4
  102e44:	6a 2d                	push   0x2d
  102e46:	e8 f5 e2 ff ff       	call   101140 <term::write(char)>
  102e4b:	83 c4 04             	add    esp,0x4
  102e4e:	6a 65                	push   0x65
  102e50:	e8 eb e2 ff ff       	call   101140 <term::write(char)>
  102e55:	83 c4 04             	add    esp,0x4
  102e58:	6a 6d                	push   0x6d
  102e5a:	e8 e1 e2 ff ff       	call   101140 <term::write(char)>
  102e5f:	83 c4 04             	add    esp,0x4
  102e62:	6a 70                	push   0x70
  102e64:	e8 d7 e2 ff ff       	call   101140 <term::write(char)>
  102e69:	83 c4 04             	add    esp,0x4
  102e6c:	6a 74                	push   0x74
  102e6e:	e8 cd e2 ff ff       	call   101140 <term::write(char)>
  102e73:	83 c4 04             	add    esp,0x4
  102e76:	6a 79                	push   0x79
  102e78:	e8 c3 e2 ff ff       	call   101140 <term::write(char)>
  102e7d:	83 c4 04             	add    esp,0x4
  102e80:	6a 20                	push   0x20
  102e82:	e8 b9 e2 ff ff       	call   101140 <term::write(char)>
  102e87:	83 c4 04             	add    esp,0x4
  102e8a:	6a 4f                	push   0x4f
  102e8c:	e8 af e2 ff ff       	call   101140 <term::write(char)>
  102e91:	83 c4 04             	add    esp,0x4
  102e94:	6a 4b                	push   0x4b
  102e96:	e8 a5 e2 ff ff       	call   101140 <term::write(char)>
  102e9b:	83 c4 04             	add    esp,0x4
  102e9e:	6a 3a                	push   0x3a
  102ea0:	e8 9b e2 ff ff       	call   101140 <term::write(char)>
  102ea5:	83 c4 04             	add    esp,0x4
  102ea8:	6a 20                	push   0x20
  102eaa:	e8 91 e2 ff ff       	call   101140 <term::write(char)>
  102eaf:	83 c4 04             	add    esp,0x4
  102eb2:	6a 27                	push   0x27
  102eb4:	e8 87 e2 ff ff       	call   101140 <term::write(char)>
  102eb9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102ebc:	8a 84 24 b4 00 00 00 	mov    al,BYTE PTR [esp+0xb4]
  102ec3:	84 c0                	test   al,al
  102ec5:	74 1d                	je     102ee4 <kernel_main+0x1304>
  102ec7:	8d b4 24 b5 00 00 00 	lea    esi,[esp+0xb5]
  102ece:	90                   	nop
  102ecf:	90                   	nop
        write(s[a]);
  102ed0:	0f be c0             	movsx  eax,al
  102ed3:	50                   	push   eax
  102ed4:	e8 67 e2 ff ff       	call   101140 <term::write(char)>
  102ed9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  102edc:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  102edf:	46                   	inc    esi
  102ee0:	84 c0                	test   al,al
  102ee2:	75 ec                	jne    102ed0 <kernel_main+0x12f0>
        write(s[a]);
  102ee4:	6a 27                	push   0x27
  102ee6:	e8 55 e2 ff ff       	call   101140 <term::write(char)>
  102eeb:	83 c4 04             	add    esp,0x4
  102eee:	6a 0a                	push   0xa
  102ef0:	e8 4b e2 ff ff       	call   101140 <term::write(char)>
  102ef5:	83 c4 04             	add    esp,0x4
  102ef8:	90                   	nop
  102ef9:	90                   	nop
  102efa:	90                   	nop
  102efb:	90                   	nop
  102efc:	90                   	nop
  102efd:	90                   	nop
  102efe:	90                   	nop
  102eff:	90                   	nop
  102f00:	31 c0                	xor    eax,eax
  102f02:	90                   	nop
  102f03:	90                   	nop
  102f04:	90                   	nop
  102f05:	90                   	nop
  102f06:	90                   	nop
  102f07:	90                   	nop
  102f08:	90                   	nop
  102f09:	90                   	nop
  102f0a:	90                   	nop
  102f0b:	90                   	nop
  102f0c:	90                   	nop
  102f0d:	90                   	nop
  102f0e:	90                   	nop
  102f0f:	90                   	nop
  102f10:	31 c9                	xor    ecx,ecx
  102f12:	90                   	nop
  102f13:	90                   	nop
  102f14:	90                   	nop
  102f15:	90                   	nop
  102f16:	90                   	nop
  102f17:	90                   	nop
  102f18:	90                   	nop
  102f19:	90                   	nop
  102f1a:	90                   	nop
  102f1b:	90                   	nop
  102f1c:	90                   	nop
  102f1d:	90                   	nop
  102f1e:	90                   	nop
  102f1f:	90                   	nop
            if (this->operator[](a) == 0)
  102f20:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  102f25:	74 0b                	je     102f32 <kernel_main+0x1352>
        for (int a = 0; a < N; a++) {
  102f27:	41                   	inc    ecx
  102f28:	83 f9 50             	cmp    ecx,0x50
  102f2b:	75 f3                	jne    102f20 <kernel_main+0x1340>
  102f2d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  102f32:	39 c8                	cmp    eax,ecx
  102f34:	73 2a                	jae    102f60 <kernel_main+0x1380>
            if (p[a] == 0 || p[a] != this->operator[](a))
  102f36:	83 f8 03             	cmp    eax,0x3
  102f39:	0f 84 71 06 00 00    	je     1035b0 <kernel_main+0x19d0>
  102f3f:	8a 88 5b 00 10 00    	mov    cl,BYTE PTR [eax+0x10005b]
  102f45:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  102f49:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  102f4c:	74 c2                	je     102f10 <kernel_main+0x1330>
  102f4e:	e9 5d 06 00 00       	jmp    1035b0 <kernel_main+0x19d0>
  102f53:	90                   	nop
  102f54:	90                   	nop
  102f55:	90                   	nop
  102f56:	90                   	nop
  102f57:	90                   	nop
  102f58:	90                   	nop
  102f59:	90                   	nop
  102f5a:	90                   	nop
  102f5b:	90                   	nop
  102f5c:	90                   	nop
  102f5d:	90                   	nop
  102f5e:	90                   	nop
  102f5f:	90                   	nop
  102f60:	b8 fd ff ff ff       	mov    eax,0xfffffffd
  102f65:	90                   	nop
  102f66:	90                   	nop
  102f67:	90                   	nop
  102f68:	90                   	nop
  102f69:	90                   	nop
  102f6a:	90                   	nop
  102f6b:	90                   	nop
  102f6c:	90                   	nop
  102f6d:	90                   	nop
  102f6e:	90                   	nop
  102f6f:	90                   	nop
            if (this->operator[](a) == 0)
  102f70:	80 7c 04 2f 00       	cmp    BYTE PTR [esp+eax*1+0x2f],0x0
  102f75:	74 0b                	je     102f82 <kernel_main+0x13a2>
        for (int a = 0; a < N; a++) {
  102f77:	40                   	inc    eax
  102f78:	83 f8 4d             	cmp    eax,0x4d
  102f7b:	75 f3                	jne    102f70 <kernel_main+0x1390>
  102f7d:	e9 2e 06 00 00       	jmp    1035b0 <kernel_main+0x19d0>
        return p[length()] == 0;
  102f82:	85 c0                	test   eax,eax
        if (command == "mod") {
  102f84:	0f 85 26 06 00 00    	jne    1035b0 <kernel_main+0x19d0>
  102f8a:	31 c0                	xor    eax,eax
  102f8c:	90                   	nop
  102f8d:	90                   	nop
  102f8e:	90                   	nop
  102f8f:	90                   	nop
            if (this->operator[](a) == 0)
  102f90:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  102f97:	00 
  102f98:	74 08                	je     102fa2 <kernel_main+0x13c2>
        for (int a = 0; a < N; a++) {
  102f9a:	40                   	inc    eax
  102f9b:	83 f8 50             	cmp    eax,0x50
  102f9e:	75 f0                	jne    102f90 <kernel_main+0x13b0>
  102fa0:	eb 08                	jmp    102faa <kernel_main+0x13ca>
        for (int a = 0; a < length(); a++) {
  102fa2:	85 c0                	test   eax,eax
  102fa4:	0f 84 c8 01 00 00    	je     103172 <kernel_main+0x1592>
  102faa:	31 c0                	xor    eax,eax
  102fac:	90                   	nop
  102fad:	90                   	nop
  102fae:	90                   	nop
  102faf:	90                   	nop
            if (this->operator[](a) == 0)
  102fb0:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  102fb7:	00 
  102fb8:	74 0b                	je     102fc5 <kernel_main+0x13e5>
        for (int a = 0; a < N; a++) {
  102fba:	40                   	inc    eax
  102fbb:	83 f8 50             	cmp    eax,0x50
  102fbe:	75 f0                	jne    102fb0 <kernel_main+0x13d0>
  102fc0:	b8 50 00 00 00       	mov    eax,0x50
        return dual_iterator<const char>(this->data_ + length());
  102fc5:	8d 8c 04 b4 00 00 00 	lea    ecx,[esp+eax*1+0xb4]
  102fcc:	8d 94 24 b4 00 00 00 	lea    edx,[esp+0xb4]
        return ptr_ != p.ptr_;
  102fd3:	39 ca                	cmp    edx,ecx
    for (auto c : p) {
  102fd5:	0f 84 8b 01 00 00    	je     103166 <kernel_main+0x1586>
  102fdb:	31 c9                	xor    ecx,ecx
  102fdd:	90                   	nop
  102fde:	90                   	nop
  102fdf:	90                   	nop
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  102fe0:	0f be 32             	movsx  esi,BYTE PTR [edx]
        r *= B;
  102fe3:	8d 0c 89             	lea    ecx,[ecx+ecx*4]
        r += static_cast<int>(c.value - '0');
  102fe6:	8d 4c 4e d0          	lea    ecx,[esi+ecx*2-0x30]
        ptr_++;
  102fea:	42                   	inc    edx
        return ptr_ != p.ptr_;
  102feb:	48                   	dec    eax
    for (auto c : p) {
  102fec:	75 f2                	jne    102fe0 <kernel_main+0x1400>

    optional<module_proc> entry_point(int mod) {
        if (mod < count_)
  102fee:	39 4c 24 08          	cmp    DWORD PTR [esp+0x8],ecx
  102ff2:	0f 8e 7a 01 00 00    	jle    103172 <kernel_main+0x1592>
  102ff8:	31 c0                	xor    eax,eax
  102ffa:	90                   	nop
  102ffb:	90                   	nop
  102ffc:	90                   	nop
  102ffd:	90                   	nop
  102ffe:	90                   	nop
  102fff:	90                   	nop
            if (this->operator[](a) == 0)
  103000:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  103007:	00 
  103008:	74 0b                	je     103015 <kernel_main+0x1435>
        for (int a = 0; a < N; a++) {
  10300a:	40                   	inc    eax
  10300b:	83 f8 50             	cmp    eax,0x50
  10300e:	75 f0                	jne    103000 <kernel_main+0x1420>
  103010:	b8 50 00 00 00       	mov    eax,0x50
        return dual_iterator<const char>(this->data_ + length());
  103015:	8d 94 04 b4 00 00 00 	lea    edx,[esp+eax*1+0xb4]
  10301c:	31 c9                	xor    ecx,ecx
        return ptr_ != p.ptr_;
  10301e:	8d b4 24 b4 00 00 00 	lea    esi,[esp+0xb4]
  103025:	39 d6                	cmp    esi,edx
  103027:	ba 00 00 00 00       	mov    edx,0x0
    for (auto c : p) {
  10302c:	74 20                	je     10304e <kernel_main+0x146e>
  10302e:	31 d2                	xor    edx,edx
  103030:	8d b4 24 b4 00 00 00 	lea    esi,[esp+0xb4]
  103037:	90                   	nop
  103038:	90                   	nop
  103039:	90                   	nop
  10303a:	90                   	nop
  10303b:	90                   	nop
  10303c:	90                   	nop
  10303d:	90                   	nop
  10303e:	90                   	nop
  10303f:	90                   	nop
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  103040:	0f be 3e             	movsx  edi,BYTE PTR [esi]
        r *= B;
  103043:	8d 14 92             	lea    edx,[edx+edx*4]
        r += static_cast<int>(c.value - '0');
  103046:	8d 54 57 d0          	lea    edx,[edi+edx*2-0x30]
        ptr_++;
  10304a:	46                   	inc    esi
        return ptr_ != p.ptr_;
  10304b:	48                   	dec    eax
    for (auto c : p) {
  10304c:	75 f2                	jne    103040 <kernel_main+0x1460>
  10304e:	39 54 24 08          	cmp    DWORD PTR [esp+0x8],edx
  103052:	7e 11                	jle    103065 <kernel_main+0x1485>
            return reinterpret_cast<module_proc>(addr_[mod].mod_start +
  103054:	c1 e2 04             	shl    edx,0x4
  103057:	8b 44 24 10          	mov    eax,DWORD PTR [esp+0x10]
  10305b:	8b 0c 10             	mov    ecx,DWORD PTR [eax+edx*1]
  10305e:	b8 00 10 00 00       	mov    eax,0x1000
  103063:	01 c1                	add    ecx,eax
  103065:	b8 00 00 64 00       	mov    eax,0x640000
  10306a:	90                   	nop
  10306b:	90                   	nop
  10306c:	90                   	nop
  10306d:	90                   	nop
  10306e:	90                   	nop
  10306f:	90                   	nop
        asm volatile ("and %eax,%eax");
  103070:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  103072:	48                   	dec    eax
  103073:	75 fb                	jne    103070 <kernel_main+0x1490>
                term::write(">>> ", int_to_string<16>(proc()).str(), "\n");
  103075:	ff d1                	call   ecx
    constexpr array() : data_{T()} {}
  103077:	c7 84 24 2b 01 00 00 	mov    DWORD PTR [esp+0x12b],0x0
  10307e:	00 00 00 00 
  103082:	c7 84 24 28 01 00 00 	mov    DWORD PTR [esp+0x128],0x0
  103089:	00 00 00 00 
  10308d:	c7 84 24 24 01 00 00 	mov    DWORD PTR [esp+0x124],0x0
  103094:	00 00 00 00 
  103098:	c7 84 24 20 01 00 00 	mov    DWORD PTR [esp+0x120],0x0
  10309f:	00 00 00 00 
  1030a3:	c7 84 24 1c 01 00 00 	mov    DWORD PTR [esp+0x11c],0x0
  1030aa:	00 00 00 00 
  1030ae:	c7 84 24 18 01 00 00 	mov    DWORD PTR [esp+0x118],0x0
  1030b5:	00 00 00 00 
  1030b9:	c7 84 24 14 01 00 00 	mov    DWORD PTR [esp+0x114],0x0
  1030c0:	00 00 00 00 
  1030c4:	c7 84 24 10 01 00 00 	mov    DWORD PTR [esp+0x110],0x0
  1030cb:	00 00 00 00 
    int index_ = 0;
  1030cf:	c7 84 24 30 01 00 00 	mov    DWORD PTR [esp+0x130],0x0
  1030d6:	00 00 00 00 
    if (x == 0)
  1030da:	85 c0                	test   eax,eax
  1030dc:	0f 84 42 04 00 00    	je     103524 <kernel_main+0x1944>
  1030e2:	89 c7                	mov    edi,eax
    for (; x > 0; a++) {
  1030e4:	85 c0                	test   eax,eax
  1030e6:	0f 8e 47 04 00 00    	jle    103533 <kernel_main+0x1953>
  1030ec:	c7 04 24 00 00 00 00 	mov    DWORD PTR [esp],0x0
  1030f3:	b8 01 00 00 00       	mov    eax,0x1
  1030f8:	8d 94 24 10 01 00 00 	lea    edx,[esp+0x110]
  1030ff:	eb 4f                	jmp    103150 <kernel_main+0x1570>
  103101:	90                   	nop
  103102:	90                   	nop
  103103:	90                   	nop
  103104:	90                   	nop
  103105:	90                   	nop
  103106:	90                   	nop
  103107:	90                   	nop
  103108:	90                   	nop
  103109:	90                   	nop
  10310a:	90                   	nop
  10310b:	90                   	nop
  10310c:	90                   	nop
  10310d:	90                   	nop
  10310e:	90                   	nop
  10310f:	90                   	nop
            return 'A' + ((x - 10) % B);
  103110:	8d 47 f6             	lea    eax,[edi-0xa]
  103113:	8d 57 05             	lea    edx,[edi+0x5]
  103116:	85 c0                	test   eax,eax
  103118:	0f 49 d0             	cmovns edx,eax
  10311b:	81 e2 f0 00 00 00    	and    edx,0xf0
  103121:	f7 da                	neg    edx
  103123:	8d 44 17 f6          	lea    eax,[edi+edx*1-0xa]
  103127:	04 41                	add    al,0x41
  103129:	8b 0c 24             	mov    ecx,DWORD PTR [esp]
        r[a] = i2c(x);
  10312c:	88 84 0c 10 01 00 00 	mov    BYTE PTR [esp+ecx*1+0x110],al
        x /= B;
  103133:	c1 ef 04             	shr    edi,0x4
    for (; x > 0; a++) {
  103136:	41                   	inc    ecx
  103137:	89 0c 24             	mov    DWORD PTR [esp],ecx
  10313a:	8b 74 24 04          	mov    esi,DWORD PTR [esp+0x4]
  10313e:	8d 46 01             	lea    eax,[esi+0x1]
  103141:	8b 4c 24 0c          	mov    ecx,DWORD PTR [esp+0xc]
  103145:	8d 51 01             	lea    edx,[ecx+0x1]
  103148:	85 ff                	test   edi,edi
  10314a:	0f 84 9d 03 00 00    	je     1034ed <kernel_main+0x190d>
  103150:	89 44 24 04          	mov    DWORD PTR [esp+0x4],eax
  103154:	89 54 24 0c          	mov    DWORD PTR [esp+0xc],edx
        if ((x % B) < 10)
  103158:	89 f8                	mov    eax,edi
  10315a:	83 e0 0f             	and    eax,0xf
  10315d:	83 f8 09             	cmp    eax,0x9
  103160:	77 ae                	ja     103110 <kernel_main+0x1530>
            return '0' + (x % B);
  103162:	0c 30                	or     al,0x30
  103164:	eb c3                	jmp    103129 <kernel_main+0x1549>
  103166:	31 c9                	xor    ecx,ecx
        if (mod < count_)
  103168:	39 4c 24 08          	cmp    DWORD PTR [esp+0x8],ecx
  10316c:	0f 8f 86 fe ff ff    	jg     102ff8 <kernel_main+0x1418>
  103172:	6a 55                	push   0x55
  103174:	e8 c7 df ff ff       	call   101140 <term::write(char)>
  103179:	83 c4 04             	add    esp,0x4
  10317c:	6a 73                	push   0x73
  10317e:	e8 bd df ff ff       	call   101140 <term::write(char)>
  103183:	83 c4 04             	add    esp,0x4
  103186:	6a 61                	push   0x61
  103188:	e8 b3 df ff ff       	call   101140 <term::write(char)>
  10318d:	83 c4 04             	add    esp,0x4
  103190:	6a 67                	push   0x67
  103192:	e8 a9 df ff ff       	call   101140 <term::write(char)>
  103197:	83 c4 04             	add    esp,0x4
  10319a:	6a 65                	push   0x65
  10319c:	e8 9f df ff ff       	call   101140 <term::write(char)>
  1031a1:	83 c4 04             	add    esp,0x4
  1031a4:	6a 3a                	push   0x3a
  1031a6:	e8 95 df ff ff       	call   101140 <term::write(char)>
  1031ab:	83 c4 04             	add    esp,0x4
  1031ae:	6a 20                	push   0x20
  1031b0:	e8 8b df ff ff       	call   101140 <term::write(char)>
  1031b5:	83 c4 04             	add    esp,0x4
  1031b8:	6a 6d                	push   0x6d
  1031ba:	e8 81 df ff ff       	call   101140 <term::write(char)>
  1031bf:	83 c4 04             	add    esp,0x4
  1031c2:	6a 6f                	push   0x6f
  1031c4:	e8 77 df ff ff       	call   101140 <term::write(char)>
  1031c9:	83 c4 04             	add    esp,0x4
  1031cc:	6a 64                	push   0x64
  1031ce:	e8 6d df ff ff       	call   101140 <term::write(char)>
  1031d3:	83 c4 04             	add    esp,0x4
  1031d6:	6a 20                	push   0x20
  1031d8:	e8 63 df ff ff       	call   101140 <term::write(char)>
  1031dd:	83 c4 04             	add    esp,0x4
  1031e0:	6a 3c                	push   0x3c
  1031e2:	e8 59 df ff ff       	call   101140 <term::write(char)>
  1031e7:	83 c4 04             	add    esp,0x4
  1031ea:	6a 6e                	push   0x6e
  1031ec:	e8 4f df ff ff       	call   101140 <term::write(char)>
  1031f1:	83 c4 04             	add    esp,0x4
  1031f4:	6a 75                	push   0x75
  1031f6:	e8 45 df ff ff       	call   101140 <term::write(char)>
  1031fb:	83 c4 04             	add    esp,0x4
  1031fe:	6a 6d                	push   0x6d
  103200:	e8 3b df ff ff       	call   101140 <term::write(char)>
  103205:	83 c4 04             	add    esp,0x4
  103208:	6a 3e                	push   0x3e
  10320a:	e8 31 df ff ff       	call   101140 <term::write(char)>
  10320f:	83 c4 04             	add    esp,0x4
  103212:	6a 0a                	push   0xa
  103214:	e8 27 df ff ff       	call   101140 <term::write(char)>
  103219:	83 c4 04             	add    esp,0x4
  10321c:	6a 09                	push   0x9
  10321e:	e8 1d df ff ff       	call   101140 <term::write(char)>
  103223:	83 c4 04             	add    esp,0x4
  103226:	6a 6e                	push   0x6e
  103228:	e8 13 df ff ff       	call   101140 <term::write(char)>
  10322d:	83 c4 04             	add    esp,0x4
  103230:	6a 75                	push   0x75
  103232:	e8 09 df ff ff       	call   101140 <term::write(char)>
  103237:	83 c4 04             	add    esp,0x4
  10323a:	6a 6d                	push   0x6d
  10323c:	e8 ff de ff ff       	call   101140 <term::write(char)>
  103241:	83 c4 04             	add    esp,0x4
  103244:	6a 3a                	push   0x3a
  103246:	e8 f5 de ff ff       	call   101140 <term::write(char)>
  10324b:	83 c4 04             	add    esp,0x4
  10324e:	6a 20                	push   0x20
  103250:	e8 eb de ff ff       	call   101140 <term::write(char)>
  103255:	83 c4 04             	add    esp,0x4
  103258:	6a 6d                	push   0x6d
  10325a:	e8 e1 de ff ff       	call   101140 <term::write(char)>
  10325f:	83 c4 04             	add    esp,0x4
  103262:	6a 6f                	push   0x6f
  103264:	e8 d7 de ff ff       	call   101140 <term::write(char)>
  103269:	83 c4 04             	add    esp,0x4
  10326c:	6a 64                	push   0x64
  10326e:	e8 cd de ff ff       	call   101140 <term::write(char)>
  103273:	83 c4 04             	add    esp,0x4
  103276:	6a 75                	push   0x75
  103278:	e8 c3 de ff ff       	call   101140 <term::write(char)>
  10327d:	83 c4 04             	add    esp,0x4
  103280:	6a 6c                	push   0x6c
  103282:	e8 b9 de ff ff       	call   101140 <term::write(char)>
  103287:	83 c4 04             	add    esp,0x4
  10328a:	6a 65                	push   0x65
  10328c:	e8 af de ff ff       	call   101140 <term::write(char)>
  103291:	83 c4 04             	add    esp,0x4
  103294:	6a 20                	push   0x20
  103296:	e8 a5 de ff ff       	call   101140 <term::write(char)>
  10329b:	83 c4 04             	add    esp,0x4
  10329e:	6a 6e                	push   0x6e
  1032a0:	e8 9b de ff ff       	call   101140 <term::write(char)>
  1032a5:	83 c4 04             	add    esp,0x4
  1032a8:	6a 75                	push   0x75
  1032aa:	e8 91 de ff ff       	call   101140 <term::write(char)>
  1032af:	83 c4 04             	add    esp,0x4
  1032b2:	6a 6d                	push   0x6d
  1032b4:	e8 87 de ff ff       	call   101140 <term::write(char)>
  1032b9:	83 c4 04             	add    esp,0x4
  1032bc:	6a 62                	push   0x62
  1032be:	e8 7d de ff ff       	call   101140 <term::write(char)>
  1032c3:	83 c4 04             	add    esp,0x4
  1032c6:	6a 65                	push   0x65
  1032c8:	e8 73 de ff ff       	call   101140 <term::write(char)>
  1032cd:	83 c4 04             	add    esp,0x4
  1032d0:	6a 72                	push   0x72
  1032d2:	e8 69 de ff ff       	call   101140 <term::write(char)>
  1032d7:	83 c4 04             	add    esp,0x4
  1032da:	6a 20                	push   0x20
  1032dc:	e8 5f de ff ff       	call   101140 <term::write(char)>
  1032e1:	83 c4 04             	add    esp,0x4
                if (mb->mods_count > 0)
  1032e4:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  1032e7:	8b 50 14             	mov    edx,DWORD PTR [eax+0x14]
  1032ea:	85 d2                	test   edx,edx
  1032ec:	0f 84 74 01 00 00    	je     103466 <kernel_main+0x1886>
    constexpr array() : data_{T()} {}
  1032f2:	c7 84 24 2b 01 00 00 	mov    DWORD PTR [esp+0x12b],0x0
  1032f9:	00 00 00 00 
  1032fd:	c7 84 24 28 01 00 00 	mov    DWORD PTR [esp+0x128],0x0
  103304:	00 00 00 00 
  103308:	c7 84 24 24 01 00 00 	mov    DWORD PTR [esp+0x124],0x0
  10330f:	00 00 00 00 
  103313:	c7 84 24 20 01 00 00 	mov    DWORD PTR [esp+0x120],0x0
  10331a:	00 00 00 00 
  10331e:	c7 84 24 1c 01 00 00 	mov    DWORD PTR [esp+0x11c],0x0
  103325:	00 00 00 00 
  103329:	c7 84 24 18 01 00 00 	mov    DWORD PTR [esp+0x118],0x0
  103330:	00 00 00 00 
  103334:	c7 84 24 14 01 00 00 	mov    DWORD PTR [esp+0x114],0x0
  10333b:	00 00 00 00 
  10333f:	c7 84 24 10 01 00 00 	mov    DWORD PTR [esp+0x110],0x0
  103346:	00 00 00 00 
    int index_ = 0;
  10334a:	c7 84 24 30 01 00 00 	mov    DWORD PTR [esp+0x130],0x0
  103351:	00 00 00 00 
  103355:	31 ff                	xor    edi,edi
  103357:	c7 44 24 04 01 00 00 	mov    DWORD PTR [esp+0x4],0x1
  10335e:	00 
  10335f:	8d 84 24 10 01 00 00 	lea    eax,[esp+0x110]
  103366:	89 04 24             	mov    DWORD PTR [esp],eax
  103369:	90                   	nop
  10336a:	90                   	nop
  10336b:	90                   	nop
  10336c:	90                   	nop
  10336d:	90                   	nop
  10336e:	90                   	nop
  10336f:	90                   	nop
        x /= B;
  103370:	89 d0                	mov    eax,edx
  103372:	89 d6                	mov    esi,edx
  103374:	89 54 24 0c          	mov    DWORD PTR [esp+0xc],edx
  103378:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  10337d:	f7 e1                	mul    ecx
  10337f:	c1 ea 03             	shr    edx,0x3
  103382:	8d 04 12             	lea    eax,[edx+edx*1]
  103385:	8d 04 80             	lea    eax,[eax+eax*4]
  103388:	89 f1                	mov    ecx,esi
  10338a:	29 c1                	sub    ecx,eax
  10338c:	8b 44 24 04          	mov    eax,DWORD PTR [esp+0x4]
  103390:	8b 34 24             	mov    esi,DWORD PTR [esp]
            return '0' + (x % B);
  103393:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  103396:	88 8c 3c 10 01 00 00 	mov    BYTE PTR [esp+edi*1+0x110],cl
    for (; x > 0; a++) {
  10339d:	47                   	inc    edi
  10339e:	8d 48 01             	lea    ecx,[eax+0x1]
  1033a1:	89 4c 24 04          	mov    DWORD PTR [esp+0x4],ecx
  1033a5:	83 7c 24 0c 09       	cmp    DWORD PTR [esp+0xc],0x9
  1033aa:	8d 4e 01             	lea    ecx,[esi+0x1]
  1033ad:	89 0c 24             	mov    DWORD PTR [esp],ecx
  1033b0:	77 be                	ja     103370 <kernel_main+0x1790>
    r[a] = 0;
  1033b2:	c6 84 3c 10 01 00 00 	mov    BYTE PTR [esp+edi*1+0x110],0x0
  1033b9:	00 
    for (auto b = 0; b < a / 2; b++) {
  1033ba:	f7 c7 fe ff ff ff    	test   edi,0xfffffffe
  1033c0:	74 20                	je     1033e2 <kernel_main+0x1802>
  1033c2:	d1 e8                	shr    eax,1
  1033c4:	8d 8c 24 10 01 00 00 	lea    ecx,[esp+0x110]
  1033cb:	90                   	nop
  1033cc:	90                   	nop
  1033cd:	90                   	nop
  1033ce:	90                   	nop
  1033cf:	90                   	nop
        r[b] ^= r[a - b - 1];
  1033d0:	0f b6 11             	movzx  edx,BYTE PTR [ecx]
  1033d3:	32 16                	xor    dl,BYTE PTR [esi]
  1033d5:	88 11                	mov    BYTE PTR [ecx],dl
        r[a - b - 1] ^= r[b];
  1033d7:	32 16                	xor    dl,BYTE PTR [esi]
  1033d9:	88 16                	mov    BYTE PTR [esi],dl
        r[b] ^= r[a - b - 1];
  1033db:	30 11                	xor    BYTE PTR [ecx],dl
    for (auto b = 0; b < a / 2; b++) {
  1033dd:	41                   	inc    ecx
  1033de:	4e                   	dec    esi
  1033df:	48                   	dec    eax
  1033e0:	75 ee                	jne    1033d0 <kernel_main+0x17f0>
    return r;
  1033e2:	b9 09 00 00 00       	mov    ecx,0x9
  1033e7:	8d bc 24 88 00 00 00 	lea    edi,[esp+0x88]
  1033ee:	8d b4 24 10 01 00 00 	lea    esi,[esp+0x110]
  1033f5:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  1033f7:	6a 28                	push   0x28
  1033f9:	e8 42 dd ff ff       	call   101140 <term::write(char)>
  1033fe:	83 c4 04             	add    esp,0x4
  103401:	6a 6d                	push   0x6d
  103403:	e8 38 dd ff ff       	call   101140 <term::write(char)>
  103408:	83 c4 04             	add    esp,0x4
  10340b:	6a 61                	push   0x61
  10340d:	e8 2e dd ff ff       	call   101140 <term::write(char)>
  103412:	83 c4 04             	add    esp,0x4
  103415:	6a 78                	push   0x78
  103417:	e8 24 dd ff ff       	call   101140 <term::write(char)>
  10341c:	83 c4 04             	add    esp,0x4
  10341f:	6a 3a                	push   0x3a
  103421:	e8 1a dd ff ff       	call   101140 <term::write(char)>
  103426:	83 c4 04             	add    esp,0x4
  103429:	6a 20                	push   0x20
  10342b:	e8 10 dd ff ff       	call   101140 <term::write(char)>
  103430:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103433:	8a 84 24 88 00 00 00 	mov    al,BYTE PTR [esp+0x88]
  10343a:	84 c0                	test   al,al
  10343c:	0f 84 9c 00 00 00    	je     1034de <kernel_main+0x18fe>
  103442:	8d b4 24 89 00 00 00 	lea    esi,[esp+0x89]
  103449:	90                   	nop
  10344a:	90                   	nop
  10344b:	90                   	nop
  10344c:	90                   	nop
  10344d:	90                   	nop
  10344e:	90                   	nop
  10344f:	90                   	nop
        write(s[a]);
  103450:	0f be c0             	movsx  eax,al
  103453:	50                   	push   eax
  103454:	e8 e7 dc ff ff       	call   101140 <term::write(char)>
  103459:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10345c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10345f:	46                   	inc    esi
  103460:	84 c0                	test   al,al
  103462:	75 ec                	jne    103450 <kernel_main+0x1870>
  103464:	eb 78                	jmp    1034de <kernel_main+0x18fe>
        write(s[a]);
  103466:	6a 28                	push   0x28
  103468:	e8 d3 dc ff ff       	call   101140 <term::write(char)>
  10346d:	83 c4 04             	add    esp,0x4
  103470:	6a 6e                	push   0x6e
  103472:	e8 c9 dc ff ff       	call   101140 <term::write(char)>
  103477:	83 c4 04             	add    esp,0x4
  10347a:	6a 6f                	push   0x6f
  10347c:	e8 bf dc ff ff       	call   101140 <term::write(char)>
  103481:	83 c4 04             	add    esp,0x4
  103484:	6a 6e                	push   0x6e
  103486:	e8 b5 dc ff ff       	call   101140 <term::write(char)>
  10348b:	83 c4 04             	add    esp,0x4
  10348e:	6a 65                	push   0x65
  103490:	e8 ab dc ff ff       	call   101140 <term::write(char)>
  103495:	83 c4 04             	add    esp,0x4
  103498:	6a 20                	push   0x20
  10349a:	e8 a1 dc ff ff       	call   101140 <term::write(char)>
  10349f:	83 c4 04             	add    esp,0x4
  1034a2:	6a 6c                	push   0x6c
  1034a4:	e8 97 dc ff ff       	call   101140 <term::write(char)>
  1034a9:	83 c4 04             	add    esp,0x4
  1034ac:	6a 6f                	push   0x6f
  1034ae:	e8 8d dc ff ff       	call   101140 <term::write(char)>
  1034b3:	83 c4 04             	add    esp,0x4
  1034b6:	6a 61                	push   0x61
  1034b8:	e8 83 dc ff ff       	call   101140 <term::write(char)>
  1034bd:	83 c4 04             	add    esp,0x4
  1034c0:	6a 64                	push   0x64
  1034c2:	e8 79 dc ff ff       	call   101140 <term::write(char)>
  1034c7:	83 c4 04             	add    esp,0x4
  1034ca:	6a 65                	push   0x65
  1034cc:	e8 6f dc ff ff       	call   101140 <term::write(char)>
  1034d1:	83 c4 04             	add    esp,0x4
  1034d4:	6a 64                	push   0x64
  1034d6:	e8 65 dc ff ff       	call   101140 <term::write(char)>
  1034db:	83 c4 04             	add    esp,0x4
  1034de:	6a 29                	push   0x29
  1034e0:	e8 5b dc ff ff       	call   101140 <term::write(char)>
  1034e5:	83 c4 04             	add    esp,0x4
  1034e8:	e9 b7 00 00 00       	jmp    1035a4 <kernel_main+0x19c4>
  1034ed:	8b 04 24             	mov    eax,DWORD PTR [esp]
    r[a] = 0;
  1034f0:	c6 84 04 10 01 00 00 	mov    BYTE PTR [esp+eax*1+0x110],0x0
  1034f7:	00 
    for (auto b = 0; b < a / 2; b++) {
  1034f8:	a9 fe ff ff ff       	test   eax,0xfffffffe
  1034fd:	8d bc 24 88 00 00 00 	lea    edi,[esp+0x88]
  103504:	74 3e                	je     103544 <kernel_main+0x1964>
  103506:	d1 ee                	shr    esi,1
  103508:	8d 84 24 10 01 00 00 	lea    eax,[esp+0x110]
  10350f:	90                   	nop
        r[b] ^= r[a - b - 1];
  103510:	0f b6 10             	movzx  edx,BYTE PTR [eax]
  103513:	32 11                	xor    dl,BYTE PTR [ecx]
  103515:	88 10                	mov    BYTE PTR [eax],dl
        r[a - b - 1] ^= r[b];
  103517:	32 11                	xor    dl,BYTE PTR [ecx]
  103519:	88 11                	mov    BYTE PTR [ecx],dl
        r[b] ^= r[a - b - 1];
  10351b:	30 10                	xor    BYTE PTR [eax],dl
    for (auto b = 0; b < a / 2; b++) {
  10351d:	40                   	inc    eax
  10351e:	49                   	dec    ecx
  10351f:	4e                   	dec    esi
  103520:	75 ee                	jne    103510 <kernel_main+0x1930>
  103522:	eb 20                	jmp    103544 <kernel_main+0x1964>
        r[a++] = '0';
  103524:	c6 84 24 10 01 00 00 	mov    BYTE PTR [esp+0x110],0x30
  10352b:	30 
  10352c:	b8 01 00 00 00       	mov    eax,0x1
  103531:	eb 02                	jmp    103535 <kernel_main+0x1955>
  103533:	31 c0                	xor    eax,eax
    r[a] = 0;
  103535:	c6 84 04 10 01 00 00 	mov    BYTE PTR [esp+eax*1+0x110],0x0
  10353c:	00 
  10353d:	8d bc 24 88 00 00 00 	lea    edi,[esp+0x88]
    return r;
  103544:	b9 09 00 00 00       	mov    ecx,0x9
  103549:	8d b4 24 10 01 00 00 	lea    esi,[esp+0x110]
  103550:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
  103552:	6a 3e                	push   0x3e
  103554:	e8 e7 db ff ff       	call   101140 <term::write(char)>
  103559:	83 c4 04             	add    esp,0x4
  10355c:	6a 3e                	push   0x3e
  10355e:	e8 dd db ff ff       	call   101140 <term::write(char)>
  103563:	83 c4 04             	add    esp,0x4
  103566:	6a 3e                	push   0x3e
  103568:	e8 d3 db ff ff       	call   101140 <term::write(char)>
  10356d:	83 c4 04             	add    esp,0x4
  103570:	6a 20                	push   0x20
  103572:	e8 c9 db ff ff       	call   101140 <term::write(char)>
  103577:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10357a:	8a 84 24 88 00 00 00 	mov    al,BYTE PTR [esp+0x88]
  103581:	84 c0                	test   al,al
  103583:	74 1f                	je     1035a4 <kernel_main+0x19c4>
  103585:	8d b4 24 89 00 00 00 	lea    esi,[esp+0x89]
  10358c:	90                   	nop
  10358d:	90                   	nop
  10358e:	90                   	nop
  10358f:	90                   	nop
        write(s[a]);
  103590:	0f be c0             	movsx  eax,al
  103593:	50                   	push   eax
  103594:	e8 a7 db ff ff       	call   101140 <term::write(char)>
  103599:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  10359c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  10359f:	46                   	inc    esi
  1035a0:	84 c0                	test   al,al
  1035a2:	75 ec                	jne    103590 <kernel_main+0x19b0>
  1035a4:	6a 0a                	push   0xa
  1035a6:	e8 95 db ff ff       	call   101140 <term::write(char)>
  1035ab:	83 c4 04             	add    esp,0x4
  1035ae:	90                   	nop
  1035af:	90                   	nop
  1035b0:	31 c0                	xor    eax,eax
  1035b2:	90                   	nop
  1035b3:	90                   	nop
  1035b4:	90                   	nop
  1035b5:	90                   	nop
  1035b6:	90                   	nop
  1035b7:	90                   	nop
  1035b8:	90                   	nop
  1035b9:	90                   	nop
  1035ba:	90                   	nop
  1035bb:	90                   	nop
  1035bc:	90                   	nop
  1035bd:	90                   	nop
  1035be:	90                   	nop
  1035bf:	90                   	nop
  1035c0:	31 c9                	xor    ecx,ecx
  1035c2:	90                   	nop
  1035c3:	90                   	nop
  1035c4:	90                   	nop
  1035c5:	90                   	nop
  1035c6:	90                   	nop
  1035c7:	90                   	nop
  1035c8:	90                   	nop
  1035c9:	90                   	nop
  1035ca:	90                   	nop
  1035cb:	90                   	nop
  1035cc:	90                   	nop
  1035cd:	90                   	nop
  1035ce:	90                   	nop
  1035cf:	90                   	nop
            if (this->operator[](a) == 0)
  1035d0:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  1035d5:	74 0b                	je     1035e2 <kernel_main+0x1a02>
        for (int a = 0; a < N; a++) {
  1035d7:	41                   	inc    ecx
  1035d8:	83 f9 50             	cmp    ecx,0x50
  1035db:	75 f3                	jne    1035d0 <kernel_main+0x19f0>
  1035dd:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  1035e2:	39 c8                	cmp    eax,ecx
  1035e4:	73 1a                	jae    103600 <kernel_main+0x1a20>
            if (p[a] == 0 || p[a] != this->operator[](a))
  1035e6:	83 f8 04             	cmp    eax,0x4
  1035e9:	74 45                	je     103630 <kernel_main+0x1a50>
  1035eb:	8a 88 56 00 10 00    	mov    cl,BYTE PTR [eax+0x100056]
  1035f1:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  1035f5:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  1035f8:	74 c6                	je     1035c0 <kernel_main+0x19e0>
  1035fa:	eb 34                	jmp    103630 <kernel_main+0x1a50>
  1035fc:	90                   	nop
  1035fd:	90                   	nop
  1035fe:	90                   	nop
  1035ff:	90                   	nop
  103600:	b8 fc ff ff ff       	mov    eax,0xfffffffc
  103605:	90                   	nop
  103606:	90                   	nop
  103607:	90                   	nop
  103608:	90                   	nop
  103609:	90                   	nop
  10360a:	90                   	nop
  10360b:	90                   	nop
  10360c:	90                   	nop
  10360d:	90                   	nop
  10360e:	90                   	nop
  10360f:	90                   	nop
            if (this->operator[](a) == 0)
  103610:	80 7c 04 30 00       	cmp    BYTE PTR [esp+eax*1+0x30],0x0
  103615:	74 08                	je     10361f <kernel_main+0x1a3f>
        for (int a = 0; a < N; a++) {
  103617:	40                   	inc    eax
  103618:	83 f8 4c             	cmp    eax,0x4c
  10361b:	75 f3                	jne    103610 <kernel_main+0x1a30>
  10361d:	eb 11                	jmp    103630 <kernel_main+0x1a50>
        return p[length()] == 0;
  10361f:	85 c0                	test   eax,eax
        if (command == "game") {
  103621:	0f 84 db 02 00 00    	je     103902 <kernel_main+0x1d22>
  103627:	90                   	nop
  103628:	90                   	nop
  103629:	90                   	nop
  10362a:	90                   	nop
  10362b:	90                   	nop
  10362c:	90                   	nop
  10362d:	90                   	nop
  10362e:	90                   	nop
  10362f:	90                   	nop
  103630:	31 c0                	xor    eax,eax
  103632:	90                   	nop
  103633:	90                   	nop
  103634:	90                   	nop
  103635:	90                   	nop
  103636:	90                   	nop
  103637:	90                   	nop
  103638:	90                   	nop
  103639:	90                   	nop
  10363a:	90                   	nop
  10363b:	90                   	nop
  10363c:	90                   	nop
  10363d:	90                   	nop
  10363e:	90                   	nop
  10363f:	90                   	nop
  103640:	31 c9                	xor    ecx,ecx
  103642:	90                   	nop
  103643:	90                   	nop
  103644:	90                   	nop
  103645:	90                   	nop
  103646:	90                   	nop
  103647:	90                   	nop
  103648:	90                   	nop
  103649:	90                   	nop
  10364a:	90                   	nop
  10364b:	90                   	nop
  10364c:	90                   	nop
  10364d:	90                   	nop
  10364e:	90                   	nop
  10364f:	90                   	nop
            if (this->operator[](a) == 0)
  103650:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  103655:	74 0b                	je     103662 <kernel_main+0x1a82>
        for (int a = 0; a < N; a++) {
  103657:	41                   	inc    ecx
  103658:	83 f9 50             	cmp    ecx,0x50
  10365b:	75 f3                	jne    103650 <kernel_main+0x1a70>
  10365d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  103662:	39 c8                	cmp    eax,ecx
  103664:	73 2a                	jae    103690 <kernel_main+0x1ab0>
            if (p[a] == 0 || p[a] != this->operator[](a))
  103666:	83 f8 06             	cmp    eax,0x6
  103669:	0f 84 01 02 00 00    	je     103870 <kernel_main+0x1c90>
  10366f:	8a 88 42 00 10 00    	mov    cl,BYTE PTR [eax+0x100042]
  103675:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  103679:	8d 40 01             	lea    eax,[eax+0x1]
            if (p[a] == 0 || p[a] != this->operator[](a))
  10367c:	74 c2                	je     103640 <kernel_main+0x1a60>
  10367e:	e9 ed 01 00 00       	jmp    103870 <kernel_main+0x1c90>
  103683:	90                   	nop
  103684:	90                   	nop
  103685:	90                   	nop
  103686:	90                   	nop
  103687:	90                   	nop
  103688:	90                   	nop
  103689:	90                   	nop
  10368a:	90                   	nop
  10368b:	90                   	nop
  10368c:	90                   	nop
  10368d:	90                   	nop
  10368e:	90                   	nop
  10368f:	90                   	nop
  103690:	b8 fa ff ff ff       	mov    eax,0xfffffffa
  103695:	90                   	nop
  103696:	90                   	nop
  103697:	90                   	nop
  103698:	90                   	nop
  103699:	90                   	nop
  10369a:	90                   	nop
  10369b:	90                   	nop
  10369c:	90                   	nop
  10369d:	90                   	nop
  10369e:	90                   	nop
  10369f:	90                   	nop
            if (this->operator[](a) == 0)
  1036a0:	80 7c 04 32 00       	cmp    BYTE PTR [esp+eax*1+0x32],0x0
  1036a5:	74 0b                	je     1036b2 <kernel_main+0x1ad2>
        for (int a = 0; a < N; a++) {
  1036a7:	40                   	inc    eax
  1036a8:	83 f8 4a             	cmp    eax,0x4a
  1036ab:	75 f3                	jne    1036a0 <kernel_main+0x1ac0>
  1036ad:	e9 be 01 00 00       	jmp    103870 <kernel_main+0x1c90>
        return p[length()] == 0;
  1036b2:	85 c0                	test   eax,eax
        if (command == "matrix") {
  1036b4:	0f 85 b6 01 00 00    	jne    103870 <kernel_main+0x1c90>
  1036ba:	31 c0                	xor    eax,eax
  1036bc:	90                   	nop
  1036bd:	90                   	nop
  1036be:	90                   	nop
  1036bf:	90                   	nop
            if (this->operator[](a) == 0)
  1036c0:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  1036c7:	00 
  1036c8:	74 08                	je     1036d2 <kernel_main+0x1af2>
        for (int a = 0; a < N; a++) {
  1036ca:	40                   	inc    eax
  1036cb:	83 f8 50             	cmp    eax,0x50
  1036ce:	75 f0                	jne    1036c0 <kernel_main+0x1ae0>
  1036d0:	eb 04                	jmp    1036d6 <kernel_main+0x1af6>
        for (int a = 0; a < length(); a++) {
  1036d2:	85 c0                	test   eax,eax
  1036d4:	74 76                	je     10374c <kernel_main+0x1b6c>
  1036d6:	31 c0                	xor    eax,eax
  1036d8:	90                   	nop
  1036d9:	90                   	nop
  1036da:	90                   	nop
  1036db:	90                   	nop
  1036dc:	90                   	nop
  1036dd:	90                   	nop
  1036de:	90                   	nop
  1036df:	90                   	nop
            if (this->operator[](a) == 0)
  1036e0:	80 bc 04 b4 00 00 00 	cmp    BYTE PTR [esp+eax*1+0xb4],0x0
  1036e7:	00 
  1036e8:	74 0b                	je     1036f5 <kernel_main+0x1b15>
        for (int a = 0; a < N; a++) {
  1036ea:	40                   	inc    eax
  1036eb:	83 f8 50             	cmp    eax,0x50
  1036ee:	75 f0                	jne    1036e0 <kernel_main+0x1b00>
  1036f0:	b8 50 00 00 00       	mov    eax,0x50
        return dual_iterator<const char>(this->data_ + length());
  1036f5:	8d 8c 04 b4 00 00 00 	lea    ecx,[esp+eax*1+0xb4]
  1036fc:	8d 94 24 b4 00 00 00 	lea    edx,[esp+0xb4]
        return ptr_ != p.ptr_;
  103703:	39 ca                	cmp    edx,ecx
    for (auto c : p) {
  103705:	74 30                	je     103737 <kernel_main+0x1b57>
  103707:	89 d1                	mov    ecx,edx
  103709:	31 f6                	xor    esi,esi
  10370b:	90                   	nop
  10370c:	90                   	nop
  10370d:	90                   	nop
  10370e:	90                   	nop
  10370f:	90                   	nop
    constexpr auto operator*() const { return dual_element{index_, *ptr_}; }
  103710:	0f be 11             	movsx  edx,BYTE PTR [ecx]
        r *= B;
  103713:	8d 34 b6             	lea    esi,[esi+esi*4]
        r += static_cast<int>(c.value - '0');
  103716:	8d 74 72 d0          	lea    esi,[edx+esi*2-0x30]
        ptr_++;
  10371a:	41                   	inc    ecx
        return ptr_ != p.ptr_;
  10371b:	48                   	dec    eax
    for (auto c : p) {
  10371c:	75 f2                	jne    103710 <kernel_main+0x1b30>
        colour = static_cast<uint8>(fg | (bg << 4));
  10371e:	66 c7 05 0c 60 10 00 	mov    WORD PTR ds:0x10600c,0x102
  103725:	02 01 
            term::Term.wrap = true;
  103727:	c6 05 0e 60 10 00 01 	mov    BYTE PTR ds:0x10600e,0x1
            for (int a = 0; a < n; a++) {
  10372e:	85 f6                	test   esi,esi
  103730:	7f 2f                	jg     103761 <kernel_main+0x1b81>
  103732:	e9 1e 01 00 00       	jmp    103855 <kernel_main+0x1c75>
  103737:	66 c7 05 0c 60 10 00 	mov    WORD PTR ds:0x10600c,0x102
  10373e:	02 01 
            term::Term.wrap = true;
  103740:	c6 05 0e 60 10 00 01 	mov    BYTE PTR ds:0x10600e,0x1
  103747:	e9 09 01 00 00       	jmp    103855 <kernel_main+0x1c75>
  10374c:	66 c7 05 0c 60 10 00 	mov    WORD PTR ds:0x10600c,0x102
  103753:	02 01 
  103755:	c6 05 0e 60 10 00 01 	mov    BYTE PTR ds:0x10600e,0x1
  10375c:	be 01 00 00 00       	mov    esi,0x1
  103761:	31 c0                	xor    eax,eax
  103763:	89 74 24 04          	mov    DWORD PTR [esp+0x4],esi
  103767:	eb 17                	jmp    103780 <kernel_main+0x1ba0>
  103769:	90                   	nop
  10376a:	90                   	nop
  10376b:	90                   	nop
  10376c:	90                   	nop
  10376d:	90                   	nop
  10376e:	90                   	nop
  10376f:	90                   	nop
  103770:	8b 04 24             	mov    eax,DWORD PTR [esp]
            for (int a = 0; a < n; a++) {
  103773:	40                   	inc    eax
  103774:	8b 74 24 04          	mov    esi,DWORD PTR [esp+0x4]
  103778:	39 f0                	cmp    eax,esi
  10377a:	0f 84 d5 00 00 00    	je     103855 <kernel_main+0x1c75>
  103780:	89 04 24             	mov    DWORD PTR [esp],eax
                term::clear();
  103783:	e8 c8 d8 ff ff       	call   101050 <term::clear()>
  103788:	31 f6                	xor    esi,esi
  10378a:	eb 52                	jmp    1037de <kernel_main+0x1bfe>
  10378c:	90                   	nop
  10378d:	90                   	nop
  10378e:	90                   	nop
  10378f:	90                   	nop
        if (!flipped) {
  103790:	80 3d 0d 60 10 00 00 	cmp    BYTE PTR ds:0x10600d,0x0
  103797:	0f 84 80 00 00 00    	je     10381d <kernel_main+0x1c3d>
            increment_cursor(row, col, ROWS, COLS, ROWS - (row % ROWS));
  10379d:	8b 0d 08 60 10 00    	mov    ecx,DWORD PTR ds:0x106008
  1037a3:	89 c8                	mov    eax,ecx
  1037a5:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  1037aa:	f7 ea                	imul   edx
  1037ac:	89 d0                	mov    eax,edx
  1037ae:	c1 e8 1f             	shr    eax,0x1f
  1037b1:	c1 fa 03             	sar    edx,0x3
  1037b4:	01 c2                	add    edx,eax
  1037b6:	8d 04 92             	lea    eax,[edx+edx*4]
  1037b9:	8d 04 80             	lea    eax,[eax+eax*4]
  1037bc:	29 c8                	sub    eax,ecx
  1037be:	83 c0 19             	add    eax,0x19
  1037c1:	b9 08 60 10 00       	mov    ecx,0x106008
  1037c6:	ba 04 60 10 00       	mov    edx,0x106004
  1037cb:	50                   	push   eax
  1037cc:	6a 50                	push   0x50
  1037ce:	6a 19                	push   0x19
  1037d0:	e8 cb 01 00 00       	call   1039a0 <term::$_0::increment_cursor(int&, int&, int, int, int)>
  1037d5:	83 c4 0c             	add    esp,0xc
            value++;
  1037d8:	46                   	inc    esi
            return value != p.value;
  1037d9:	83 fe 50             	cmp    esi,0x50
                for (auto _ : range<0, term::COLS>) {
  1037dc:	74 92                	je     103770 <kernel_main+0x1b90>
  1037de:	31 ff                	xor    edi,edi
                        if (rnd.next(10) == 1) {
  1037e0:	6a 0a                	push   0xa
  1037e2:	53                   	push   ebx
  1037e3:	e8 18 09 00 00       	call   104100 <rand::random_gen::next(unsigned int)>
  1037e8:	83 c4 08             	add    esp,0x8
  1037eb:	83 f8 01             	cmp    eax,0x1
  1037ee:	74 a0                	je     103790 <kernel_main+0x1bb0>
                        term::write(char(' ' + (rnd.next(64))));
  1037f0:	6a 40                	push   0x40
  1037f2:	53                   	push   ebx
  1037f3:	e8 08 09 00 00       	call   104100 <rand::random_gen::next(unsigned int)>
  1037f8:	83 c4 08             	add    esp,0x8
  1037fb:	04 20                	add    al,0x20
  1037fd:	0f be c0             	movsx  eax,al
  103800:	50                   	push   eax
  103801:	e8 3a d9 ff ff       	call   101140 <term::write(char)>
  103806:	83 c4 04             	add    esp,0x4
  103809:	b8 00 00 1e 00       	mov    eax,0x1e0000
  10380e:	90                   	nop
  10380f:	90                   	nop
        asm volatile ("and %eax,%eax");
  103810:	21 c0                	and    eax,eax
    for (int a = 0; a < (1 << 16) * amount; a++) {
  103812:	48                   	dec    eax
  103813:	75 fb                	jne    103810 <kernel_main+0x1c30>
            value++;
  103815:	47                   	inc    edi
            return value != p.value;
  103816:	83 ff 19             	cmp    edi,0x19
                    for (auto _ : range<0, term::ROWS>) {
  103819:	75 c5                	jne    1037e0 <kernel_main+0x1c00>
  10381b:	eb bb                	jmp    1037d8 <kernel_main+0x1bf8>
            increment_cursor(col, row, COLS, ROWS, COLS - (col % COLS));
  10381d:	8b 0d 04 60 10 00    	mov    ecx,DWORD PTR ds:0x106004
  103823:	89 c8                	mov    eax,ecx
  103825:	ba 67 66 66 66       	mov    edx,0x66666667
  10382a:	f7 ea                	imul   edx
  10382c:	89 d0                	mov    eax,edx
  10382e:	c1 e8 1f             	shr    eax,0x1f
  103831:	c1 fa 05             	sar    edx,0x5
  103834:	01 c2                	add    edx,eax
  103836:	c1 e2 04             	shl    edx,0x4
  103839:	8d 04 92             	lea    eax,[edx+edx*4]
  10383c:	29 c8                	sub    eax,ecx
  10383e:	83 c0 50             	add    eax,0x50
  103841:	b9 04 60 10 00       	mov    ecx,0x106004
  103846:	ba 08 60 10 00       	mov    edx,0x106008
  10384b:	50                   	push   eax
  10384c:	6a 19                	push   0x19
  10384e:	6a 50                	push   0x50
  103850:	e9 7b ff ff ff       	jmp    1037d0 <kernel_main+0x1bf0>
            term::Term.wrap = false;
  103855:	c6 05 0e 60 10 00 00 	mov    BYTE PTR ds:0x10600e,0x0
        colour = static_cast<uint8>(fg | (bg << 4));
  10385c:	66 c7 05 0c 60 10 00 	mov    WORD PTR ds:0x10600c,0xf
  103863:	0f 00 
  103865:	90                   	nop
  103866:	90                   	nop
  103867:	90                   	nop
  103868:	90                   	nop
  103869:	90                   	nop
  10386a:	90                   	nop
  10386b:	90                   	nop
  10386c:	90                   	nop
  10386d:	90                   	nop
  10386e:	90                   	nop
  10386f:	90                   	nop
  103870:	31 c0                	xor    eax,eax
  103872:	90                   	nop
  103873:	90                   	nop
  103874:	90                   	nop
  103875:	90                   	nop
  103876:	90                   	nop
  103877:	90                   	nop
  103878:	90                   	nop
  103879:	90                   	nop
  10387a:	90                   	nop
  10387b:	90                   	nop
  10387c:	90                   	nop
  10387d:	90                   	nop
  10387e:	90                   	nop
  10387f:	90                   	nop
  103880:	31 c9                	xor    ecx,ecx
  103882:	90                   	nop
  103883:	90                   	nop
  103884:	90                   	nop
  103885:	90                   	nop
  103886:	90                   	nop
  103887:	90                   	nop
  103888:	90                   	nop
  103889:	90                   	nop
  10388a:	90                   	nop
  10388b:	90                   	nop
  10388c:	90                   	nop
  10388d:	90                   	nop
  10388e:	90                   	nop
  10388f:	90                   	nop
            if (this->operator[](a) == 0)
  103890:	80 7c 0c 2c 00       	cmp    BYTE PTR [esp+ecx*1+0x2c],0x0
  103895:	74 0b                	je     1038a2 <kernel_main+0x1cc2>
        for (int a = 0; a < N; a++) {
  103897:	41                   	inc    ecx
  103898:	83 f9 50             	cmp    ecx,0x50
  10389b:	75 f3                	jne    103890 <kernel_main+0x1cb0>
  10389d:	b9 50 00 00 00       	mov    ecx,0x50
        for (int a = 0; a < length(); a++) {
  1038a2:	39 c8                	cmp    eax,ecx
  1038a4:	73 2a                	jae    1038d0 <kernel_main+0x1cf0>
            if (p[a] == 0 || p[a] != this->operator[](a))
  1038a6:	83 f8 08             	cmp    eax,0x8
  1038a9:	0f 84 81 ee ff ff    	je     102730 <kernel_main+0xb50>
  1038af:	8a 88 91 00 10 00    	mov    cl,BYTE PTR [eax+0x100091]
  1038b5:	3a 4c 04 2c          	cmp    cl,BYTE PTR [esp+eax*1+0x2c]
        for (int a = 0; a < length(); a++) {
  1038b9:	8d 40 01             	lea    eax,[eax+0x1]
  1038bc:	74 c2                	je     103880 <kernel_main+0x1ca0>
  1038be:	e9 6d ee ff ff       	jmp    102730 <kernel_main+0xb50>
  1038c3:	90                   	nop
  1038c4:	90                   	nop
  1038c5:	90                   	nop
  1038c6:	90                   	nop
  1038c7:	90                   	nop
  1038c8:	90                   	nop
  1038c9:	90                   	nop
  1038ca:	90                   	nop
  1038cb:	90                   	nop
  1038cc:	90                   	nop
  1038cd:	90                   	nop
  1038ce:	90                   	nop
  1038cf:	90                   	nop
  1038d0:	b8 f8 ff ff ff       	mov    eax,0xfffffff8
  1038d5:	90                   	nop
  1038d6:	90                   	nop
  1038d7:	90                   	nop
  1038d8:	90                   	nop
  1038d9:	90                   	nop
  1038da:	90                   	nop
  1038db:	90                   	nop
  1038dc:	90                   	nop
  1038dd:	90                   	nop
  1038de:	90                   	nop
  1038df:	90                   	nop
            if (this->operator[](a) == 0)
  1038e0:	80 7c 04 34 00       	cmp    BYTE PTR [esp+eax*1+0x34],0x0
  1038e5:	0f 84 33 ee ff ff    	je     10271e <kernel_main+0xb3e>
        for (int a = 0; a < N; a++) {
  1038eb:	40                   	inc    eax
  1038ec:	83 f8 48             	cmp    eax,0x48
  1038ef:	75 ef                	jne    1038e0 <kernel_main+0x1d00>
  1038f1:	e9 3a ee ff ff       	jmp    102730 <kernel_main+0xb50>
    asm("hlt");
  1038f6:	f4                   	hlt    
  1038f7:	90                   	nop
  1038f8:	90                   	nop
  1038f9:	90                   	nop
  1038fa:	90                   	nop
  1038fb:	90                   	nop
  1038fc:	90                   	nop
  1038fd:	90                   	nop
  1038fe:	90                   	nop
  1038ff:	90                   	nop
    while (true)
  103900:	eb fe                	jmp    103900 <kernel_main+0x1d20>
  103902:	8d b4 24 10 01 00 00 	lea    esi,[esp+0x110]
            game_of_life g;
  103909:	56                   	push   esi
  10390a:	e8 b1 06 00 00       	call   103fc0 <game_of_life::game_of_life()>
  10390f:	83 c4 04             	add    esp,0x4
            }
    }

    void run(int gens = 10) {
        for (int a = 0; a < gens; a++) {
            step();
  103912:	56                   	push   esi
  103913:	e8 a8 09 00 00       	call   1042c0 <game_of_life::step()>
  103918:	83 c4 04             	add    esp,0x4
  10391b:	31 f6                	xor    esi,esi
  10391d:	bb 2d 00 00 00       	mov    ebx,0x2d
  103922:	90                   	nop
  103923:	90                   	nop
  103924:	90                   	nop
  103925:	90                   	nop
  103926:	90                   	nop
  103927:	90                   	nop
  103928:	90                   	nop
  103929:	90                   	nop
  10392a:	90                   	nop
  10392b:	90                   	nop
  10392c:	90                   	nop
  10392d:	90                   	nop
  10392e:	90                   	nop
  10392f:	90                   	nop
  103930:	bf 19 00 00 00       	mov    edi,0x19
  103935:	89 34 24             	mov    DWORD PTR [esp],esi
  103938:	90                   	nop
  103939:	90                   	nop
  10393a:	90                   	nop
  10393b:	90                   	nop
  10393c:	90                   	nop
  10393d:	90                   	nop
  10393e:	90                   	nop
  10393f:	90                   	nop
        return bit_member(*this, static_cast<int>(i));
  103940:	56                   	push   esi
  103941:	8d 84 24 14 01 00 00 	lea    eax,[esp+0x114]
  103948:	50                   	push   eax
  103949:	8d 84 24 90 00 00 00 	lea    eax,[esp+0x90]
  103950:	50                   	push   eax
  103951:	e8 2a 09 00 00       	call   104280 <mem::bit_sequence<2000>::bit_member::bit_member(mem::bit_sequence<2000>&, int)>
  103956:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  103959:	80 bc 24 90 00 00 00 	cmp    BYTE PTR [esp+0x90],0x0
  103960:	00 

    void draw() {
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                auto c = board(x, y);
                term::write(c ? 'X' : '-');
  103961:	b8 58 00 00 00       	mov    eax,0x58
  103966:	0f 44 c3             	cmove  eax,ebx
  103969:	50                   	push   eax
  10396a:	e8 d1 d7 ff ff       	call   101140 <term::write(char)>
  10396f:	83 c4 04             	add    esp,0x4
            for (int y = 0; y < height; y++) {
  103972:	83 c6 50             	add    esi,0x50
  103975:	4f                   	dec    edi
  103976:	75 c8                	jne    103940 <kernel_main+0x1d60>
  103978:	8b 34 24             	mov    esi,DWORD PTR [esp]
        for (int x = 0; x < width; x++) {
  10397b:	46                   	inc    esi
  10397c:	83 fe 50             	cmp    esi,0x50
  10397f:	75 af                	jne    103930 <kernel_main+0x1d50>
  103981:	90                   	nop
  103982:	90                   	nop
  103983:	90                   	nop
  103984:	90                   	nop
  103985:	90                   	nop
  103986:	90                   	nop
  103987:	90                   	nop
  103988:	90                   	nop
  103989:	90                   	nop
  10398a:	90                   	nop
  10398b:	90                   	nop
  10398c:	90                   	nop
  10398d:	90                   	nop
  10398e:	90                   	nop
  10398f:	90                   	nop
            while(true);
  103990:	eb fe                	jmp    103990 <kernel_main+0x1db0>
        term::fatal_error("FAIL (shutting down)\n");
  103992:	68 2c 00 10 00       	push   0x10002c
  103997:	e8 e4 05 00 00       	call   103f80 <void term::fatal_error<char const*>(char const*)>
  10399c:	90                   	nop
  10399d:	90                   	nop
  10399e:	90                   	nop
  10399f:	90                   	nop

001039a0 <term::$_0::increment_cursor(int&, int&, int, int, int)>:
                          int cross_limit, int times = 0) {
  1039a0:	55                   	push   ebp
  1039a1:	89 e5                	mov    ebp,esp
  1039a3:	53                   	push   ebx
  1039a4:	57                   	push   edi
  1039a5:	56                   	push   esi
  1039a6:	83 ec 08             	sub    esp,0x8
  1039a9:	89 55 f0             	mov    DWORD PTR [ebp-0x10],edx
  1039ac:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
        for (int a = 0; a < times; a++) {
  1039af:	85 c0                	test   eax,eax
  1039b1:	0f 8e 13 03 00 00    	jle    103cca <term::$_0::increment_cursor(int&, int&, int, int, int)+0x32a>
  1039b7:	89 cf                	mov    edi,ecx
  1039b9:	80 3d 0e 60 10 00 00 	cmp    BYTE PTR ds:0x10600e,0x0
  1039c0:	75 25                	jne    1039e7 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x47>
  1039c2:	8b 1d 0c 60 10 00    	mov    ebx,DWORD PTR ds:0x10600c
  1039c8:	c1 e3 08             	shl    ebx,0x8
  1039cb:	83 cb 20             	or     ebx,0x20
  1039ce:	8b 35 00 60 10 00    	mov    esi,DWORD PTR ds:0x106000
  1039d4:	31 c9                	xor    ecx,ecx
  1039d6:	89 7d ec             	mov    DWORD PTR [ebp-0x14],edi
  1039d9:	eb 61                	jmp    103a3c <term::$_0::increment_cursor(int&, int&, int, int, int)+0x9c>
  1039db:	90                   	nop
  1039dc:	90                   	nop
  1039dd:	90                   	nop
  1039de:	90                   	nop
  1039df:	90                   	nop
  1039e0:	48                   	dec    eax
  1039e1:	0f 84 e3 02 00 00    	je     103cca <term::$_0::increment_cursor(int&, int&, int, int, int)+0x32a>
            main++;
  1039e7:	8b 0f                	mov    ecx,DWORD PTR [edi]
  1039e9:	41                   	inc    ecx
  1039ea:	89 0f                	mov    DWORD PTR [edi],ecx
            if (main == main_limit) {
  1039ec:	3b 4d 08             	cmp    ecx,DWORD PTR [ebp+0x8]
  1039ef:	75 1f                	jne    103a10 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x70>
                main = 0;
  1039f1:	c7 07 00 00 00 00    	mov    DWORD PTR [edi],0x0
  1039f7:	8b 4d f0             	mov    ecx,DWORD PTR [ebp-0x10]
                cross++;
  1039fa:	8b 11                	mov    edx,DWORD PTR [ecx]
  1039fc:	42                   	inc    edx
  1039fd:	89 11                	mov    DWORD PTR [ecx],edx
            if (cross == cross_limit) {
  1039ff:	3b 55 0c             	cmp    edx,DWORD PTR [ebp+0xc]
  103a02:	75 dc                	jne    1039e0 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x40>
  103a04:	eb 14                	jmp    103a1a <term::$_0::increment_cursor(int&, int&, int, int, int)+0x7a>
  103a06:	90                   	nop
  103a07:	90                   	nop
  103a08:	90                   	nop
  103a09:	90                   	nop
  103a0a:	90                   	nop
  103a0b:	90                   	nop
  103a0c:	90                   	nop
  103a0d:	90                   	nop
  103a0e:	90                   	nop
  103a0f:	90                   	nop
  103a10:	8b 4d f0             	mov    ecx,DWORD PTR [ebp-0x10]
  103a13:	8b 11                	mov    edx,DWORD PTR [ecx]
  103a15:	3b 55 0c             	cmp    edx,DWORD PTR [ebp+0xc]
  103a18:	75 c6                	jne    1039e0 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x40>
  103a1a:	c7 07 00 00 00 00    	mov    DWORD PTR [edi],0x0
  103a20:	8b 4d f0             	mov    ecx,DWORD PTR [ebp-0x10]
                    cross = 0;
  103a23:	c7 01 00 00 00 00    	mov    DWORD PTR [ecx],0x0
  103a29:	eb b5                	jmp    1039e0 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x40>
  103a2b:	90                   	nop
  103a2c:	90                   	nop
  103a2d:	90                   	nop
  103a2e:	90                   	nop
  103a2f:	90                   	nop
        for (int a = 0; a < times; a++) {
  103a30:	41                   	inc    ecx
  103a31:	39 c1                	cmp    ecx,eax
  103a33:	8b 7d ec             	mov    edi,DWORD PTR [ebp-0x14]
  103a36:	0f 84 8e 02 00 00    	je     103cca <term::$_0::increment_cursor(int&, int&, int, int, int)+0x32a>
  103a3c:	89 fa                	mov    edx,edi
            main++;
  103a3e:	8b 3f                	mov    edi,DWORD PTR [edi]
  103a40:	47                   	inc    edi
  103a41:	89 3a                	mov    DWORD PTR [edx],edi
            if (main == main_limit) {
  103a43:	3b 7d 08             	cmp    edi,DWORD PTR [ebp+0x8]
  103a46:	75 18                	jne    103a60 <term::$_0::increment_cursor(int&, int&, int, int, int)+0xc0>
                main = 0;
  103a48:	c7 02 00 00 00 00    	mov    DWORD PTR [edx],0x0
  103a4e:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
                cross++;
  103a51:	8b 3a                	mov    edi,DWORD PTR [edx]
  103a53:	47                   	inc    edi
  103a54:	89 3a                	mov    DWORD PTR [edx],edi
            if (cross == cross_limit) {
  103a56:	3b 7d 0c             	cmp    edi,DWORD PTR [ebp+0xc]
  103a59:	75 d5                	jne    103a30 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x90>
  103a5b:	eb 0d                	jmp    103a6a <term::$_0::increment_cursor(int&, int&, int, int, int)+0xca>
  103a5d:	90                   	nop
  103a5e:	90                   	nop
  103a5f:	90                   	nop
  103a60:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
  103a63:	8b 3a                	mov    edi,DWORD PTR [edx]
  103a65:	3b 7d 0c             	cmp    edi,DWORD PTR [ebp+0xc]
  103a68:	75 c6                	jne    103a30 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x90>
  103a6a:	8b 55 ec             	mov    edx,DWORD PTR [ebp-0x14]
  103a6d:	c7 02 00 00 00 00    	mov    DWORD PTR [edx],0x0
  103a73:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
                    cross--;
  103a76:	ff 0a                	dec    DWORD PTR [edx]
  103a78:	bf 00 f1 ff ff       	mov    edi,0xfffff100
  103a7d:	90                   	nop
  103a7e:	90                   	nop
  103a7f:	90                   	nop
                        VGA_BUF[a] = VGA_BUF[a + COLS];
  103a80:	0f b7 94 3e a0 0f 00 	movzx  edx,WORD PTR [esi+edi*1+0xfa0]
  103a87:	00 
  103a88:	66 89 94 3e 00 0f 00 	mov    WORD PTR [esi+edi*1+0xf00],dx
  103a8f:	00 
            return value != p.value;
  103a90:	83 c7 02             	add    edi,0x2
                    for (auto a : range<0, (ROWS - 1) * COLS>) {
  103a93:	75 eb                	jne    103a80 <term::$_0::increment_cursor(int&, int&, int, int, int)+0xe0>
                        VGA_BUF[a] = static_cast<uint16>((colour << 8) | ' ');
  103a95:	66 89 9e 00 0f 00 00 	mov    WORD PTR [esi+0xf00],bx
  103a9c:	66 89 9e 02 0f 00 00 	mov    WORD PTR [esi+0xf02],bx
  103aa3:	66 89 9e 04 0f 00 00 	mov    WORD PTR [esi+0xf04],bx
  103aaa:	66 89 9e 06 0f 00 00 	mov    WORD PTR [esi+0xf06],bx
  103ab1:	66 89 9e 08 0f 00 00 	mov    WORD PTR [esi+0xf08],bx
  103ab8:	66 89 9e 0a 0f 00 00 	mov    WORD PTR [esi+0xf0a],bx
  103abf:	66 89 9e 0c 0f 00 00 	mov    WORD PTR [esi+0xf0c],bx
  103ac6:	66 89 9e 0e 0f 00 00 	mov    WORD PTR [esi+0xf0e],bx
  103acd:	66 89 9e 10 0f 00 00 	mov    WORD PTR [esi+0xf10],bx
  103ad4:	66 89 9e 12 0f 00 00 	mov    WORD PTR [esi+0xf12],bx
  103adb:	66 89 9e 14 0f 00 00 	mov    WORD PTR [esi+0xf14],bx
  103ae2:	66 89 9e 16 0f 00 00 	mov    WORD PTR [esi+0xf16],bx
  103ae9:	66 89 9e 18 0f 00 00 	mov    WORD PTR [esi+0xf18],bx
  103af0:	66 89 9e 1a 0f 00 00 	mov    WORD PTR [esi+0xf1a],bx
  103af7:	66 89 9e 1c 0f 00 00 	mov    WORD PTR [esi+0xf1c],bx
  103afe:	66 89 9e 1e 0f 00 00 	mov    WORD PTR [esi+0xf1e],bx
  103b05:	66 89 9e 20 0f 00 00 	mov    WORD PTR [esi+0xf20],bx
  103b0c:	66 89 9e 22 0f 00 00 	mov    WORD PTR [esi+0xf22],bx
  103b13:	66 89 9e 24 0f 00 00 	mov    WORD PTR [esi+0xf24],bx
  103b1a:	66 89 9e 26 0f 00 00 	mov    WORD PTR [esi+0xf26],bx
  103b21:	66 89 9e 28 0f 00 00 	mov    WORD PTR [esi+0xf28],bx
  103b28:	66 89 9e 2a 0f 00 00 	mov    WORD PTR [esi+0xf2a],bx
  103b2f:	66 89 9e 2c 0f 00 00 	mov    WORD PTR [esi+0xf2c],bx
  103b36:	66 89 9e 2e 0f 00 00 	mov    WORD PTR [esi+0xf2e],bx
  103b3d:	66 89 9e 30 0f 00 00 	mov    WORD PTR [esi+0xf30],bx
  103b44:	66 89 9e 32 0f 00 00 	mov    WORD PTR [esi+0xf32],bx
  103b4b:	66 89 9e 34 0f 00 00 	mov    WORD PTR [esi+0xf34],bx
  103b52:	66 89 9e 36 0f 00 00 	mov    WORD PTR [esi+0xf36],bx
  103b59:	66 89 9e 38 0f 00 00 	mov    WORD PTR [esi+0xf38],bx
  103b60:	66 89 9e 3a 0f 00 00 	mov    WORD PTR [esi+0xf3a],bx
  103b67:	66 89 9e 3c 0f 00 00 	mov    WORD PTR [esi+0xf3c],bx
  103b6e:	66 89 9e 3e 0f 00 00 	mov    WORD PTR [esi+0xf3e],bx
  103b75:	66 89 9e 40 0f 00 00 	mov    WORD PTR [esi+0xf40],bx
  103b7c:	66 89 9e 42 0f 00 00 	mov    WORD PTR [esi+0xf42],bx
  103b83:	66 89 9e 44 0f 00 00 	mov    WORD PTR [esi+0xf44],bx
  103b8a:	66 89 9e 46 0f 00 00 	mov    WORD PTR [esi+0xf46],bx
  103b91:	66 89 9e 48 0f 00 00 	mov    WORD PTR [esi+0xf48],bx
  103b98:	66 89 9e 4a 0f 00 00 	mov    WORD PTR [esi+0xf4a],bx
  103b9f:	66 89 9e 4c 0f 00 00 	mov    WORD PTR [esi+0xf4c],bx
  103ba6:	66 89 9e 4e 0f 00 00 	mov    WORD PTR [esi+0xf4e],bx
  103bad:	66 89 9e 50 0f 00 00 	mov    WORD PTR [esi+0xf50],bx
  103bb4:	66 89 9e 52 0f 00 00 	mov    WORD PTR [esi+0xf52],bx
  103bbb:	66 89 9e 54 0f 00 00 	mov    WORD PTR [esi+0xf54],bx
  103bc2:	66 89 9e 56 0f 00 00 	mov    WORD PTR [esi+0xf56],bx
  103bc9:	66 89 9e 58 0f 00 00 	mov    WORD PTR [esi+0xf58],bx
  103bd0:	66 89 9e 5a 0f 00 00 	mov    WORD PTR [esi+0xf5a],bx
  103bd7:	66 89 9e 5c 0f 00 00 	mov    WORD PTR [esi+0xf5c],bx
  103bde:	66 89 9e 5e 0f 00 00 	mov    WORD PTR [esi+0xf5e],bx
  103be5:	66 89 9e 60 0f 00 00 	mov    WORD PTR [esi+0xf60],bx
  103bec:	66 89 9e 62 0f 00 00 	mov    WORD PTR [esi+0xf62],bx
  103bf3:	66 89 9e 64 0f 00 00 	mov    WORD PTR [esi+0xf64],bx
  103bfa:	66 89 9e 66 0f 00 00 	mov    WORD PTR [esi+0xf66],bx
  103c01:	66 89 9e 68 0f 00 00 	mov    WORD PTR [esi+0xf68],bx
  103c08:	66 89 9e 6a 0f 00 00 	mov    WORD PTR [esi+0xf6a],bx
  103c0f:	66 89 9e 6c 0f 00 00 	mov    WORD PTR [esi+0xf6c],bx
  103c16:	66 89 9e 6e 0f 00 00 	mov    WORD PTR [esi+0xf6e],bx
  103c1d:	66 89 9e 70 0f 00 00 	mov    WORD PTR [esi+0xf70],bx
  103c24:	66 89 9e 72 0f 00 00 	mov    WORD PTR [esi+0xf72],bx
  103c2b:	66 89 9e 74 0f 00 00 	mov    WORD PTR [esi+0xf74],bx
  103c32:	66 89 9e 76 0f 00 00 	mov    WORD PTR [esi+0xf76],bx
  103c39:	66 89 9e 78 0f 00 00 	mov    WORD PTR [esi+0xf78],bx
  103c40:	66 89 9e 7a 0f 00 00 	mov    WORD PTR [esi+0xf7a],bx
  103c47:	66 89 9e 7c 0f 00 00 	mov    WORD PTR [esi+0xf7c],bx
  103c4e:	66 89 9e 7e 0f 00 00 	mov    WORD PTR [esi+0xf7e],bx
  103c55:	66 89 9e 80 0f 00 00 	mov    WORD PTR [esi+0xf80],bx
  103c5c:	66 89 9e 82 0f 00 00 	mov    WORD PTR [esi+0xf82],bx
  103c63:	66 89 9e 84 0f 00 00 	mov    WORD PTR [esi+0xf84],bx
  103c6a:	66 89 9e 86 0f 00 00 	mov    WORD PTR [esi+0xf86],bx
  103c71:	66 89 9e 88 0f 00 00 	mov    WORD PTR [esi+0xf88],bx
  103c78:	66 89 9e 8a 0f 00 00 	mov    WORD PTR [esi+0xf8a],bx
  103c7f:	66 89 9e 8c 0f 00 00 	mov    WORD PTR [esi+0xf8c],bx
  103c86:	66 89 9e 8e 0f 00 00 	mov    WORD PTR [esi+0xf8e],bx
  103c8d:	66 89 9e 90 0f 00 00 	mov    WORD PTR [esi+0xf90],bx
  103c94:	66 89 9e 92 0f 00 00 	mov    WORD PTR [esi+0xf92],bx
  103c9b:	66 89 9e 94 0f 00 00 	mov    WORD PTR [esi+0xf94],bx
  103ca2:	66 89 9e 96 0f 00 00 	mov    WORD PTR [esi+0xf96],bx
  103ca9:	66 89 9e 98 0f 00 00 	mov    WORD PTR [esi+0xf98],bx
  103cb0:	66 89 9e 9a 0f 00 00 	mov    WORD PTR [esi+0xf9a],bx
  103cb7:	66 89 9e 9c 0f 00 00 	mov    WORD PTR [esi+0xf9c],bx
  103cbe:	66 89 9e 9e 0f 00 00 	mov    WORD PTR [esi+0xf9e],bx
  103cc5:	e9 66 fd ff ff       	jmp    103a30 <term::$_0::increment_cursor(int&, int&, int, int, int)+0x90>
    }
  103cca:	83 c4 08             	add    esp,0x8
  103ccd:	5e                   	pop    esi
  103cce:	5f                   	pop    edi
  103ccf:	5b                   	pop    ebx
  103cd0:	5d                   	pop    ebp
  103cd1:	c3                   	ret    
  103cd2:	cc                   	int3   
  103cd3:	cc                   	int3   
  103cd4:	cc                   	int3   
  103cd5:	cc                   	int3   
  103cd6:	cc                   	int3   
  103cd7:	cc                   	int3   
  103cd8:	cc                   	int3   
  103cd9:	cc                   	int3   
  103cda:	cc                   	int3   
  103cdb:	cc                   	int3   
  103cdc:	cc                   	int3   
  103cdd:	cc                   	int3   
  103cde:	cc                   	int3   
  103cdf:	cc                   	int3   

00103ce0 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)>:
    for (auto &a : {p...}) {
        write(a);
    }
}

template <class... S>[[noreturn]] void fatal_error(S... msg) {
  103ce0:	55                   	push   ebp
  103ce1:	89 e5                	mov    ebp,esp
  103ce3:	57                   	push   edi
  103ce4:	56                   	push   esi
  103ce5:	8b 75 0c             	mov    esi,DWORD PTR [ebp+0xc]
  103ce8:	8b 7d 08             	mov    edi,DWORD PTR [ebp+0x8]
    for (int a = 0; s[a] != 0; a++) {
  103ceb:	8a 07                	mov    al,BYTE PTR [edi]
  103ced:	84 c0                	test   al,al
  103cef:	74 23                	je     103d14 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x34>
  103cf1:	47                   	inc    edi
  103cf2:	90                   	nop
  103cf3:	90                   	nop
  103cf4:	90                   	nop
  103cf5:	90                   	nop
  103cf6:	90                   	nop
  103cf7:	90                   	nop
  103cf8:	90                   	nop
  103cf9:	90                   	nop
  103cfa:	90                   	nop
  103cfb:	90                   	nop
  103cfc:	90                   	nop
  103cfd:	90                   	nop
  103cfe:	90                   	nop
  103cff:	90                   	nop
        write(s[a]);
  103d00:	0f be c0             	movsx  eax,al
  103d03:	50                   	push   eax
  103d04:	e8 37 d4 ff ff       	call   101140 <term::write(char)>
  103d09:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103d0c:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  103d0f:	47                   	inc    edi
  103d10:	84 c0                	test   al,al
  103d12:	75 ec                	jne    103d00 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x20>
  103d14:	8b 7d 10             	mov    edi,DWORD PTR [ebp+0x10]
  103d17:	8a 06                	mov    al,BYTE PTR [esi]
  103d19:	84 c0                	test   al,al
  103d1b:	74 17                	je     103d34 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x54>
  103d1d:	46                   	inc    esi
  103d1e:	90                   	nop
  103d1f:	90                   	nop
        write(s[a]);
  103d20:	0f be c0             	movsx  eax,al
  103d23:	50                   	push   eax
  103d24:	e8 17 d4 ff ff       	call   101140 <term::write(char)>
  103d29:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103d2c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  103d2f:	46                   	inc    esi
  103d30:	84 c0                	test   al,al
  103d32:	75 ec                	jne    103d20 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x40>
  103d34:	8a 07                	mov    al,BYTE PTR [edi]
  103d36:	84 c0                	test   al,al
  103d38:	74 1a                	je     103d54 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x74>
  103d3a:	47                   	inc    edi
  103d3b:	90                   	nop
  103d3c:	90                   	nop
  103d3d:	90                   	nop
  103d3e:	90                   	nop
  103d3f:	90                   	nop
        write(s[a]);
  103d40:	0f be c0             	movsx  eax,al
  103d43:	50                   	push   eax
  103d44:	e8 f7 d3 ff ff       	call   101140 <term::write(char)>
  103d49:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103d4c:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  103d4f:	47                   	inc    edi
  103d50:	84 c0                	test   al,al
  103d52:	75 ec                	jne    103d40 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x60>
    asm("hlt");
  103d54:	f4                   	hlt    
  103d55:	90                   	nop
  103d56:	90                   	nop
  103d57:	90                   	nop
  103d58:	90                   	nop
  103d59:	90                   	nop
  103d5a:	90                   	nop
  103d5b:	90                   	nop
  103d5c:	90                   	nop
  103d5d:	90                   	nop
  103d5e:	90                   	nop
  103d5f:	90                   	nop
    while (true)
  103d60:	eb fe                	jmp    103d60 <void term::fatal_error<char const*, char const*, char const*>(char const*, char const*, char const*)+0x80>
  103d62:	cc                   	int3   
  103d63:	cc                   	int3   
  103d64:	cc                   	int3   
  103d65:	cc                   	int3   
  103d66:	cc                   	int3   
  103d67:	cc                   	int3   
  103d68:	cc                   	int3   
  103d69:	cc                   	int3   
  103d6a:	cc                   	int3   
  103d6b:	cc                   	int3   
  103d6c:	cc                   	int3   
  103d6d:	cc                   	int3   
  103d6e:	cc                   	int3   
  103d6f:	cc                   	int3   

00103d70 <auto int_to_string<10, unsigned int>(unsigned int)>:
template <int B = 10, class I> constexpr auto int_to_string(I x) {
  103d70:	55                   	push   ebp
  103d71:	89 e5                	mov    ebp,esp
  103d73:	53                   	push   ebx
  103d74:	57                   	push   edi
  103d75:	56                   	push   esi
  103d76:	83 e4 f8             	and    esp,0xfffffff8
  103d79:	83 ec 28             	sub    esp,0x28
  103d7c:	8b 5d 0c             	mov    ebx,DWORD PTR [ebp+0xc]
    constexpr array() : data_{T()} {}
  103d7f:	c7 44 24 1b 00 00 00 	mov    DWORD PTR [esp+0x1b],0x0
  103d86:	00 
  103d87:	c7 44 24 18 00 00 00 	mov    DWORD PTR [esp+0x18],0x0
  103d8e:	00 
  103d8f:	c7 44 24 14 00 00 00 	mov    DWORD PTR [esp+0x14],0x0
  103d96:	00 
  103d97:	c7 44 24 10 00 00 00 	mov    DWORD PTR [esp+0x10],0x0
  103d9e:	00 
  103d9f:	c7 44 24 0c 00 00 00 	mov    DWORD PTR [esp+0xc],0x0
  103da6:	00 
  103da7:	c7 44 24 08 00 00 00 	mov    DWORD PTR [esp+0x8],0x0
  103dae:	00 
  103daf:	c7 44 24 04 00 00 00 	mov    DWORD PTR [esp+0x4],0x0
  103db6:	00 
  103db7:	c7 04 24 00 00 00 00 	mov    DWORD PTR [esp],0x0
    int index_ = 0;
  103dbe:	c7 44 24 20 00 00 00 	mov    DWORD PTR [esp+0x20],0x0
  103dc5:	00 
    if (x == 0)
  103dc6:	85 db                	test   ebx,ebx
  103dc8:	74 6a                	je     103e34 <auto int_to_string<10, unsigned int>(unsigned int)+0xc4>
  103dca:	31 f6                	xor    esi,esi
  103dcc:	bf cd cc cc cc       	mov    edi,0xcccccccd
  103dd1:	90                   	nop
  103dd2:	90                   	nop
  103dd3:	90                   	nop
  103dd4:	90                   	nop
  103dd5:	90                   	nop
  103dd6:	90                   	nop
  103dd7:	90                   	nop
  103dd8:	90                   	nop
  103dd9:	90                   	nop
  103dda:	90                   	nop
  103ddb:	90                   	nop
  103ddc:	90                   	nop
  103ddd:	90                   	nop
  103dde:	90                   	nop
  103ddf:	90                   	nop
        x /= B;
  103de0:	89 d8                	mov    eax,ebx
  103de2:	f7 e7                	mul    edi
  103de4:	c1 ea 03             	shr    edx,0x3
  103de7:	8d 04 12             	lea    eax,[edx+edx*1]
  103dea:	8d 04 80             	lea    eax,[eax+eax*4]
  103ded:	89 d9                	mov    ecx,ebx
  103def:	29 c1                	sub    ecx,eax
            return '0' + (x % B);
  103df1:	80 c9 30             	or     cl,0x30
        r[a] = i2c(x);
  103df4:	88 0c 34             	mov    BYTE PTR [esp+esi*1],cl
    for (; x > 0; a++) {
  103df7:	46                   	inc    esi
  103df8:	83 fb 09             	cmp    ebx,0x9
  103dfb:	89 d3                	mov    ebx,edx
  103dfd:	77 e1                	ja     103de0 <auto int_to_string<10, unsigned int>(unsigned int)+0x70>
    r[a] = 0;
  103dff:	c6 04 34 00          	mov    BYTE PTR [esp+esi*1],0x0
    for (auto b = 0; b < a / 2; b++) {
  103e03:	f7 c6 fe ff ff ff    	test   esi,0xfffffffe
  103e09:	74 2f                	je     103e3a <auto int_to_string<10, unsigned int>(unsigned int)+0xca>
  103e0b:	8d 44 34 ff          	lea    eax,[esp+esi*1-0x1]
  103e0f:	d1 ee                	shr    esi,1
  103e11:	89 e1                	mov    ecx,esp
  103e13:	90                   	nop
  103e14:	90                   	nop
  103e15:	90                   	nop
  103e16:	90                   	nop
  103e17:	90                   	nop
  103e18:	90                   	nop
  103e19:	90                   	nop
  103e1a:	90                   	nop
  103e1b:	90                   	nop
  103e1c:	90                   	nop
  103e1d:	90                   	nop
  103e1e:	90                   	nop
  103e1f:	90                   	nop
        r[b] ^= r[a - b - 1];
  103e20:	0f b6 11             	movzx  edx,BYTE PTR [ecx]
  103e23:	32 10                	xor    dl,BYTE PTR [eax]
  103e25:	88 11                	mov    BYTE PTR [ecx],dl
        r[a - b - 1] ^= r[b];
  103e27:	32 10                	xor    dl,BYTE PTR [eax]
  103e29:	88 10                	mov    BYTE PTR [eax],dl
        r[b] ^= r[a - b - 1];
  103e2b:	30 11                	xor    BYTE PTR [ecx],dl
    for (auto b = 0; b < a / 2; b++) {
  103e2d:	48                   	dec    eax
  103e2e:	41                   	inc    ecx
  103e2f:	4e                   	dec    esi
  103e30:	75 ee                	jne    103e20 <auto int_to_string<10, unsigned int>(unsigned int)+0xb0>
  103e32:	eb 06                	jmp    103e3a <auto int_to_string<10, unsigned int>(unsigned int)+0xca>
        r[a++] = '0';
  103e34:	66 c7 04 24 30 00    	mov    WORD PTR [esp],0x30
  103e3a:	89 e6                	mov    esi,esp
    return r;
  103e3c:	b9 09 00 00 00       	mov    ecx,0x9
  103e41:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  103e44:	89 c7                	mov    edi,eax
  103e46:	f3 a5                	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
}
  103e48:	8d 65 f4             	lea    esp,[ebp-0xc]
  103e4b:	5e                   	pop    esi
  103e4c:	5f                   	pop    edi
  103e4d:	5b                   	pop    ebx
  103e4e:	5d                   	pop    ebp
  103e4f:	c2 04 00             	ret    0x4
  103e52:	cc                   	int3   
  103e53:	cc                   	int3   
  103e54:	cc                   	int3   
  103e55:	cc                   	int3   
  103e56:	cc                   	int3   
  103e57:	cc                   	int3   
  103e58:	cc                   	int3   
  103e59:	cc                   	int3   
  103e5a:	cc                   	int3   
  103e5b:	cc                   	int3   
  103e5c:	cc                   	int3   
  103e5d:	cc                   	int3   
  103e5e:	cc                   	int3   
  103e5f:	cc                   	int3   

00103e60 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)>:
template <class... S> void write(S... p) {
  103e60:	55                   	push   ebp
  103e61:	89 e5                	mov    ebp,esp
  103e63:	53                   	push   ebx
  103e64:	57                   	push   edi
  103e65:	56                   	push   esi
  103e66:	83 ec 1c             	sub    esp,0x1c
  103e69:	8b 45 18             	mov    eax,DWORD PTR [ebp+0x18]
  103e6c:	8b 4d 14             	mov    ecx,DWORD PTR [ebp+0x14]
  103e6f:	8b 5d 10             	mov    ebx,DWORD PTR [ebp+0x10]
  103e72:	8b 75 0c             	mov    esi,DWORD PTR [ebp+0xc]
  103e75:	8b 7d 08             	mov    edi,DWORD PTR [ebp+0x8]
    for (auto &a : {p...}) {
  103e78:	89 7d d8             	mov    DWORD PTR [ebp-0x28],edi
  103e7b:	89 75 dc             	mov    DWORD PTR [ebp-0x24],esi
  103e7e:	89 5d e0             	mov    DWORD PTR [ebp-0x20],ebx
  103e81:	89 4d e4             	mov    DWORD PTR [ebp-0x1c],ecx
  103e84:	89 45 e8             	mov    DWORD PTR [ebp-0x18],eax
  103e87:	8b 45 1c             	mov    eax,DWORD PTR [ebp+0x1c]
  103e8a:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
  103e8d:	8b 45 20             	mov    eax,DWORD PTR [ebp+0x20]
  103e90:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
    for (int a = 0; s[a] != 0; a++) {
  103e93:	8a 07                	mov    al,BYTE PTR [edi]
  103e95:	84 c0                	test   al,al
  103e97:	74 1b                	je     103eb4 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x54>
  103e99:	47                   	inc    edi
  103e9a:	90                   	nop
  103e9b:	90                   	nop
  103e9c:	90                   	nop
  103e9d:	90                   	nop
  103e9e:	90                   	nop
  103e9f:	90                   	nop
        write(s[a]);
  103ea0:	0f be c0             	movsx  eax,al
  103ea3:	50                   	push   eax
  103ea4:	e8 97 d2 ff ff       	call   101140 <term::write(char)>
  103ea9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103eac:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  103eaf:	47                   	inc    edi
  103eb0:	84 c0                	test   al,al
  103eb2:	75 ec                	jne    103ea0 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x40>
  103eb4:	8a 06                	mov    al,BYTE PTR [esi]
  103eb6:	84 c0                	test   al,al
  103eb8:	74 1a                	je     103ed4 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x74>
  103eba:	46                   	inc    esi
  103ebb:	90                   	nop
  103ebc:	90                   	nop
  103ebd:	90                   	nop
  103ebe:	90                   	nop
  103ebf:	90                   	nop
        write(s[a]);
  103ec0:	0f be c0             	movsx  eax,al
  103ec3:	50                   	push   eax
  103ec4:	e8 77 d2 ff ff       	call   101140 <term::write(char)>
  103ec9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103ecc:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  103ecf:	46                   	inc    esi
  103ed0:	84 c0                	test   al,al
  103ed2:	75 ec                	jne    103ec0 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x60>
  103ed4:	8a 03                	mov    al,BYTE PTR [ebx]
  103ed6:	84 c0                	test   al,al
  103ed8:	8b 7d 14             	mov    edi,DWORD PTR [ebp+0x14]
  103edb:	74 17                	je     103ef4 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x94>
  103edd:	43                   	inc    ebx
  103ede:	90                   	nop
  103edf:	90                   	nop
        write(s[a]);
  103ee0:	0f be c0             	movsx  eax,al
  103ee3:	50                   	push   eax
  103ee4:	e8 57 d2 ff ff       	call   101140 <term::write(char)>
  103ee9:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103eec:	0f b6 03             	movzx  eax,BYTE PTR [ebx]
  103eef:	43                   	inc    ebx
  103ef0:	84 c0                	test   al,al
  103ef2:	75 ec                	jne    103ee0 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x80>
  103ef4:	8a 07                	mov    al,BYTE PTR [edi]
  103ef6:	84 c0                	test   al,al
  103ef8:	8b 75 18             	mov    esi,DWORD PTR [ebp+0x18]
  103efb:	74 17                	je     103f14 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xb4>
  103efd:	47                   	inc    edi
  103efe:	90                   	nop
  103eff:	90                   	nop
        write(s[a]);
  103f00:	0f be c0             	movsx  eax,al
  103f03:	50                   	push   eax
  103f04:	e8 37 d2 ff ff       	call   101140 <term::write(char)>
  103f09:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103f0c:	0f b6 07             	movzx  eax,BYTE PTR [edi]
  103f0f:	47                   	inc    edi
  103f10:	84 c0                	test   al,al
  103f12:	75 ec                	jne    103f00 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xa0>
  103f14:	8a 06                	mov    al,BYTE PTR [esi]
  103f16:	84 c0                	test   al,al
  103f18:	74 1a                	je     103f34 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xd4>
  103f1a:	46                   	inc    esi
  103f1b:	90                   	nop
  103f1c:	90                   	nop
  103f1d:	90                   	nop
  103f1e:	90                   	nop
  103f1f:	90                   	nop
        write(s[a]);
  103f20:	0f be c0             	movsx  eax,al
  103f23:	50                   	push   eax
  103f24:	e8 17 d2 ff ff       	call   101140 <term::write(char)>
  103f29:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103f2c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  103f2f:	46                   	inc    esi
  103f30:	84 c0                	test   al,al
  103f32:	75 ec                	jne    103f20 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xc0>
        write(a);
  103f34:	8b 75 ec             	mov    esi,DWORD PTR [ebp-0x14]
    for (int a = 0; s[a] != 0; a++) {
  103f37:	8a 06                	mov    al,BYTE PTR [esi]
  103f39:	84 c0                	test   al,al
  103f3b:	74 17                	je     103f54 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xf4>
  103f3d:	46                   	inc    esi
  103f3e:	90                   	nop
  103f3f:	90                   	nop
        write(s[a]);
  103f40:	0f be c0             	movsx  eax,al
  103f43:	50                   	push   eax
  103f44:	e8 f7 d1 ff ff       	call   101140 <term::write(char)>
  103f49:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103f4c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  103f4f:	46                   	inc    esi
  103f50:	84 c0                	test   al,al
  103f52:	75 ec                	jne    103f40 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0xe0>
        write(a);
  103f54:	8b 75 f0             	mov    esi,DWORD PTR [ebp-0x10]
    for (int a = 0; s[a] != 0; a++) {
  103f57:	8a 06                	mov    al,BYTE PTR [esi]
  103f59:	84 c0                	test   al,al
  103f5b:	74 17                	je     103f74 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x114>
  103f5d:	46                   	inc    esi
  103f5e:	90                   	nop
  103f5f:	90                   	nop
        write(s[a]);
  103f60:	0f be c0             	movsx  eax,al
  103f63:	50                   	push   eax
  103f64:	e8 d7 d1 ff ff       	call   101140 <term::write(char)>
  103f69:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103f6c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  103f6f:	46                   	inc    esi
  103f70:	84 c0                	test   al,al
  103f72:	75 ec                	jne    103f60 <void term::write<char const*, char const*, char const*, char const*, char const*, char const*, char const*>(char const*, char const*, char const*, char const*, char const*, char const*, char const*)+0x100>
}
  103f74:	83 c4 1c             	add    esp,0x1c
  103f77:	5e                   	pop    esi
  103f78:	5f                   	pop    edi
  103f79:	5b                   	pop    ebx
  103f7a:	5d                   	pop    ebp
  103f7b:	c3                   	ret    
  103f7c:	cc                   	int3   
  103f7d:	cc                   	int3   
  103f7e:	cc                   	int3   
  103f7f:	cc                   	int3   

00103f80 <void term::fatal_error<char const*>(char const*)>:
template <class... S>[[noreturn]] void fatal_error(S... msg) {
  103f80:	55                   	push   ebp
  103f81:	89 e5                	mov    ebp,esp
  103f83:	56                   	push   esi
  103f84:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
    for (int a = 0; s[a] != 0; a++) {
  103f87:	8a 06                	mov    al,BYTE PTR [esi]
  103f89:	84 c0                	test   al,al
  103f8b:	74 17                	je     103fa4 <void term::fatal_error<char const*>(char const*)+0x24>
  103f8d:	46                   	inc    esi
  103f8e:	90                   	nop
  103f8f:	90                   	nop
        write(s[a]);
  103f90:	0f be c0             	movsx  eax,al
  103f93:	50                   	push   eax
  103f94:	e8 a7 d1 ff ff       	call   101140 <term::write(char)>
  103f99:	83 c4 04             	add    esp,0x4
    for (int a = 0; s[a] != 0; a++) {
  103f9c:	0f b6 06             	movzx  eax,BYTE PTR [esi]
  103f9f:	46                   	inc    esi
  103fa0:	84 c0                	test   al,al
  103fa2:	75 ec                	jne    103f90 <void term::fatal_error<char const*>(char const*)+0x10>
    asm("hlt");
  103fa4:	f4                   	hlt    
  103fa5:	90                   	nop
  103fa6:	90                   	nop
  103fa7:	90                   	nop
  103fa8:	90                   	nop
  103fa9:	90                   	nop
  103faa:	90                   	nop
  103fab:	90                   	nop
  103fac:	90                   	nop
  103fad:	90                   	nop
  103fae:	90                   	nop
  103faf:	90                   	nop
    while (true)
  103fb0:	eb fe                	jmp    103fb0 <void term::fatal_error<char const*>(char const*)+0x30>
  103fb2:	cc                   	int3   
  103fb3:	cc                   	int3   
  103fb4:	cc                   	int3   
  103fb5:	cc                   	int3   
  103fb6:	cc                   	int3   
  103fb7:	cc                   	int3   
  103fb8:	cc                   	int3   
  103fb9:	cc                   	int3   
  103fba:	cc                   	int3   
  103fbb:	cc                   	int3   
  103fbc:	cc                   	int3   
  103fbd:	cc                   	int3   
  103fbe:	cc                   	int3   
  103fbf:	cc                   	int3   

00103fc0 <game_of_life::game_of_life()>:
    game_of_life() {
  103fc0:	55                   	push   ebp
  103fc1:	89 e5                	mov    ebp,esp
  103fc3:	53                   	push   ebx
  103fc4:	57                   	push   edi
  103fc5:	56                   	push   esi
  103fc6:	83 e4 f8             	and    esp,0xfffffff8
  103fc9:	81 ec e0 09 00 00    	sub    esp,0x9e0
    constexpr array(U &&... p) : data_{static_cast<T>(p)...} {}
  103fcf:	68 00 02 00 00       	push   0x200
  103fd4:	6a 00                	push   0x0
  103fd6:	ff 75 08             	push   DWORD PTR [ebp+0x8]
  103fd9:	e8 a2 d2 ff ff       	call   101280 <memset>
  103fde:	83 c4 0c             	add    esp,0xc
    int index_ = 0;
  103fe1:	8d 44 24 18          	lea    eax,[esp+0x18]
  103fe5:	68 c0 09 00 00       	push   0x9c0
  103fea:	6a 00                	push   0x0
  103fec:	50                   	push   eax
  103fed:	e8 8e d2 ff ff       	call   101280 <memset>
  103ff2:	83 c4 0c             	add    esp,0xc
        mt[0] = seed & static_cast<uint32>(~0);
  103ff5:	c7 44 24 10 71 15 00 	mov    DWORD PTR [esp+0x10],0x1571
  103ffc:	00 
            mt[mti] =
  103ffd:	c7 44 24 14 96 ee 98 	mov    DWORD PTR [esp+0x14],0x4d98ee96
  104004:	4d 
  104005:	c7 44 24 18 95 f0 25 	mov    DWORD PTR [esp+0x18],0xaf25f095
  10400c:	af 
  10400d:	c7 84 24 d8 09 00 00 	mov    DWORD PTR [esp+0x9d8],0x3
  104014:	03 00 00 00 
  104018:	b9 02 00 00 00       	mov    ecx,0x2
  10401d:	b8 03 00 00 00       	mov    eax,0x3
  104022:	90                   	nop
  104023:	90                   	nop
  104024:	90                   	nop
  104025:	90                   	nop
  104026:	90                   	nop
  104027:	90                   	nop
  104028:	90                   	nop
  104029:	90                   	nop
  10402a:	90                   	nop
  10402b:	90                   	nop
  10402c:	90                   	nop
  10402d:	90                   	nop
  10402e:	90                   	nop
  10402f:	90                   	nop
                (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
  104030:	8b 4c 8c 10          	mov    ecx,DWORD PTR [esp+ecx*4+0x10]
  104034:	89 ca                	mov    edx,ecx
  104036:	c1 ea 1e             	shr    edx,0x1e
  104039:	31 ca                	xor    edx,ecx
  10403b:	69 ca 65 89 07 6c    	imul   ecx,edx,0x6c078965
  104041:	01 c1                	add    ecx,eax
            mt[mti] =
  104043:	89 4c 84 10          	mov    DWORD PTR [esp+eax*4+0x10],ecx
            mt[mti] &= static_cast<uint32>(~0);
  104047:	8b 8c 24 d8 09 00 00 	mov    ecx,DWORD PTR [esp+0x9d8]
        for (mti = 1; mti < N; mti++) {
  10404e:	8d 41 01             	lea    eax,[ecx+0x1]
  104051:	89 84 24 d8 09 00 00 	mov    DWORD PTR [esp+0x9d8],eax
  104058:	3d 70 02 00 00       	cmp    eax,0x270
  10405d:	72 d1                	jb     104030 <game_of_life::game_of_life()+0x70>
  10405f:	bb 64 00 00 00       	mov    ebx,0x64
  104064:	8d 7c 24 10          	lea    edi,[esp+0x10]
  104068:	90                   	nop
  104069:	90                   	nop
  10406a:	90                   	nop
  10406b:	90                   	nop
  10406c:	90                   	nop
  10406d:	90                   	nop
  10406e:	90                   	nop
  10406f:	90                   	nop
                auto x=rnd.next()%width;
  104070:	6a 00                	push   0x0
  104072:	57                   	push   edi
  104073:	e8 88 00 00 00       	call   104100 <rand::random_gen::next(unsigned int)>
  104078:	83 c4 08             	add    esp,0x8
  10407b:	89 c6                	mov    esi,eax
  10407d:	b9 cd cc cc cc       	mov    ecx,0xcccccccd
  104082:	f7 e1                	mul    ecx
  104084:	c1 ea 02             	shr    edx,0x2
  104087:	83 e2 f0             	and    edx,0xfffffff0
  10408a:	8d 04 92             	lea    eax,[edx+edx*4]
  10408d:	29 c6                	sub    esi,eax
                auto y=rnd.next()%height;
  10408f:	6a 00                	push   0x0
  104091:	57                   	push   edi
  104092:	e8 69 00 00 00       	call   104100 <rand::random_gen::next(unsigned int)>
  104097:	83 c4 08             	add    esp,0x8
  10409a:	89 c1                	mov    ecx,eax
  10409c:	ba 1f 85 eb 51       	mov    edx,0x51eb851f
  1040a1:	f7 e2                	mul    edx
  1040a3:	c1 ea 03             	shr    edx,0x3
  1040a6:	8d 04 92             	lea    eax,[edx+edx*4]
  1040a9:	8d 04 80             	lea    eax,[eax+eax*4]
  1040ac:	29 c1                	sub    ecx,eax
                board_[width * y + x]=1;
  1040ae:	8d 04 89             	lea    eax,[ecx+ecx*4]
  1040b1:	c1 e0 04             	shl    eax,0x4
  1040b4:	01 f0                	add    eax,esi
        return bit_member(*this, static_cast<int>(i));
  1040b6:	50                   	push   eax
  1040b7:	ff 75 08             	push   DWORD PTR [ebp+0x8]
  1040ba:	8d 44 24 08          	lea    eax,[esp+0x8]
  1040be:	50                   	push   eax
  1040bf:	e8 bc 01 00 00       	call   104280 <mem::bit_sequence<2000>::bit_member::bit_member(mem::bit_sequence<2000>&, int)>
  1040c4:	83 c4 0c             	add    esp,0xc
            b_.bytes_[pos_ / 8] &= (p << (pos_ % 8));
  1040c7:	8b 34 24             	mov    esi,DWORD PTR [esp]
  1040ca:	8b 44 24 04          	mov    eax,DWORD PTR [esp+0x4]
  1040ce:	89 c1                	mov    ecx,eax
  1040d0:	80 e1 07             	and    cl,0x7
  1040d3:	ba 01 00 00 00       	mov    edx,0x1
  1040d8:	d3 e2                	shl    edx,cl
  1040da:	8d 48 07             	lea    ecx,[eax+0x7]
  1040dd:	85 c0                	test   eax,eax
  1040df:	0f 49 c8             	cmovns ecx,eax
  1040e2:	c1 f9 03             	sar    ecx,0x3
  1040e5:	20 14 0e             	and    BYTE PTR [esi+ecx*1],dl
            for(int a=0; a<100; a++) {
  1040e8:	4b                   	dec    ebx
  1040e9:	75 85                	jne    104070 <game_of_life::game_of_life()+0xb0>
    }
  1040eb:	8d 65 f4             	lea    esp,[ebp-0xc]
  1040ee:	5e                   	pop    esi
  1040ef:	5f                   	pop    edi
  1040f0:	5b                   	pop    ebx
  1040f1:	5d                   	pop    ebp
  1040f2:	c3                   	ret    
  1040f3:	cc                   	int3   
  1040f4:	cc                   	int3   
  1040f5:	cc                   	int3   
  1040f6:	cc                   	int3   
  1040f7:	cc                   	int3   
  1040f8:	cc                   	int3   
  1040f9:	cc                   	int3   
  1040fa:	cc                   	int3   
  1040fb:	cc                   	int3   
  1040fc:	cc                   	int3   
  1040fd:	cc                   	int3   
  1040fe:	cc                   	int3   
  1040ff:	cc                   	int3   

00104100 <rand::random_gen::next(unsigned int)>:
        }
    }

    uint32 next(uint32 limit = 0) {
  104100:	55                   	push   ebp
  104101:	89 e5                	mov    ebp,esp
  104103:	53                   	push   ebx
  104104:	57                   	push   edi
  104105:	56                   	push   esi
  104106:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
  104109:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
        uint32 y = 0;

        if (mti >= N) { /* generate N words at one time */
  10410c:	8b 90 c8 09 00 00    	mov    edx,DWORD PTR [eax+0x9c8]
  104112:	81 fa 70 02 00 00    	cmp    edx,0x270
  104118:	0f 82 d7 00 00 00    	jb     1041f5 <rand::random_gen::next(unsigned int)+0xf5>
            uint32 kk = 0;

            for (; kk < N - M; kk++) {
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  10411e:	8b 30                	mov    esi,DWORD PTR [eax]
  104120:	ba 1d ff ff ff       	mov    edx,0xffffff1d
  104125:	90                   	nop
  104126:	90                   	nop
  104127:	90                   	nop
  104128:	90                   	nop
  104129:	90                   	nop
  10412a:	90                   	nop
  10412b:	90                   	nop
  10412c:	90                   	nop
  10412d:	90                   	nop
  10412e:	90                   	nop
  10412f:	90                   	nop
  104130:	81 e6 00 00 00 80    	and    esi,0x80000000
  104136:	8b bc 90 90 03 00 00 	mov    edi,DWORD PTR [eax+edx*4+0x390]
  10413d:	89 fb                	mov    ebx,edi
  10413f:	81 e3 fe ff ff 7f    	and    ebx,0x7ffffffe
  104145:	09 f3                	or     ebx,esi
                mt[kk] = mt[kk + M] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  104147:	d1 eb                	shr    ebx,1
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  104149:	89 fe                	mov    esi,edi
                mt[kk] = mt[kk + M] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  10414b:	83 e7 01             	and    edi,0x1
    template <class I> constexpr auto operator[](I i) const { return data_[i]; }
  10414e:	8b 3c bd d8 00 10 00 	mov    edi,DWORD PTR [edi*4+0x1000d8]
  104155:	33 bc 90 c0 09 00 00 	xor    edi,DWORD PTR [eax+edx*4+0x9c0]
  10415c:	31 df                	xor    edi,ebx
  10415e:	89 bc 90 8c 03 00 00 	mov    DWORD PTR [eax+edx*4+0x38c],edi
            for (; kk < N - M; kk++) {
  104165:	42                   	inc    edx
  104166:	75 c8                	jne    104130 <rand::random_gen::next(unsigned int)+0x30>
            }
            for (; kk < N - 1; kk++) {
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  104168:	8b b0 8c 03 00 00    	mov    esi,DWORD PTR [eax+0x38c]
  10416e:	ba 74 fe ff ff       	mov    edx,0xfffffe74
  104173:	90                   	nop
  104174:	90                   	nop
  104175:	90                   	nop
  104176:	90                   	nop
  104177:	90                   	nop
  104178:	90                   	nop
  104179:	90                   	nop
  10417a:	90                   	nop
  10417b:	90                   	nop
  10417c:	90                   	nop
  10417d:	90                   	nop
  10417e:	90                   	nop
  10417f:	90                   	nop
  104180:	81 e6 00 00 00 80    	and    esi,0x80000000
  104186:	8b bc 90 c0 09 00 00 	mov    edi,DWORD PTR [eax+edx*4+0x9c0]
  10418d:	89 fb                	mov    ebx,edi
  10418f:	81 e3 fe ff ff 7f    	and    ebx,0x7ffffffe
  104195:	09 f3                	or     ebx,esi
                mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  104197:	d1 eb                	shr    ebx,1
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
  104199:	89 fe                	mov    esi,edi
                mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  10419b:	83 e7 01             	and    edi,0x1
  10419e:	8b 3c bd d8 00 10 00 	mov    edi,DWORD PTR [edi*4+0x1000d8]
  1041a5:	33 bc 90 30 06 00 00 	xor    edi,DWORD PTR [eax+edx*4+0x630]
  1041ac:	31 df                	xor    edi,ebx
  1041ae:	89 bc 90 bc 09 00 00 	mov    DWORD PTR [eax+edx*4+0x9bc],edi
            for (; kk < N - 1; kk++) {
  1041b5:	42                   	inc    edx
  1041b6:	75 c8                	jne    104180 <rand::random_gen::next(unsigned int)+0x80>
  1041b8:	ba 00 00 00 80       	mov    edx,0x80000000
            }
            y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);
  1041bd:	23 90 bc 09 00 00    	and    edx,DWORD PTR [eax+0x9bc]
  1041c3:	8b 30                	mov    esi,DWORD PTR [eax]
  1041c5:	89 f7                	mov    edi,esi
  1041c7:	81 e7 fe ff ff 7f    	and    edi,0x7ffffffe
  1041cd:	09 d7                	or     edi,edx
            mt[N - 1] = mt[M - 1] ^ (y >> 1) ^ MAG01[y & 0x1UL];
  1041cf:	d1 ef                	shr    edi,1
  1041d1:	83 e6 01             	and    esi,0x1
  1041d4:	8b 14 b5 d8 00 10 00 	mov    edx,DWORD PTR [esi*4+0x1000d8]
  1041db:	33 90 30 06 00 00    	xor    edx,DWORD PTR [eax+0x630]
  1041e1:	31 fa                	xor    edx,edi
  1041e3:	89 90 bc 09 00 00    	mov    DWORD PTR [eax+0x9bc],edx

            mti = 0;
  1041e9:	c7 80 c8 09 00 00 00 	mov    DWORD PTR [eax+0x9c8],0x0
  1041f0:	00 00 00 
  1041f3:	31 d2                	xor    edx,edx
        }

        y = mt[mti++];
  1041f5:	8d 72 01             	lea    esi,[edx+0x1]
  1041f8:	89 b0 c8 09 00 00    	mov    DWORD PTR [eax+0x9c8],esi
  1041fe:	8b 04 90             	mov    eax,DWORD PTR [eax+edx*4]

        /* Tempering */
        y ^= (y >> 11);
  104201:	89 c2                	mov    edx,eax
  104203:	c1 ea 0b             	shr    edx,0xb
  104206:	31 c2                	xor    edx,eax
        y ^= (y << 7) & 0x9d2c5680UL;
  104208:	89 d0                	mov    eax,edx
  10420a:	c1 e0 07             	shl    eax,0x7
  10420d:	25 80 56 2c 9d       	and    eax,0x9d2c5680
  104212:	31 d0                	xor    eax,edx
        y ^= (y << 15) & 0xefc60000UL;
  104214:	89 c2                	mov    edx,eax
  104216:	c1 e2 0f             	shl    edx,0xf
  104219:	81 e2 00 00 c6 ef    	and    edx,0xefc60000
  10421f:	31 c2                	xor    edx,eax
        y ^= (y >> 18);
  104221:	89 d0                	mov    eax,edx
  104223:	c1 e8 12             	shr    eax,0x12
  104226:	31 d0                	xor    eax,edx

        if (limit == 0)
  104228:	85 c9                	test   ecx,ecx
  10422a:	74 06                	je     104232 <rand::random_gen::next(unsigned int)+0x132>
            return y;
        else
            return y % limit;
  10422c:	31 d2                	xor    edx,edx
  10422e:	f7 f1                	div    ecx
  104230:	89 d0                	mov    eax,edx
    }
  104232:	5e                   	pop    esi
  104233:	5f                   	pop    edi
  104234:	5b                   	pop    ebx
  104235:	5d                   	pop    ebp
  104236:	c3                   	ret    
  104237:	cc                   	int3   
  104238:	cc                   	int3   
  104239:	cc                   	int3   
  10423a:	cc                   	int3   
  10423b:	cc                   	int3   
  10423c:	cc                   	int3   
  10423d:	cc                   	int3   
  10423e:	cc                   	int3   
  10423f:	cc                   	int3   

00104240 <mem::bit_sequence<1000>::bit_member::bit_member(mem::bit_sequence<1000>&, int)>:
            : b_(b), pos_(pos), val_(b[pos]) {}
  104240:	55                   	push   ebp
  104241:	89 e5                	mov    ebp,esp
  104243:	56                   	push   esi
  104244:	83 e4 f8             	and    esp,0xfffffff8
  104247:	83 ec 10             	sub    esp,0x10
  10424a:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
  10424d:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
  104250:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  104253:	89 0e                	mov    DWORD PTR [esi],ecx
  104255:	89 46 04             	mov    DWORD PTR [esi+0x4],eax
  104258:	89 e2                	mov    edx,esp
        return bit_member(*this, static_cast<int>(i));
  10425a:	50                   	push   eax
  10425b:	51                   	push   ecx
  10425c:	52                   	push   edx
  10425d:	e8 de ff ff ff       	call   104240 <mem::bit_sequence<1000>::bit_member::bit_member(mem::bit_sequence<1000>&, int)>
  104262:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  104265:	8a 44 24 08          	mov    al,BYTE PTR [esp+0x8]
            : b_(b), pos_(pos), val_(b[pos]) {}
  104269:	88 46 08             	mov    BYTE PTR [esi+0x8],al
  10426c:	8d 65 fc             	lea    esp,[ebp-0x4]
  10426f:	5e                   	pop    esi
  104270:	5d                   	pop    ebp
  104271:	c3                   	ret    
  104272:	cc                   	int3   
  104273:	cc                   	int3   
  104274:	cc                   	int3   
  104275:	cc                   	int3   
  104276:	cc                   	int3   
  104277:	cc                   	int3   
  104278:	cc                   	int3   
  104279:	cc                   	int3   
  10427a:	cc                   	int3   
  10427b:	cc                   	int3   
  10427c:	cc                   	int3   
  10427d:	cc                   	int3   
  10427e:	cc                   	int3   
  10427f:	cc                   	int3   

00104280 <mem::bit_sequence<2000>::bit_member::bit_member(mem::bit_sequence<2000>&, int)>:
  104280:	55                   	push   ebp
  104281:	89 e5                	mov    ebp,esp
  104283:	56                   	push   esi
  104284:	83 e4 f8             	and    esp,0xfffffff8
  104287:	83 ec 10             	sub    esp,0x10
  10428a:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
  10428d:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
  104290:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  104293:	89 0e                	mov    DWORD PTR [esi],ecx
  104295:	89 46 04             	mov    DWORD PTR [esi+0x4],eax
  104298:	89 e2                	mov    edx,esp
        return bit_member(*this, static_cast<int>(i));
  10429a:	50                   	push   eax
  10429b:	51                   	push   ecx
  10429c:	52                   	push   edx
  10429d:	e8 de ff ff ff       	call   104280 <mem::bit_sequence<2000>::bit_member::bit_member(mem::bit_sequence<2000>&, int)>
  1042a2:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  1042a5:	8a 44 24 08          	mov    al,BYTE PTR [esp+0x8]
            : b_(b), pos_(pos), val_(b[pos]) {}
  1042a9:	88 46 08             	mov    BYTE PTR [esi+0x8],al
  1042ac:	8d 65 fc             	lea    esp,[ebp-0x4]
  1042af:	5e                   	pop    esi
  1042b0:	5d                   	pop    ebp
  1042b1:	c3                   	ret    
  1042b2:	cc                   	int3   
  1042b3:	cc                   	int3   
  1042b4:	cc                   	int3   
  1042b5:	cc                   	int3   
  1042b6:	cc                   	int3   
  1042b7:	cc                   	int3   
  1042b8:	cc                   	int3   
  1042b9:	cc                   	int3   
  1042ba:	cc                   	int3   
  1042bb:	cc                   	int3   
  1042bc:	cc                   	int3   
  1042bd:	cc                   	int3   
  1042be:	cc                   	int3   
  1042bf:	cc                   	int3   

001042c0 <game_of_life::step()>:
    void step() {
  1042c0:	55                   	push   ebp
  1042c1:	89 e5                	mov    ebp,esp
  1042c3:	53                   	push   ebx
  1042c4:	57                   	push   edi
  1042c5:	56                   	push   esi
  1042c6:	83 e4 f8             	and    esp,0xfffffff8
  1042c9:	83 ec 38             	sub    esp,0x38
  1042cc:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
        term::clear();
  1042cf:	e8 7c cd ff ff       	call   101050 <term::clear()>
  1042d4:	81 c6 00 01 00 00    	add    esi,0x100
  1042da:	31 db                	xor    ebx,ebx
  1042dc:	89 34 24             	mov    DWORD PTR [esp],esi
  1042df:	eb 1d                	jmp    1042fe <game_of_life::step()+0x3e>
  1042e1:	90                   	nop
  1042e2:	90                   	nop
  1042e3:	90                   	nop
  1042e4:	90                   	nop
  1042e5:	90                   	nop
  1042e6:	90                   	nop
  1042e7:	90                   	nop
  1042e8:	90                   	nop
  1042e9:	90                   	nop
  1042ea:	90                   	nop
  1042eb:	90                   	nop
  1042ec:	90                   	nop
  1042ed:	90                   	nop
  1042ee:	90                   	nop
  1042ef:	90                   	nop
  1042f0:	8b 5c 24 04          	mov    ebx,DWORD PTR [esp+0x4]
        for (int x = 0; x < width; x++) {
  1042f4:	43                   	inc    ebx
  1042f5:	83 fb 50             	cmp    ebx,0x50
  1042f8:	0f 84 b2 00 00 00    	je     1043b0 <game_of_life::step()+0xf0>
  1042fe:	89 5c 24 04          	mov    DWORD PTR [esp+0x4],ebx
  104302:	31 ff                	xor    edi,edi
  104304:	eb 5e                	jmp    104364 <game_of_life::step()+0xa4>
  104306:	90                   	nop
  104307:	90                   	nop
  104308:	90                   	nop
  104309:	90                   	nop
  10430a:	90                   	nop
  10430b:	90                   	nop
  10430c:	90                   	nop
  10430d:	90                   	nop
  10430e:	90                   	nop
  10430f:	90                   	nop
        return bit_member(*this, static_cast<int>(i));
  104310:	53                   	push   ebx
  104311:	56                   	push   esi
  104312:	8d 44 24 20          	lea    eax,[esp+0x20]
  104316:	50                   	push   eax
  104317:	e8 64 ff ff ff       	call   104280 <mem::bit_sequence<2000>::bit_member::bit_member(mem::bit_sequence<2000>&, int)>
  10431c:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  10431f:	0f b6 74 24 20       	movzx  esi,BYTE PTR [esp+0x20]
        return bit_member(*this, static_cast<int>(i));
  104324:	53                   	push   ebx
  104325:	ff 74 24 04          	push   DWORD PTR [esp+0x4]
  104329:	8d 44 24 10          	lea    eax,[esp+0x10]
  10432d:	50                   	push   eax
  10432e:	e8 4d ff ff ff       	call   104280 <mem::bit_sequence<2000>::bit_member::bit_member(mem::bit_sequence<2000>&, int)>
  104333:	83 c4 0c             	add    esp,0xc
  104336:	89 f0                	mov    eax,esi
            b_.bytes_[pos_ / 8] &= (p << (pos_ % 8));
  104338:	83 f0 01             	xor    eax,0x1
  10433b:	8b 74 24 08          	mov    esi,DWORD PTR [esp+0x8]
  10433f:	8b 54 24 0c          	mov    edx,DWORD PTR [esp+0xc]
  104343:	89 d1                	mov    ecx,edx
  104345:	80 e1 07             	and    cl,0x7
  104348:	d3 e0                	shl    eax,cl
  10434a:	8d 4a 07             	lea    ecx,[edx+0x7]
  10434d:	85 d2                	test   edx,edx
  10434f:	0f 49 ca             	cmovns ecx,edx
  104352:	c1 f9 03             	sar    ecx,0x3
  104355:	20 04 0e             	and    BYTE PTR [esi+ecx*1],al
  104358:	8b 34 24             	mov    esi,DWORD PTR [esp]
            for (int y = 0; y < height; y++) {
  10435b:	47                   	inc    edi
  10435c:	83 c3 50             	add    ebx,0x50
  10435f:	83 ff 19             	cmp    edi,0x19
  104362:	74 8c                	je     1042f0 <game_of_life::step()+0x30>
        return bit_member(*this, static_cast<int>(i));
  104364:	53                   	push   ebx
  104365:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  104368:	50                   	push   eax
  104369:	8d 44 24 30          	lea    eax,[esp+0x30]
  10436d:	50                   	push   eax
  10436e:	e8 0d ff ff ff       	call   104280 <mem::bit_sequence<2000>::bit_member::bit_member(mem::bit_sequence<2000>&, int)>
  104373:	83 c4 0c             	add    esp,0xc
                int n = neighbours(x, y);
  104376:	57                   	push   edi
  104377:	ff 74 24 08          	push   DWORD PTR [esp+0x8]
  10437b:	ff 75 08             	push   DWORD PTR [ebp+0x8]
  10437e:	e8 9d 00 00 00       	call   104420 <game_of_life::neighbours(int, int) const>
  104383:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  104386:	80 7c 24 30 00       	cmp    BYTE PTR [esp+0x30],0x0
  10438b:	0f 94 c1             	sete   cl
                if ((c == 1 && (n < 2 || n > 3)) || (c == 0 && n == 3))
  10438e:	89 c2                	mov    edx,eax
  104390:	83 e2 fe             	and    edx,0xfffffffe
  104393:	83 fa 02             	cmp    edx,0x2
  104396:	0f 94 c2             	sete   dl
  104399:	83 f8 03             	cmp    eax,0x3
  10439c:	0f 94 c0             	sete   al
  10439f:	84 c8                	test   al,cl
  1043a1:	0f 85 69 ff ff ff    	jne    104310 <game_of_life::step()+0x50>
  1043a7:	08 d1                	or     cl,dl
  1043a9:	75 b0                	jne    10435b <game_of_life::step()+0x9b>
  1043ab:	e9 60 ff ff ff       	jmp    104310 <game_of_life::step()+0x50>
  1043b0:	31 f6                	xor    esi,esi
  1043b2:	8d 7c 24 08          	lea    edi,[esp+0x8]
  1043b6:	90                   	nop
  1043b7:	90                   	nop
  1043b8:	90                   	nop
  1043b9:	90                   	nop
  1043ba:	90                   	nop
  1043bb:	90                   	nop
  1043bc:	90                   	nop
  1043bd:	90                   	nop
  1043be:	90                   	nop
  1043bf:	90                   	nop
        return bit_member(*this, static_cast<int>(i));
  1043c0:	56                   	push   esi
  1043c1:	ff 74 24 04          	push   DWORD PTR [esp+0x4]
  1043c5:	8d 44 24 20          	lea    eax,[esp+0x20]
  1043c9:	50                   	push   eax
  1043ca:	e8 b1 fe ff ff       	call   104280 <mem::bit_sequence<2000>::bit_member::bit_member(mem::bit_sequence<2000>&, int)>
  1043cf:	83 c4 0c             	add    esp,0xc
        constexpr operator bool() const { return val_; }
  1043d2:	0f b6 5c 24 20       	movzx  ebx,BYTE PTR [esp+0x20]
        return bit_member(*this, static_cast<int>(i));
  1043d7:	56                   	push   esi
  1043d8:	ff 75 08             	push   DWORD PTR [ebp+0x8]
  1043db:	57                   	push   edi
  1043dc:	e8 9f fe ff ff       	call   104280 <mem::bit_sequence<2000>::bit_member::bit_member(mem::bit_sequence<2000>&, int)>
  1043e1:	83 c4 0c             	add    esp,0xc
            b_.bytes_[pos_ / 8] &= (p << (pos_ % 8));
  1043e4:	8b 54 24 08          	mov    edx,DWORD PTR [esp+0x8]
  1043e8:	8b 44 24 0c          	mov    eax,DWORD PTR [esp+0xc]
  1043ec:	89 c1                	mov    ecx,eax
  1043ee:	80 e1 07             	and    cl,0x7
  1043f1:	d3 e3                	shl    ebx,cl
  1043f3:	8d 48 07             	lea    ecx,[eax+0x7]
  1043f6:	85 c0                	test   eax,eax
  1043f8:	0f 49 c8             	cmovns ecx,eax
  1043fb:	c1 f9 03             	sar    ecx,0x3
  1043fe:	20 1c 0a             	and    BYTE PTR [edx+ecx*1],bl
        for (int a = 0; a < board_.size(); a++) {
  104401:	46                   	inc    esi
  104402:	81 fe d0 07 00 00    	cmp    esi,0x7d0
  104408:	75 b6                	jne    1043c0 <game_of_life::step()+0x100>
    }
  10440a:	8d 65 f4             	lea    esp,[ebp-0xc]
  10440d:	5e                   	pop    esi
  10440e:	5f                   	pop    edi
  10440f:	5b                   	pop    ebx
  104410:	5d                   	pop    ebp
  104411:	c3                   	ret    
  104412:	cc                   	int3   
  104413:	cc                   	int3   
  104414:	cc                   	int3   
  104415:	cc                   	int3   
  104416:	cc                   	int3   
  104417:	cc                   	int3   
  104418:	cc                   	int3   
  104419:	cc                   	int3   
  10441a:	cc                   	int3   
  10441b:	cc                   	int3   
  10441c:	cc                   	int3   
  10441d:	cc                   	int3   
  10441e:	cc                   	int3   
  10441f:	cc                   	int3   

00104420 <game_of_life::neighbours(int, int) const>:
        // screen.write(width + 1, 1, "Alive: " + str(alive));
        // screen.write(width + 1, 2, "Max alive: " + str(maxAlive));
        // screen.refresh();
    }

    int neighbours(int x, int y) const {
  104420:	55                   	push   ebp
  104421:	89 e5                	mov    ebp,esp
  104423:	53                   	push   ebx
  104424:	57                   	push   edi
  104425:	56                   	push   esi
  104426:	83 ec 08             	sub    esp,0x8
  104429:	8b 75 10             	mov    esi,DWORD PTR [ebp+0x10]
  10442c:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
  10442f:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
        int r = 0;
        if (x > 0) {
  104432:	85 d2                	test   edx,edx
  104434:	0f 8e 83 00 00 00    	jle    1044bd <game_of_life::neighbours(int, int) const+0x9d>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  10443a:	89 f0                	mov    eax,esi
  10443c:	c1 e0 04             	shl    eax,0x4
  10443f:	8d 3c 80             	lea    edi,[eax+eax*4]
  104442:	8d 44 3a ff          	lea    eax,[edx+edi*1-0x1]
        auto b = bytes_[i / 8];
  104446:	8d 5c 3a 06          	lea    ebx,[edx+edi*1+0x6]
  10444a:	85 c0                	test   eax,eax
  10444c:	0f 49 d8             	cmovns ebx,eax
  10444f:	c1 fb 03             	sar    ebx,0x3
  104452:	0f b6 1c 19          	movzx  ebx,BYTE PTR [ecx+ebx*1]
        return (b & (1 << (i % 8))) != 0;
  104456:	24 07                	and    al,0x7
  104458:	0f b6 c8             	movzx  ecx,al
  10445b:	31 c0                	xor    eax,eax
  10445d:	0f a3 cb             	bt     ebx,ecx
  104460:	0f 92 c0             	setb   al
            r += board(x - 1, y);
            if (y > 0)
  104463:	85 f6                	test   esi,esi
  104465:	7e 29                	jle    104490 <game_of_life::neighbours(int, int) const+0x70>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  104467:	8d 5c 3a af          	lea    ebx,[edx+edi*1-0x51]
        auto b = bytes_[i / 8];
  10446b:	8d 4c 3a b6          	lea    ecx,[edx+edi*1-0x4a]
  10446f:	85 db                	test   ebx,ebx
  104471:	0f 49 cb             	cmovns ecx,ebx
  104474:	c1 f9 03             	sar    ecx,0x3
  104477:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  10447a:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  10447e:	80 e3 07             	and    bl,0x7
  104481:	0f b6 db             	movzx  ebx,bl
  104484:	0f a3 d9             	bt     ecx,ebx
                r += board(x - 1, y - 1);
  104487:	83 d0 00             	adc    eax,0x0
            if (y < height - 1)
  10448a:	83 7d 10 17          	cmp    DWORD PTR [ebp+0x10],0x17
  10448e:	7f 23                	jg     1044b3 <game_of_life::neighbours(int, int) const+0x93>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  104490:	8d 5c 3a 4f          	lea    ebx,[edx+edi*1+0x4f]
        auto b = bytes_[i / 8];
  104494:	8d 4c 3a 56          	lea    ecx,[edx+edi*1+0x56]
  104498:	85 db                	test   ebx,ebx
  10449a:	0f 49 cb             	cmovns ecx,ebx
  10449d:	c1 f9 03             	sar    ecx,0x3
  1044a0:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  1044a3:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  1044a7:	80 e3 07             	and    bl,0x7
  1044aa:	0f b6 db             	movzx  ebx,bl
  1044ad:	0f a3 d9             	bt     ecx,ebx
                r += board(x - 1, y + 1);
  1044b0:	83 d0 00             	adc    eax,0x0
        }
        if (x < width - 1) {
  1044b3:	83 fa 4e             	cmp    edx,0x4e
  1044b6:	7e 0f                	jle    1044c7 <game_of_life::neighbours(int, int) const+0xa7>
  1044b8:	e9 a4 00 00 00       	jmp    104561 <game_of_life::neighbours(int, int) const+0x141>
  1044bd:	89 f0                	mov    eax,esi
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  1044bf:	c1 e0 04             	shl    eax,0x4
  1044c2:	8d 3c 80             	lea    edi,[eax+eax*4]
  1044c5:	31 c0                	xor    eax,eax
  1044c7:	8d 5c 3a 01          	lea    ebx,[edx+edi*1+0x1]
        auto b = bytes_[i / 8];
  1044cb:	8d 4c 3a 08          	lea    ecx,[edx+edi*1+0x8]
  1044cf:	85 db                	test   ebx,ebx
  1044d1:	0f 49 cb             	cmovns ecx,ebx
  1044d4:	c1 f9 03             	sar    ecx,0x3
  1044d7:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  1044da:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  1044de:	80 e3 07             	and    bl,0x7
  1044e1:	0f b6 db             	movzx  ebx,bl
  1044e4:	0f a3 d9             	bt     ecx,ebx
            r += board(x + 1, y);
  1044e7:	83 d0 00             	adc    eax,0x0
  1044ea:	89 d1                	mov    ecx,edx
  1044ec:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
            if (y > 0)
  1044ef:	85 d2                	test   edx,edx
  1044f1:	89 7d ec             	mov    DWORD PTR [ebp-0x14],edi
  1044f4:	7e 3d                	jle    104533 <game_of_life::neighbours(int, int) const+0x113>
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  1044f6:	8d 5c 39 b1          	lea    ebx,[ecx+edi*1-0x4f]
  1044fa:	89 c2                	mov    edx,eax
  1044fc:	89 f8                	mov    eax,edi
  1044fe:	89 cf                	mov    edi,ecx
        auto b = bytes_[i / 8];
  104500:	8d 4c 01 b8          	lea    ecx,[ecx+eax*1-0x48]
  104504:	85 db                	test   ebx,ebx
  104506:	0f 49 cb             	cmovns ecx,ebx
  104509:	c1 f9 03             	sar    ecx,0x3
  10450c:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  104510:	80 e3 07             	and    bl,0x7
  104513:	0f b6 db             	movzx  ebx,bl
  104516:	0f a3 d9             	bt     ecx,ebx
                r += board(x + 1, y - 1);
  104519:	83 d2 00             	adc    edx,0x0
  10451c:	89 55 f0             	mov    DWORD PTR [ebp-0x10],edx
            if (y < height - 1)
  10451f:	83 7d 10 17          	cmp    DWORD PTR [ebp+0x10],0x17
  104523:	7e 13                	jle    104538 <game_of_life::neighbours(int, int) const+0x118>
  104525:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  104528:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
  10452b:	8b 7d ec             	mov    edi,DWORD PTR [ebp-0x14]
  10452e:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
  104531:	eb 40                	jmp    104573 <game_of_life::neighbours(int, int) const+0x153>
  104533:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
  104536:	89 cf                	mov    edi,ecx
  104538:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  10453b:	8d 5c 07 51          	lea    ebx,[edi+eax*1+0x51]
        auto b = bytes_[i / 8];
  10453f:	8d 4c 07 58          	lea    ecx,[edi+eax*1+0x58]
  104543:	85 db                	test   ebx,ebx
  104545:	0f 49 cb             	cmovns ecx,ebx
  104548:	c1 f9 03             	sar    ecx,0x3
  10454b:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  10454e:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  104552:	80 e3 07             	and    bl,0x7
  104555:	0f b6 fb             	movzx  edi,bl
  104558:	0f a3 f9             	bt     ecx,edi
  10455b:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
                r += board(x + 1, y + 1);
  10455e:	83 d0 00             	adc    eax,0x0
  104561:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
  104564:	89 d1                	mov    ecx,edx
  104566:	c1 e1 04             	shl    ecx,0x4
        }
        if (y > 0) {
  104569:	85 d2                	test   edx,edx
  10456b:	8d 3c 89             	lea    edi,[ecx+ecx*4]
  10456e:	8b 75 08             	mov    esi,DWORD PTR [ebp+0x8]
  104571:	7e 28                	jle    10459b <game_of_life::neighbours(int, int) const+0x17b>
  104573:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  104576:	8d 5c 39 b0          	lea    ebx,[ecx+edi*1-0x50]
        auto b = bytes_[i / 8];
  10457a:	8d 4c 39 b7          	lea    ecx,[ecx+edi*1-0x49]
  10457e:	85 db                	test   ebx,ebx
  104580:	0f 49 cb             	cmovns ecx,ebx
  104583:	c1 f9 03             	sar    ecx,0x3
  104586:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  10458a:	80 e3 07             	and    bl,0x7
  10458d:	0f b6 db             	movzx  ebx,bl
  104590:	0f a3 d9             	bt     ecx,ebx
            r += board(x, y - 1);
  104593:	83 d0 00             	adc    eax,0x0
        }
        if (y < height - 1) {
  104596:	83 fa 17             	cmp    edx,0x17
  104599:	7f 23                	jg     1045be <game_of_life::neighbours(int, int) const+0x19e>
  10459b:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
    constexpr bool board(int x, int y) const { return board_[width * y + x]; }
  10459e:	8d 5c 39 50          	lea    ebx,[ecx+edi*1+0x50]
        auto b = bytes_[i / 8];
  1045a2:	8d 4c 39 57          	lea    ecx,[ecx+edi*1+0x57]
  1045a6:	85 db                	test   ebx,ebx
  1045a8:	0f 49 cb             	cmovns ecx,ebx
  1045ab:	c1 f9 03             	sar    ecx,0x3
  1045ae:	0f b6 0c 0e          	movzx  ecx,BYTE PTR [esi+ecx*1]
        return (b & (1 << (i % 8))) != 0;
  1045b2:	80 e3 07             	and    bl,0x7
  1045b5:	0f b6 d3             	movzx  edx,bl
  1045b8:	0f a3 d1             	bt     ecx,edx
            r += board(x, y + 1);
  1045bb:	83 d0 00             	adc    eax,0x0
        }
        return r;
  1045be:	83 c4 08             	add    esp,0x8
  1045c1:	5e                   	pop    esi
  1045c2:	5f                   	pop    edi
  1045c3:	5b                   	pop    ebx
  1045c4:	5d                   	pop    ebp
  1045c5:	c3                   	ret    
